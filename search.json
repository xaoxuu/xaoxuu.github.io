[{"title":"苹果设计素材官方下载地址","path":"/blog/20231213/","content":"废话不多说直接上链接，包含 iOS、iPadOS、macOS、tvOS、visionOS、watchOS 的组件库、设计模版、官方字体、SF 符号、苹果全系列产品模型图、商标等资源下载。 Apple Design Resourceshttps://developer.apple.com/cn/design/resources/ 奇怪的现象 每到新品或者新系统发布的时间，都会有很多博主或者自媒体下载一下资源，加个水印（或者不加）然后放到公众号或者哪里，在短视频或者B站进行导流，文章阅读量也很可观。我一直都无法理解，官方资源那么全和干净，为什么要找别人加过料的呢？询问 AI 得出以下答案： 一些博主或自媒体可能会下载官方资源并进行二次加工，主要是为了吸引更多的关注和流量。以下是一些可能的原因： 个性化内容：他们可能认为通过添加水印、进行剪辑或整合等方式，可以为资源增加一些个性化的元素，使其与其他内容区别开来，吸引更多人的关注。 方便用户获取：一些用户可能不知道如何直接从官方渠道获取资源，或者觉得在官方渠道查找和下载资源比较麻烦。因此，这些博主或自媒体提供加过料的资源，方便用户获取。 增加流量和收入：通过在公众号、短视频或 B 站等平台发布加过料的资源，并进行导流，可以吸引更多的用户关注他们的账号或频道，从而增加流量和收入。 然而，使用加过料的资源也存在一些风险和问题。首先，这些资源可能存在版权问题，使用未经授权的资源可能会导致法律纠纷。其次，加过料的资源可能会包含恶意软件、广告或其他不安全的元素，给用户带来安全隐患。 因此，如果需要使用相关资源，建议尽量从官方渠道获取，以确保资源的安全性和可靠性。同时，也应该尊重资源的版权，避免使用未经授权的资源。 第一点可能有点牵强了，我觉得他们的主要目的是第3点，第2点则是水文的高情商说法，虽然一定程度上确实方便了用户获取，但是直接放官方链接不是更方便么，导流到别的地方分明是另有所图，尤其是对别人免费公开的资源加水印再分发的行为！ 不要一边抵制内容农场，一边自己去做内容农场。 如果担心官方链接失效或者下载过慢，可以原封不动打包转存到免费的平台如网盘、GitHub、私有云等然后在文章里直接贴链接都是很赞的呀。 如何屏蔽/过滤低质量网站 按照枋柚梓大佬的步骤配置一下就好： https://inkss.cn/post/8204c0ab/https://inkss.cn/post/8204c0ab/ 过滤掉C某某N之后搜索效率直接翻倍了","tags":["apple"],"categories":["经验分享"]},{"title":"博客入门：每个人的独立博客","path":"/blog/20221217/","content":"本文面向从未用过独立博客，也不了解 markdown 和 git 的用户，旨在普及独立博客技术，顺序经过调整以降低首次上手难度。有相关经验的读者可以自行跳过某些步骤。 什么是独立博客？独立博客就是区别于平台博客（如简书、知乎、豆瓣）的一种方案，特点即： 域名独立（地址是什么） 空间独立（部署到哪里） 内容独立（自己即审核） 通俗来说就是 住自己的房子 与 寄人篱下 的区别。所以，我们为什么需要一个独立博客呢？ 希望数据属于自己，随时可以更换技术方案，而非交给某个平台，与某个平台共存亡。 希望自己设计，或不满足于平台支持的格式，希望有更多的内容表达方式。 希望有自己的短域名，任何人输入域名就进入自己的空间。 独立博客可以有无数种技术方案，本文采用 GitHub + Hexo + Stellar 方案进行讲解。 体验 hello world使用 macOS 系统的朋友可以在 终端 中执行下面这行命令，体验如何快速搭建一个独立博客： 一般在1分钟内即可完成，如果下载速度缓慢建议更换网络环境。 编写一篇文章基础知识选择使用独立博客，需要掌握基本的 markdown 语法。例如常用的各级标题： # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 超链接的写法： [链接文字](链接地址)例如：[markdown](https://www.runoob.com/markdown/md-tutorial.html) 图片的写法： ![](图片地址)例如：![](https://git.xaox.cc/cdn/xaoxuu/raw/branch/main/blog/2021-0228a@2x.jpg) Stellar 标签语法如果使用 Stellar 主题，还可以使用丰富的标签语法，用来扩展 markdown 所不支持的表达方式，包括但不限于以下这些示例：表情引用备注时间线轮播图支持任意表情包，可自行配置：&#123;% emoji 爱你 %&#125;&#123;% emoji blobcat ablobcatrainbow %&#125;&#123;% emoji blobcat ablobcatattentionreverse %&#125;&#123;% emoji tieba 滑稽 %&#125;醒目的引用&#123;% quot 醒目的引用 %&#125;备注可以支持多种颜色&#123;% note color:yellow 备注 可以支持多种颜色 %&#125;&#123;% timeline user:xaoxuu api:https://api.github.xaox.cc/repos/xaoxuu/blog-timeline/issues?per_page=2 %&#125;&#123;% endtimeline %&#125; 第一步：创建文件在 myblog/source/_posts 文件夹中创建一个以 md 格式的文件，下面我们将会在这个文件中写文章。 第二步：设置 front-matter在文章的开头写上如下格式的内容： myblog/source/_posts/article.md---title: 文章标题date: 2022-12-23 # 文章发布日期---这里写的是文章内容 现在刷新一下 http://localhost:4000 这个网页，就会看到刚刚写的文章了。 首次发布到互联网在前面的教程中，我们仅仅是在本地预览效果，还未发布到互联网，发布到互联网之后才可以实现随时随地访问。要做这一步之前，我们首先需要一个 GitHub 账号，如果没有请先注册一个。 创建一个仓库点击 new 创建一个仓库，存放我们的输出的网页静态文件： 把博客推送到这个仓库中先找到 myblog/_config.yml 文件，在其中设置： deploy: - type: git repo: https://github.com/xaoxuu/xaoxuu.github.io.git # 注意要把地址改为自己的仓库地址 branch: gh-pages message: &quot;Build at &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss Z&#x27;) &#125;&#125;&quot; 在终端中执行： npm i hexo-deployer-git 这个指令用来安装一个插件，此插件可以将博客部署到 git 仓库中。安装成功后，接下来执行： hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 这样就会把博客推送到我们在 GitHub 上创建的仓库里。 开启 GitHub Pages在仓库的 Settings 设置中找到 Pages 选项卡，设置 Source 和 Branch 为如下图所示： 不出意外的话，接下来访问：https://username.github.io 就可以看到自己的博客啦～ 遗憾的是，github.io 域名在大陆地区被电信运营商 DNS 污染，无法直接访问。 博客日常更新流程创建&#x2F;修改文章 -&gt; 提交代码 在完成首次发布之后，后续新增或者修改文章之后就只需要执行这组命令即可同步发布： hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 🎉&nbsp;恭喜到此为止全部流程都已经完成了。下面的教程将会对流程和体验进行优化，建议有能力的同学继续往下看。 源码管理建议使用 GitHub 仓库在前面的步骤中，我们还没有把源码放进仓库中保存，这样会很容易丢失。所以接下来我们再创建一个仓库，例如可以命名为 myblog-source 用来表示这个仓库存放的是源码，这个仓库建议选择为「Private」即私有仓库。 首先把这个仓库克隆到本地： git clone https://github.com/username/myblog-source 然后在此仓库中配置一下忽略文件： .DS_Storenode_modulesdb.json.deploy_gitpublic 这些文件可以根据我们的源码生成，所以建议忽略它们，不让版本库追踪这些文件的变化。然后把我们的博客工程目录整个复制进来，或者在这里面重新创建一个，最终 myblog-source 仓库目录结构会是这样的： myblog-source: - scaffolds: # 模版 - draft.md - page.md - post.md - source: _posts: # 这里面存放文章 - xxx.md - themes: ... - _config.yml # 配置文件 - package.json ... 然后把这些文件提交并推送到 GitHub 上就可以啦： git add --allgit commit -m &quot;update&quot;git push origin main 体验优化建议使用 Vercel 部署前面我们使用 GitHub Pages 服务进行部署，但是访问速度比较慢，建议使用 Vercel 来获得更快的访问速度。 打开 vercel.com 选择使用 GitHub 账号登录，然后 Add New... -&gt; Project 选择我们在 GitHub 那边的静态文件仓库（username.github.io），稍等片刻就完成部署，完成后会告诉你访问地址，例如：username.vercel.app。 遗憾的是，vercel.app 域名在大陆地区被电信运营商 DNS 污染，无法直接访问。 使用自己的域名一个域名一年也就几十块钱，建议自己从阿里云或者腾讯云购买一个域名，也顺带直接解决了免费域名被 DNS 污染无法访问的问题。 设置 DNS 解析然后在云服务商的域名DNS解析中增加 CNAME 解析： 主机记录 记录类型 记录值 TTL 解析请求来源(isp) @ CNAME cname.vercel-dns.com 10分钟 默认 绑定域名接下来在 vercel 中我们刚刚创建的项目的设置中绑定域名： 如果是首次设置的话，可能要等很久（一般24小时以内生效），非首次设置大概几分钟就生效了。 生效后再访问 yoursite.com 就可以看到真正属于自己的博客啦。 修改配置文件修改 url 配置为自己最终要绑定的域名，否则博客内的部分链接会指向错误的地址，修改之后需等待重新部署后生效： blog/_config.ymlurl: https://yoursite.com 学习路线指引友情提示前面都是萌新教程，到这里开始步入正题了！ 基础知识 markdown：新时代青年必备技能。 yaml：多用于配置文件，简单易懂。 git：版本管理系统，IT行业必备技能。 如果像本文一样使用 Hexo + Stellar 方案，还需要搭配相关文档： hexo stellar 看过文档之后，你可以用更加高效的方法设置博客、发布文章，包括但不限于 hexo new、设置文章分类、标签、创建知识库、友链等。 自动化部署使用 #自动化部署 可以实现只修改源码，后续流程交给 CI 来完成，减少重复工作。 Stellar 高级玩法 文档系统：别人的博客只是博客，但你可以用 Stellar 创建自己的知识库！ 动态友链：如果可以，谁愿意每次加一条友链都重新部署一次博客呢？ 时间线：无需重新部署，就可以发布简短的动态消息，类似于微博。当然，也支持展示微博动态。 朋友文章：在自己博客内直接看看朋友们最近发布了什么。（由【友链朋友圈】团队定制的极简版，极大降低上手门槛。） 专属布局：模块化设计，按需定制。 获得更快的访问速度如果不满足于 vercel 的速度（本站就是部署于 vercel 的），可以尝试以下几种方案： 购买香港服务器，速度是略快于 vercel 的，每月最低成本 24 元。 域名备案，然后使用国内免费 CDN 加速，在内地访问内地的服务速度自然比香港更快。 域名备案，然后在云服务商购买云存储服务，个人博客流量小价钱会便宜很多。 域名备案，然后使用内地服务器，新用户买服务器会很便宜，但是老用户续费很贵，我这边看阿里云最低配置是每月 60 元，远超香港服务器价格。 轻量应用服务器老用户价格表大陆地区：配置1个月1年3年2核1G；每月流量 400GB；ESSD 40GB；峰值带宽 3Mbps¥60¥612¥18362核2G；每月流量 800GB；ESSD 50GB；峰值带宽 4Mbps¥90¥918¥2754香港地区：配置1个月1年3年2核1G；每月流量 1024GB；ESSD 40GB；峰值带宽 30Mbps¥24¥288¥8642核2G；每月流量 2048GB；ESSD 60GB；峰值带宽 30Mbps¥34¥408¥1224数据是我在2022年12月17日登录阿里云查看所得，其他用户在其他时间可能不是这个价，仅供参考。 DIY (Do It Yourself)如果现有框架和主题无法满足自己的需求，可以自己学习相关知识，修改源码以满足需求。一般需要掌握的知识有： HTML CSS JS NodeJS 一般主题会使用一些模板语言或css预处理器以提高效率，例如： EJS Stylus 掌握了这些，你也可以自己写一个基于 hexo 博客框架的主题给别人使用了。 Downloads每个人的独立博客.key.zip","tags":["hexo","blog","stellar"],"categories":["经验分享"]},{"title":"博客进阶：自动化部署","path":"/blog/20221126/","content":"使用脚本自动化搭建注：此脚本只适用于 Mac/Linux 平台此脚本只适用于 Mac&#x2F;Linux 平台，其中 Mac 平台 全部指令 均支持，而 Linux 平台有部分指令存在兼容性 BUG 有待解决：blog initblog test xxxblog i 主题 一键搭建环境如果电脑重装了系统，还没有安装 node.js 和 hexo 环境，可以在终端输入下面这行代码，一键完成前期准备工作： 此命令会完成以下内容： 下载并安装 blog 脚本 由 blog 脚本检测 node.js 环境，如果没有则安装 由 blog 脚本检测 hexo 环境，如果没有则安装 一键搭建环境并克隆自己的博客如果博客源码是私有仓库，且还没有配置过 ssh 或 git 账号密码，此时需要先配置一下。然后将后面的地址换成自己的博客源码地址： 已安装blog脚本未安装blog脚本blog resume https://github.com/user/repo 此命令会完成以下内容： 克隆博客及其子模块源码 执行 npm i 安装依赖 执行 hexo s 运行博客 打开 http://localhost:4000 预览博客 curl -s https://sh.xaox.cc/install | sh -s blog &amp;&amp; blog resume https://github.com/user/repo 此命令会完成以下内容： 下载并安装 blog 脚本 由 blog 脚本检测 node.js 环境，如果没有则安装 由 blog 脚本检测 hexo 环境，如果没有则安装 克隆博客及其子模块源码 执行 npm i 安装依赖 执行 hexo s 运行博客 打开 http://localhost:4000 预览博客 测试主题效果如果遇到了问题，可以对比主题 demo 查看效果是否正常： 已安装blog脚本未安装blog脚本 安装其它主题 换成任意主题名，需要是发布到 npmjs.org 的主题，匹配到 hexo-theme-主题名 的部分。 附：常用命令 命令 功能 blog init 检查并安装环境，然后创建并运行博客 blog test 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog test stellar 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog test vlts 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog test 主题名 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog i node 安装 node.js blog i hexo 安装 hexo blog i stellar 安装 stellar 主题，同理换成其它主题名字都可以 blog i 主题名 安装任意主题 blog c 同 hexo clean 然后打开 localhost:4000 blog cs 同 hexo clean &amp;&amp; hexo g 然后打开 localhost:4000 blog cgd 同 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add --all &amp;&amp; git commit &amp;&amp; git push origin blog help 打开文档页面 设置 npm run 运行脚本打开博客的 package.json 文件，在 scripts 部分增加这些快捷指令： &#123; ... &quot;scripts&quot;: &#123; &quot;c&quot;: &quot;hexo clean&quot;, &quot;s&quot;: &quot;hexo clean &amp;&amp; hexo server&quot;, &quot;g&quot;: &quot;hexo clean &amp;&amp; hexo generate&quot;, &quot;d&quot;: &quot;hexo deploy&quot; &#125;, ...&#125; 这样输入 npm run s 就相当于输入 hexo clean &amp;&amp; hexo server 了，除此之外你也可以根据自己的需要增加其他脚本。 GitHub Actions 自动化部署通过 GitHub Actions 可以只提交源码到仓库，后续流程全部由 CI 自动完成，本质上是完成以下几个步骤： checkout 源码 配置环境 生成静态文件 部署到对应平台（GitHub Pages &#x2F; Vercel &#x2F; Server…） 配置文件.github/workflows/auto-deploy.ymlname: auto deployon: workflow_dispatch: push:jobs: build: runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu name: auto deploy steps: # 1. 获取源码 - name: Checkout uses: actions/checkout@v3 # 使用 actions/checkout@v3 with: # 条件 submodules: true # Checkout private submodules(themes or something else). 当有子模块时切换分支？ # 2. 配置环境 - name: Setup Node.js 18.12.x uses: actions/setup-node@master with: node-version: &quot;18.12.x&quot; # 3. 生成静态文件 - name: Generate Public Files run: | npm i npm install hexo-cli -g hexo clean &amp;&amp; hexo generate # 4a. 部署到 GitHub 仓库（可选） - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125; external_repository: xaoxuu/xaoxuu.github.io publish_branch: gh-pages publish_dir: ./public commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; user_name: &#x27;github-actions[bot]&#x27; user_email: &#x27;github-actions[bot]@users.noreply.github.com&#x27; # 4b. 部署到服务器（可选） - name: Deploy to Server uses: easingthemes/ssh-deploy@v3 env: SSH_PRIVATE_KEY: $&#123;&#123; secrets.SERVER_SSH_KEY &#125;&#125; ARGS: &quot;-rltgoDzvO --delete&quot; EXCLUDE: &quot;.well-known, .user.ini&quot; SOURCE: public/ REMOTE_HOST: $&#123;&#123; secrets.REMOTE_HOST &#125;&#125; REMOTE_PORT: $&#123;&#123; secrets.REMOTE_PORT &#125;&#125; REMOTE_USER: $&#123;&#123; secrets.REMOTE_USER &#125;&#125; TARGET: $&#123;&#123; secrets.TARGET &#125;&#125; # 4c. 部署到阿里云OSS（可选） - name: Setup Aliyun OSS uses: manyuanrong/setup-ossutil@master with: endpoint: oss-cn-hongkong.aliyuncs.com access-key-id: $&#123;&#123; secrets.OSS_ACCESSKEY_ID &#125;&#125; access-key-secret: $&#123;&#123; secrets.OSS_ACCESSKEY_SECRET &#125;&#125; - name: Deploy to Aliyun OSS run: ossutil cp -rf ./public oss://xaoxuu-com/ 关键参数部署到 GitHub Pages源码仓库「Secrets」DEPLOY_KEY: 第一步本机生成的 id_isa 文件内容 输出目标仓库「Deploy Keys」第一步本机生成的 id_rsa.pub 文件内容 部署到 Server源码仓库「Secrets」SERVER_SSH_KEY: 第一步本机生成的 id_isa 文件内容REMOTE_HOST: 服务器地址REMOTE_PORT: 服务器SSH端口REMOTE_USER: 用户名，例如 &quot;git&quot;TARGET: 生成的文件路径，例如 &quot;/www/wwwroot/xaoxuu.github.io/&quot; 部署到阿里云 OSS创建 RAM 用户，然后生成一对 id 和 secret 填写到源码仓库的 Secrets 设置中： 源码仓库「Secrets」OSS_ACCESSKEY_ID: OSS_ACCESSKEY_SECRET: GitHub Codespaces如果你经常需要在一些临时电脑上写写稿子、预览效果，不能立即发布且需要多端同步，或许这是个不错的选择，详见这篇文章： https://xaoxuu.com/blog/20221121/https://xaoxuu.com/blog/20221121/","tags":["shell","hexo"],"categories":["经验分享"]},{"title":"GitHub Codespaces 快速尝鲜","path":"/blog/20221121/","content":"GitHub 最近上线了 Codespaces 功能，页面入口如下： 免费账号可以使用 120 core-hours compute • 15GB storage 额度： 感觉挺不错的，赶快来体验吧～ 使用方法 现在，每个项目仓库 Code 的下拉菜单中多了一个 Codespaces 入口，点击就可以创建一个此项目仓库的 Codespaces 如图所示： 由于我的博客源码是通过 submodule 方式引用主题的，而且还设置了 GitHub Actions 自动化部署，所以几分钟等待过后 Codespaces 就已经把博客全套环境创建完成了，在这整个过程中不需要自己进行任何配置： 修改完代码直接提交到当前仓库，就和在本地提交 git 代码一样。 浅尝小结 初始化和博客环境搭建过程体验非常好，全程不需要操作。但是速度和本地相比是明显感觉到慢点的，由于我自己写了一个云脚本也可以在新装系统上一键完成全套流程，所以它可能不太适合我用来管理博客。 https://xaoxuu.com/blog/20221126/https://xaoxuu.com/blog/20221126/ 但如果你经常需要在一些临时电脑上写写稿子、预览效果，不能立即发布且需要多端同步，或许这是个不错的选择。 不知道大家会用它来做什么呢？","tags":["GitHub","Codespaces"],"categories":["探索号"]},{"title":"探索 Stellar 时间线标签的 N 种用法","path":"/blog/20221029/","content":"时间线标签是 Stellar 最强大的特性之一，它可以以侧边栏组件身份出现在左侧边栏，可以以标签插件形式出现在文章任意位置，以下是笔者能想到的几种常见用法。 教程与步骤 效果第一步：打开 GitHub打开 Stellar 的 GitHub 页面。第二步：点击 Star如果发现右上角的 Star 还没点亮，就点亮它！源码&#123;% timeline %&#125;&lt;!-- node 第一步：打开 GitHub --&gt;打开 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 的 GitHub 页面。&lt;!-- node 第二步：点击 Star --&gt;如果发现右上角的 Star 还没点亮，就点亮它！&#123;% endtimeline %&#125; 近期动态（说说） 设置 user:xxx 则会只显示某人发的 issue 数据，可以用来展示个人动态。 效果源码&#123;% timeline user:xaoxuu api:https://api.github.xaox.cc/repos/xaoxuu/blog-timeline/issues?per_page=2 %&#125;&#123;% endtimeline %&#125; memos 效果源码&#123;% timeline user:xaoxuu api:https://memos.xaox.cc/api/v1/memo?creatorId=1&amp;limit=2 type:memos %&#125;&#123;% endtimeline %&#125; 话题讨论 如果不限制 user:xxx 则会显示所有人发的 issue 数据，可通过 labels 筛选用于展示某一话题。 效果源码&#123;% timeline api:https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/issues?labels=1.x+版本&amp;per_page=3 %&#125;&#123;% endtimeline %&#125; 扩展阅读 可设置 hide:title,footer 隐藏标题和底部栏以进行紧凑型布局，例如 #探索号 系列文章： 效果源码&#123;% timeline hide:title,footer api:https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/issues?state=all&amp;labels=分享&amp;per_page=3 %&#125;&#123;% endtimeline %&#125; 更新日志 不只是 issues 数据，时间线也兼容 releases 数据，可直接用于展示项目更新日志： 效果源码&#123;% timeline api:https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/releases?per_page=3 %&#125;&#123;% endtimeline %&#125; 友链文章订阅 嗯，除了 issues 和 releases 数据，时间线还兼容「友链朋友圈」数据，可以展示小伙伴们最近发布的文章： 效果源码&#123;% timeline type:fcircle limit:3 api:https://raw.github.xaox.cc/xaoxuu/friends-rss-generator/output/data.json %&#125;&#123;% endtimeline %&#125;因为篇幅有限，这里设置了最多只显示 3 条数据，实际可根据需要进行设置。 热评文章 如果使用基于 issues 的评论系统，可以通过按评论数排序展示热评文章： &#123;% timeline hide:title,user user:utterances-bot,beaudar-bot api:https://api.github.xaox.cc/repos/xaoxuu/blog-comments/issues?sort=comments&amp;per_page=3 %&#125;&#123;% endtimeline %&#125; 侧边栏时间线 在 source/_data/widgets.yml 文件中创建时间线组件： timeline: layout: timeline title: 近期动态 api: https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=1 user: xaoxuutimeline_stellar_more: layout: timeline title: Stellar 探索号 api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&amp;labels=分享&amp;per_page=5 hide: title 然后在需要显示的页面的 front-matter 中的 sidebar 部分写上它的名字，例如本文的配置： sidebar: [toc, timeline_stellar_more] 大家有什么关于 Stellar 的文章想要分享吗？欢迎投稿，提完 issue 这里就可以看到了，不要乱投哦～ https://xaoxuu.com/wiki/stellar/articles/https://xaoxuu.com/wiki/stellar/articles/","tags":["Stellar","Hexo"],"categories":["经验分享"]},{"title":"用 GitHub 搭建一个简单的脚本库","path":"/blog/20210102/","content":"接口变动近期已升级至 v3 版本，文章内容已更新。 细心的朋友可能会发现，我提供的一些脚本都可以在不依赖任何包管理工具的情况下通过一行命令安装，并且它们的安装命令极为相似： curl -s https://sh.xaox.cc/install | sh -s hexocurl -s https://sh.xaox.cc/install | sh -s tagcurl -s https://sh.xaox.cc/install | sh -s vimcncurl -s https://sh.xaox.cc/install | sh -s podspec 虽然它们安装方式极为相似，但是安装逻辑却并非完全相同，例如前三者是安装到 /usr/local/bin/ 目录下，在任意位置打开终端都可以使用，而 podspec.sh 则是下载到当前目录下。 如果打开 https://sh.xaox.cc/install 文件，你会发现它并没有做任何实质性的操作，只是负责任务派发，根据不同的参数把「安装」指令指派给不同的项目，不同的项目对「安装」的具体实现可以相同也可以不同。 对于相同的部分，以 vimcn 为例，它的 index.sh 实现如下： #!/bin/sh# 这个脚本负责下载和安装的逻辑# function liblib=&#x27;https://sh.xaox.cc/lib/v3&#x27;# repository nameREPO=&#x27;vimcn&#x27;# clint file nameTARGET=&#x27;cli.sh&#x27;# clint file nameRENAME=&#x27;upload&#x27;# download versionVERSION=$1if [ &quot;$VERSION&quot; = &quot;&quot; ];then VERSION=&#x27;main&#x27;fion_success() &#123; doc_url=xxx printf &quot; &gt; \\033[32m恭喜您，安装成功！\\033[0m 请收藏这个页面，在您遇到问题的时候可以查看文档： $&#123;doc_url&#125; &quot;&#125;curl -s $&#123;lib&#125;/download.sh | sh -s $&#123;REPO&#125; $&#123;VERSION&#125; $&#123;TARGET&#125; &amp;&amp;curl -s $&#123;lib&#125;/install.sh | sh -s $HOME/Downloads/$&#123;TARGET&#125; $&#123;RENAME&#125; &amp;&amp; on_success 从中可以看到它导入了一个「库」，确切的说是一个存放可复用代码的仓库地址，具体的「下载」与「安装」脚本像独立组件一样可供外部调用。与此例不同的 podspec.sh 脚本就只有下载操作： curl -s $&#123;lib&#125;/download.sh | sh -s $&#123;REPO&#125; $&#123;VERSION&#125; $&#123;TARGET&#125; ./ &amp;&amp;chmod 777 $&#123;TARGET&#125; &amp;&amp; on_success 易于扩展这么一套流程使得脚本安装变得非常有扩展性，如果需要发布一个新的脚本，只需要新建仓库，在其中写一个 index.sh 脚本，通过调用 lib 仓库里封装好的脚本，传入仓库名、版本、要下载的文件，就可以轻松实现下载安装流程。 易于使用更重要的是，可以通过一行命令来安装： curl -s https://sh.xaox.cc/install | sh -s 我的脚本 这套体系类似于包管理工具一样，但目前只对创建在 @cloud-shell-lib 中的仓库有效。 总结就是一个比包管理工具更轻量级更小的「个人脚本管理」体系，不需要本地依赖，适合经常换系统、换设备执行一些轻量级任务的场景。 Todo暂时没有 todo 了，不打算折腾了，感兴趣的朋友可以自己研究一下，不懂的话可以留言询问。搭建方法就是： fork lib 或者自己创建一个更好的公共库。 在网站某个路径下放一个 install 文件，根据传入参数把指令转发给目标脚本仓库。 在目标脚本仓库中创建一个命名固定的脚本用于接收传入的指令，然后可以根据需要执行操作或者调用公共库的下载、安装等通用流程。","tags":["shell"],"categories":["设计开发"]},{"title":"苹果设计开发加速器线上活动","path":"/blog/20201119/","content":"受疫情影响，今年设计开发加速器活动改为线上形式，本次参与的活动课题是《为 iPhone 和 iPad 搭建灵活适配的用户界面》。新出的几款 iPhone 和 iPad 设备尺寸和旧设备都不同，造成适配成本增加，本次活动目的是向开发者分享高效而灵活的适配方案。 避免屏幕分辨率硬编码常见陷阱：对硬件设备型号做特殊判断 适配方面 启动屏 安全区和布局边框 尺寸类 动态字体 启动屏用 Storyboard 启动屏，不建议用图片作为启动页，详见官方设计指南： Human Interface Guidelineshttps://developer.apple.com/design/human-interface-guidelines/patterns/launching/ 安全区和布局边框安全区 UIScreen &amp; UIWindow 获得布局尺寸进行排版不适用于 iPhone X 以及以后机型 要使用安全区来进行布局（安全区是动态的，不同设备、横竖屏、子视图都不相同） .safeAreaInsets.safeAreaLayoutGuide 还可以根据需要定制安全区（例如定制工具栏） .additionalSafeAreaInsets 安全区发生变化时： .viewSafeAreaInsetsDidChange() 布局边框 .layoutMargins.directionalLayoutMargins.layoutMarginsGuide.layoutMarginsDidChange() 与安全区配合使用 子视图传递 布局边框会根据设备宽度、动态字体而自动调整，能够自动适配。 尺寸类sizeClasses C 紧凑型（iPhone竖屏，iPad分屏） R 常规型（iPad竖屏，12.9‘iPad等宽分屏） 动态字体.large.title1...label.font = UIFont.preferred... 自定义字体 metrics = UIFontMetrics(...) more at WWDC2017 后记2021年1月4日今天收到 Apple 的邮件，设计开发加速器活动现在已经开放申请啦，感兴趣的朋友们可以去 官网 申请。2021年2月1日今天无意中发现又关闭申请入口了。2021年4月9日今天经同事提醒发现又开放申请了。","tags":["iOS","设计开发加速器"],"categories":["技术加油站"]},{"title":"心率管家的设计与开发（下篇：信号处理）","path":"/blog/20200927/","content":"作为一名开发者，如何使用手机摄像头测量心率呢？在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。 光电容积脉搏波描记法目前市面上大部分便携心率检测设备都是基于光电容积脉搏波描记法来测量的。由于心跳引起动脉周期性变化，动脉内血液的容积发生周期性变化，因而对光线的吸收也会呈现同样的周期性变化，这个周期性变化的频率就是脉率，脉率大部分情况都和心率一致。 打开相机，把手指指尖覆盖在摄像头上，观察屏幕上的取景框，就可以发现每心跳一次，屏幕中的红色都会变暗一次。对每一帧画面提取 RGB 均值，并转换到 HSV 色彩空间，把色相 H 作为特征值，得到时域信号。 信号处理我使用简单的时域分析法计算脉率，关键点就是计算采样时间内的波峰个数。把色相信号绘制波形图如下： 由于覆盖力度不稳定导致色相会整体偏移因而产生低频噪声，再加原本就存在的高频噪声影响，波形显得很杂乱无章，所以使用带通递归滤波器进行滤波： 公式展开为： 用 Swift 语言实现这个滤波器的算法（10阶）为： private struct BandpassFilter &#123; private var x = [CGFloat].init(repeating: 0, count: 11) private var y = [CGFloat].init(repeating: 0, count: 11) @discardableResult mutating func filted(_ value: CGFloat) -&gt; CGFloat &#123; guard x.count &gt; 10, y.count &gt; 10 else &#123; return 0 &#125; for i in 0 ..&lt; 10 &#123; x[i] = x[i+1] y[i] = y[i+1] &#125; x[10] = value / 1.894427025e+01 y[10] = x[10] - x[0] + 5 * (x[2] - x[8]) + 10 * (x[6] - x[4]) y[10] += (-0.0000000000 * y[0]) + (0.0357796363 * y[1]) y[10] += (-0.1476158522 * y[2]) + (0.3992561394 * y[3]) y[10] += (-1.1743136181 * y[4]) + (2.4692165842 * y[5]) y[10] += (-3.3820859632 * y[6]) + (3.9628972812 * y[7]) y[10] += (-4.3832594900 * y[8]) + (3.2101976096 * y[9]) return y[10] &#125;&#125; 这个算法是从 WuXiaoTu&#x2F;HeartRate 这个开源库中翻译来的。 经过滤波之后就能看到波形图呈现锯齿状，由于这是由摄像头捕捉到的色相的波形图，所以看起来并不会像心电图那样： 有了干净的波形图，就可以数出一段时间内的波峰个数，从而计算出频率。例如数5秒内有多少个波峰，然后乘以12就是每分钟脉搏跳动次数，也就是这5秒内的平均脉率。现在 GitHub 上的很多同类的开源项目也都是这种方案。由于连续测量的时间越长，发生中断的可能性就越大，测量成功率就越低，再考虑到心率本身就是变化的，时间跨度太长也会使得数据变得没有意义，测量时间太短又很容易被个别误差数据影响。 网络上现有方案都是先确定测量时长，时间结束后计算结果： 如果测量时间短：成功率高，准确性低。 如果测量时间中等：成功率低，准确性高。 如果测量时间长：成功率很低，准确性很高，但是数据意义不大。 我想出了一种新的方案，就是每探测到一个有效脉冲，就记录下这个脉冲与上一个有效脉冲之间的间隔，两个连续的有效脉冲计算出来的频率就是100%正确的瞬时脉率。所以改进后的方案是：开始测量后，始终记录脉冲，随时可以计算瞬时脉率、最后若干秒的平均脉率。 成功率：100%（不存在测量中断而失败的情况） 准确性的情况如下： 如果脉冲计数都是由脉搏跳动引起的，测量结果就是完全准确的 如果脉搏跳动了而脉冲计数没有增加，不会影响结果，因为计算时只会把有效脉冲的周期进行累加 如果在脉搏跳动间隙额外增加了脉冲计数，那么数据就会失真 如果不故意快速抖动手指，数据失真的情况就不会发生，因为手指不离开摄像头并在两次脉搏跳动中间产生一次色相饱和度明度都以假乱真的脉冲信号是很难的。 脉冲探测器经过滤波后的数值是围绕0上下波动的，分别记录大于0的值和小于0的值，各自保存到数组中，然后求出它们的平均值： if filted &gt; 0 &#123; upVals.append(filted) if upVals.count &gt; 20 &#123; upVals.removeFirst(upVals.count - 20) &#125;&#125; else if filted &lt; 0 &#123; downVals.append(filted) if downVals.count &gt; 20 &#123; downVals.removeFirst(downVals.count - 20) &#125;&#125;let avgUp = upVals.reduce(0, +) / CGFloat(upVals.count)let avgDown = downVals.reduce(0, +) / CGFloat(downVals.count) 如果新的值高于 avgUp 的一半，就标记 flag = true ，低于 avgDown 的一半且 flag = true 就标记 flag = true，触发一次脉冲，记录下这个脉冲的时间戳。如果两个脉冲之间的时间间隔符合正常心率的范围，就认为是有效脉冲。 if filted &gt; 0.5 * avgUp &#123; flag = true&#125;if filted &lt; 0.5 * avgDown &amp;&amp; flag == true &#123; flag = false let time = CACurrentMediaTime() let period = time - periodStart // 与上一个周期间隔时间满足正常周期范围 if period &lt; MAX_PERIOD &amp;&amp; period &gt; MIN_PERIOD &#123; // 记录这次脉冲与上次脉冲的时间间隔 periods.append(period) // 捕获到脉冲 delegate?.pulseDetector(detector: self, capture: periods) &#125; periodStart = time&#125;return filted 上文「正常心率的范围」如何界定？心率如果低到 40bpm 此时周期达到最大值，如果心率高达 255bpm 则周期达到最小值。 MAX_PERIOD = CFTimeInterval(60.0 / 40)MIN_PERIOD = CFTimeInterval(60.0 / 255) 计算脉率上一步记录下了每个脉冲的周期，取出最后 N 个要计算的脉冲，把它们的周期相加就是总时长，用 个数 / 时长 计算的值就是频率，频率乘以 60 就是每分钟的脉冲数，也就是脉率。 func calcFrequency(count: Int) -&gt; CGFloat? &#123; guard (0 ... periods.count).contains(count) else &#123; return nil &#125; let duration = periods.dropFirst(periods.count - count).reduce(0, +) return CGFloat(count) / CGFloat(duration)&#125; 准确性与参考价值由于心率是动态变化的，即使测量的脉搏跳动都是准确的，也就是说测量阶段实现了零误差，但是计算方式不一样也会产生不同的结果。因此直接拿结果去和小米手环或者 Apple Watch 上显示的数值去进行对比是不严谨的。正确地方法是在一个时间段内用多种方式测量的同时亲自用手测量脉搏跳动次数，可以借助本文的 demo 计算瞬时或者平均脉率，如果一段时间的脉冲计数完全正确，那么 demo 计算的结果就是完全准确的，瞬时脉率、最后 N 秒的平均脉率一般都不会相同。因此即使戴在一只手上同一时间进行测量，不同产品显示的心率不同也并不能说明它们谁更准，只能说谁的结果更具有参考价值。 对此，我优化后的心率管家测量方案可以选择测量时长，也可以随时结束测量，运动后心率变化快的时候适合取短时间内例如5s平均脉率，心平气和的时候可以取适当长一点的例如10s或者20s的平均脉率。 脉率和心率脉率是每分钟脉搏的次数，心率是每分钟心跳次数，健康情况下脉率与心率一致，但是如果出现心律失常，心脏有一些跳动不能有效将血液泵至全身，因此会出现脉搏缺失，导致脉率显著低于心率。如果用来判断心脏功能状态，误差很大。对于心动过速、低血压症和休克病人，即使是心率规则，由于脉压差很小，脉搏也会很弱，此时往往不能够准确测量脉率。 另外，脉搏随肢体移动会形成伪迹波动，也会影响脉率的测量。而心率不受心律失常、心动过速、休克、肢体活动的影响，所以在临床上，医生判断心跳活动不是看脉率，而是看心率，摸脉搏只是一个辅助操作。 因此，通过手环、手表、app 测量的“心率”并不是一个完全可靠的数据。 后记非常感谢 @JustinYang 大佬在滤波算法方面给予的援助。也十分感谢 @Punmy、@WuXiaoTu 等作者的文章，使得后人能够少走很多弯路。 https://xaoxuu.com/blog/20190723/https://xaoxuu.com/blog/20190723/","tags":["iOS","Swift","心率"],"categories":["设计开发"]},{"title":"静态博客使用 Issues API 来实现动态发布友链、书签","path":"/blog/20200823/","content":"由于发布 issue 的成本远远低于发布一次博客更新（即便是使用了持续集成），可以用 issue 来简化每个独立博客都必备的友链系统，也可以通过 issue 来快速发布动态资讯，弥补静态博客必须更新静态文件才能更新内容的缺点。此功能已经集成到了主题中，使用非常方便。 实现思路如标题所说，例如 Issues API 来实现，把请求到的结果进行解析，然后生成 HTML 标签，添加到页面中。为了获取到需要的信息，创建 Issue 需要遵循一定的格式，例如「网站卡片」就需要截图、网站标题、网站链接、网站描述、头像。可以设置 Issues 模版 来简化步骤。 通过 issue 方式发布内容可以支持 script 脚本，为了安全起见，最好设置一个限制，例如用标签来激活 labels=active 或者只对自己发布的有效，可以在解析数据的时候过滤掉 script 标签。 如何在主题中使用？在 GitHub 或者 Gitee 创建仓库，仿照下面的示例，把 api 中的用户名和仓库名改成自己的。Issue 内容中需要有一段满足 JSON 格式的代码块： &#123; &quot;title&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;screenshot&quot;: &quot;&quot;, &quot;url&quot;: &quot;&quot;, &quot;avatar&quot;: &quot;&quot;, &quot;version&quot;: &quot;版本：^4.0&quot;&#125; 仓库链接： https://github.com/xaoxuu/friends/issueshttps://github.com/xaoxuu/friends/issues 在线演示效果见本站友链 https://xaoxuu.com/friends/https://xaoxuu.com/friends/","tags":["博客","GitHub"],"categories":["设计开发"]},{"title":"个人电脑作为办公设备时，我们如何保护隐私？","path":"/blog/20200627/","content":"公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区加密。 分区加密对 Mac 电脑进行磁盘分区和安装多系统非常简单，打开「磁盘工具」点击标题栏的「分区」按钮进行分区即可，分区的格式一定要选择加密的，这里推荐「APFS（加密）」格式。密码要记下来防止遗忘。这里选择加密分区主要可以防止意外挂载：在启动了工作区的系统之后，由于需要密码才能挂载生活区的数据宗卷，可以有效避免不小心点了挂载或者设置了自动挂载，导致拥有完整的磁盘访问权限的安防软件自动扫描了生活区的文件资料。同样的道理，工作分区加密也可以防止生活区的某些软件扫描到了工作资料导致数据泄露。 分区完成之后，安装系统，目标宗卷选择刚刚新建的工作分区，剩下的系统安装步骤不需要赘述了。 工作专用账号系统安装完成之后，最好登录工作专用的账号，不要使用同一个 AppleID 进行登录，否则仍然存在数据泄露的风险。同样的，浏览器账号也需要使用工作专用。AppleID 和浏览器账号基本上可以满足大部分需要记住账号密码的需求。 而对于工作日志，我推荐给程序员的做法是创建本地 git 仓库，用 Typora 编辑器 markdown 格式书写。它的缺点十分有限，就是新增文件稍微麻烦一点，要在左侧目录树上点击右键，然后选择「新建文件」，然后输入文件名，除此之外几乎没有缺点。对于支持 md 的其它笔记软件来说，它对于 md 的支持比较完整，方便更换和修改主题，导出格式丰富并且样式也比较完整。 Typora 操作界面 用户目录权限Mac 自带的一些用户文件目录例如「文稿」「桌面」等默认权限是 700 也就是仅当前用户可以读写和执行，但是自己新建的文件夹默认权限是 755 即全局用户都可以读取和执行。所以如果自己在原生的文件目录之外新建了文件夹，记得更改文件夹的权限： 把权限由 755 修改为 700 我切换了另一个用户进入这个用户目录时就提示无权限访问了，理论上这个用户上的应用程序也没有权限访问吧。（不太肯定） 一个小坑经测试发现，在两个独立的宗卷中如果存在用户名和密码相同的两个用户，那么即使设置了 700 权限，但实际上在另一个宗卷中登录同名同密码的用户，对这个用户的文件夹一样拥有权限，不知道这是苹果有意为之还是设计漏洞。 一个不便之处流程是进入系统后自动请求挂载另一个宗卷，由于开启了文件保险箱，所以弹出了密码输入框，不输入密码点击取消，则没有权限访问另一卷的磁盘内容。但是每次开机都会有这个弹窗，挺烦人的。 网上搜索了设置开机不自动挂载的方法，都是修改 fstab 文件的方法： /etc/fstabUUID=427478BB-E267-4455-869A-4AAB54F792A1 none auto noauto 0 0 实测无效，每次登录用户还是会自动尝试挂载，可能这种方式在 APFS 分区中不再支持了。不知道在 2020 年，如何让 APFS 加密分区不自动挂载？","tags":["Mac"],"categories":["解决方案"]},{"title":"苹果设计开发加速器《创建卓越的 Apple Watch 体验》活动现场体验","path":"/blog/20191006/","content":"9月26号收到了苹果的一活动邀请邮件《创建卓越的 Apple Watch 体验》，活动地点是：Design and Development Accelerator，这是苹果今年7月份在上海设立的设计开发加速器，为开发者提供有关应用设计与开发的专业培训和资源。 什么是「设计开发加速器」？苹果官网：设计开发加速器视频体验：搞机零距离：中国开发者的大好事？苹果工程师一对一授课，让人开了又开？媒体资讯：苹果设计开发加速器正式启动，每年计划为 5000 名国内开发者提供支持 watchOS 6构建面向 watchOS 的 app，让用户随时随地及时掌握信息并轻松完成快速操作。开放了更多种全新的 API，可以构建完全独立的 watchOS app，甚至是不带有 iOS 版的 watchOS app。现在，用户可以直接在 Apple Watch 上的 App Store 中查找并安装 app。 独立的 App在 watchOS 6 中，可以构建完全独立的 Watch App。“Sign in with Apple” 让用户远离手机时也能在 Apple Watch 上登录 app。 选择应用模板 Watch-only app创建只有 Apple Watch 且没有相关 iOS 应用程序。 watchOS app with an iOS app当您拥有 iOS 应用并想要提供可提供相似或相关体验的 watchOS 应用。 在创建 watchOS Target 时，指定要构建的 watchOS 项目的类型。此外，如果将 watchOS 应用程序与 iOS 应用程序捆绑在一起，则必须指定 watchOS 应用程序如何与其配套的 iOS 应用互动。 Independent Apps （独立应用）不需要 iOS 配套应用即可正常运行。用户可以选择安装 iOS 应用、watchOS 应用或同时安装两者。 Dependent Apps （从属应用）依靠 iOS 配套应用才能正常运行；仅在 watchOS 应用需要与 iOS 应用互动时才创建从属应用。用户必须使用其 iOS 应用购买并安装从属的 watchOS 应用。 在 watchOS 5 和更低版本中，所有 watchOS 应用程序都是从属应用。 Apple Watch 上的 App StorewatchOS 6 上提供适用于 Apple Watch 的 App Store，让用户可以直接在 Apple Watch 上轻松探索、浏览、搜索和安装 watchOS app。使用 Siri、听写或涂写进行搜索，或者通过轻点产品页面链接，直接进入产品页面。 系统会为独立和从属应用直接将 watchOS 应用程序下载并安装到 Apple Watch。 Apple Watch 人机界面指南Apple Watch 设计为可穿戴，因此用户界面适合穿戴者使用，并为他们带来轻巧，反应灵敏且高度个性化的体验。人们经常使用 watchOS 应用程序的相关体验（例如复杂功能、通知和 Siri 交互），而不是使用应用程序本身。创造出色的 watchOS 体验意味着既要设计应用程序，又要设计快速，信息丰富的元素，使人们能够以适合自己的方式访问您的内容。最有用的应用通常： 使用复杂功能可以在表盘上提供少量可能动态的信息，使人们可以一目了然地查看信息 使用通知传递及时的高价值信息并采取重要行动 帮助人们使用 Siri 获取信息并执行任务 如有必要，请在应用程序体验中提供更多详细信息和功能 图片来源声明本文挖了坑但是许久没有填上，直到 watchOS 7 都要发布了，最后决定放弃填坑，文章封面和文中的部分插图来源于苹果官方文档。 附：议程安排苹果上海设计开发加速器地点在源深体育中心地铁站4出口处，三座非常低调没有任何招牌的建筑，绕着走了一圈才找到A座二楼入口的门。内部环境如媒体图片一样，室内禁止私自拍照，只有这张门票留作纪念喽。","tags":["iOS","设计开发加速器"],"categories":["技术加油站"]},{"title":"使用链式语法打造一个 ObjC 安全的对象类型转换库","path":"/blog/20190829/","content":"我就职过的公司，都出现过不止一次因为后台实际数据类型和文档不一致导致的程序线上崩溃问题。原则上即使服务器离线了，app 都不应该直接闪退，所以 app 应当具有对服务器异常情况进行处理的能力。使用 ValueX 可以有效避免后台返回数据类型异常导致的程序崩溃。 https://github.com/xaoxuu/ValueX/https://github.com/xaoxuu/ValueX/ 异常场景 场景1： NSString 类型变成 NSNull 场景2： nil 变成 @&quot;&lt;null&gt;&quot; 值 场景3： userId 不确定是 NSString 还是 NSNumber 场景4： NSDictionary 中嵌套的容器变成了 Json 字符串格式 问题抽象 实际类型与定义类型不符 实际类型与期望类型不一致 设计接口假如我得到一个值 NSString *obj，实际上可能是 NSNull ，可能是 NSNumber ，可能是空数据的 @&quot;&lt;null&gt;&quot; 或者 @&quot;(null)&quot; 等各种表述。那么我需要确保 NSSafeString(obj) 的结果一定是 NSString 类型的值，如果是空数据，就应该是 nil。如果是 @123 这样的数字，那么应该得到 @&quot;123&quot; 这样的字符串。 如果是 json 数据，它可能以 NSData 类型存在，可能以 Json 字符串 NSString 类型存在，可能以 NSArray 或者 NSDictionary 对象形式存在。我需要的是我要什么类型就能直接获取。例如 ValueX(obj).stringValue 就得到这个数据的 Json 字符串，ValueX(obj).dictionaryValue 就得到这个数据的字典对象。 所以这个库就分为两部份工作，一部分是将实际类型与定义类型一致化；第二部分是将已知类型转换成它能够转换的其他类型。 类型安全针对 ObjC 中常用的 6 种数据类型 NSString、NSNumber、NSData、NSArray、NSSet、NSDictionary 一一进行判断，写出6个函数： 得到安全类型：FOUNDATION_EXTERN NSString * __nullable NSSafeString(id obj);FOUNDATION_EXTERN NSNumber * __nullable NSSafeNumber(id obj);FOUNDATION_EXTERN NSData * __nullable NSSafeData(id obj);FOUNDATION_EXTERN NSArray * __nullable NSSafeArray(id obj);FOUNDATION_EXTERN NSSet * __nullable NSSafeSet(id obj);FOUNDATION_EXTERN NSDictionary * __nullable NSSafeDictionary(id obj); 确保从这些函数出来的值是与定义类型一致的值。 类型转换即使拿到的值与定义类型一致，有时候我们要用的可能又是其他类型。 数据类型转换函数：FOUNDATION_EXTERN VXObject *ValueX(id &lt;VXConvertable&gt;obj); 确保 VXObject 类型可以通过点语法直接得到原数据所能够转换的其他类型。VXObject 是一种中间类型，针对上述 6 种数据类型，每一种可以转换成其他哪些类型进行一一判断。 其中，NSNumber 只可以转换为 NSString、NSData，遵循 VXConvertable 协议。表示数字的 NSString，可以转换成 NSNumber，表示 Json 的字符串可以转换成对应的 NSArray 或者 NSDictionary，遵守 VXConvertableData 协议。反过来 NSArray、NSSet 或者 NSDictionary 则遵守 VXConvertableObject 协议。 @interface NSString (VXObject) &lt;VXConvertableData&gt;@end@interface NSNumber (VXObject) &lt;VXConvertable&gt;@end@interface NSData (VXObject) &lt;VXConvertableData&gt;@end@interface NSArray (VXObject) &lt;VXConvertableObject&gt;@end@interface NSSet (VCObject) &lt;VXConvertableObject&gt;@end@interface NSDictionary (VXObject) &lt;VXConvertableObject&gt;@end 它们的协议内容是： @protocol VXConvertable &lt;NSObject&gt;- (VXObject *)vx;@end@protocol VXConvertableObject &lt;VXConvertable&gt;- (VXObject *)vxWithOptions:(NSJSONWritingOptions)opt;@end@protocol VXConvertableData &lt;VXConvertable&gt;- (VXObject *)vxWithOptions:(NSJSONReadingOptions)opt;@end 就按照这个思路进行开发，实现的代码就不再赘述了。 https://xaoxuu.com/wiki/valuex/https://xaoxuu.com/wiki/valuex/","tags":["iOS","链式语法","ObjC","开源库","ValueX"],"categories":["设计开发"]},{"title":"设计一个样式和逻辑分离的 HUD 库","path":"/blog/20190827/","content":"在写「ProHUD」之前我已经在「AXKit」中实现了原生控件快速构造方法、为公司写了 ObjC 版的可定制化 HUD、Swift 版的开源的 NoticeBoard（通知横幅）。ProHUD 诞生的意义就在于取代这些不那么完善的 HUD。 这是一个简单易用且完全可定制化的 HUD ProHUD &#x3D; Toast（通知横幅） + Alert（ProgressHUD、弹窗） + ActionSheet（操作表） 特性 用相似的接口调用 Toast、Alert、Guard 组件。 程序初始化时配置自定义 UI 样式，快速调用。 用简便的方法拿到已发布的实例，避免重复发布实例。 可对已发布的实例进行数据更新。 横竖屏和 iPad 布局优化。 易于扩展，可以很方便的添加任意控件，并处理好布局。 可对所有实例监听消失事件。 Toast - 顶部浮动通知条 多个 Toast 并存策略（平铺）。 只接收一个点击事件。 可以预先对不同的场景配置不同的默认值（图标、持续时间）。 Alert - 页面中心弹窗 多个 Alert 并存策略（具有景深效果的堆叠）。 可以预先对不同的场景配置不同的默认值（图标、持续时间）。 可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。 对已发布的实例进行文本和按钮的更新，包括新增、修改、删除文本和按钮。 强制退出按钮（防止超时导致页面卡死）。 Guard - 页面底部操作表 快速创建具有预先配置的默认样式的文本元素（标题、副标题、正文）。 可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。 设计思路UI与逻辑分离这个库采用配置 UI 和调用接口分离的设计，这种思路借鉴了和而泰公共库，我认为这是一种调用比传统 UI 库方便的同时可定制化能力也比传统 UI 库强大的设计思路。 简单来说，就是你在 AppDelegate 中告诉 ProHUD，你要的横幅、弹窗、操作表分别是什么样的，如果参数是什么什么，就怎么展示 UI。然后调用的地方就不需要设置 UI 了，只需要专注于数据。 例如弹出一个正在加载的提示框：Alert.push(scene: .loading, title: &quot;正在加载&quot;, message: &quot;请稍等片刻&quot;) 这样就发出了一个弹窗，而弹窗的样式，则在 AppDelegate 中以及预先配置好了。我使用了 scene 这个灵活的参数，你可以自己扩展场景。 为程序的弹窗场景设置模板，实现快速调用：extension ProHUD.Scene &#123; static var confirm: ProHUD.Scene &#123; var scene = ProHUD.Scene(identifier: &quot;confirm&quot;) scene.image = UIImage(named: &quot;ProHUDMessage&quot;) return scene &#125; static var delete: ProHUD.Scene &#123; var scene = ProHUD.Scene(identifier: &quot;delete&quot;) scene.image = UIImage(named: &quot;ProHUDTrash&quot;) scene.title = &quot;确认删除&quot; scene.message = &quot;此操作不可撤销&quot; return scene &#125; static var buy: ProHUD.Scene &#123; var scene = ProHUD.Scene(identifier: &quot;buy&quot;) scene.image = UIImage(named: &quot;ProHUDBuy&quot;) scene.title = &quot;确认付款&quot; scene.message = &quot;一旦购买拒不退款&quot; return scene &#125;&#125; 一个 scene 就可以理解成一套模板。 动态更新ProHUD 另一个优势就是动态更新，对于已经发布的实例，你可以方便的去更新内容。 示例1：获取刚才弹出的Loading，把它更新为加载成功。Alert.find(&quot;loading&quot;, last: &#123; (a) in a.update &#123; (vm) in vm.scene = .success vm.title = &quot;同步成功&quot; vm.message = nil &#125;&#125;) 示例2：获取刚才弹出的Loading，把它更新为加载失败，并增加重试按钮。Alert.find(&quot;loading&quot;, last: &#123; (a) in a.update &#123; (vm) in vm.scene = .error vm.title = &quot;同步失败&quot; vm.message = &quot;请检查网络是否连接&quot; vm.add(action: .default, title: &quot;重试&quot;) &#123; // do something &#125; vm.add(action: .cancel, title: &quot;取消&quot;, handler: nil) &#125;&#125;) 极端场景很多库没有多实例管理，很容易出现简单粗暴的视图重叠现象，ProHUD 针对不同场景做了不同的优化，对于横幅来说，可以平铺显示，像系统的通知中心一样，你可以拖拽向上移除。对于弹窗来说，我给底层的弹窗做了景深效果处理，使得看起来不像是 BUG。 https://xaoxuu.com/wiki/prohud/https://xaoxuu.com/wiki/prohud/","tags":["iOS","Swift","开源库","ProHUD"],"categories":["设计开发"]},{"title":"心率管家的设计与开发（上篇：整体流程）","path":"/blog/20190723/","content":"近期开发并上架了新版心率管家 App（仅 iOS 端），专业版不定期限免，欢迎下载体验。本文将从设计、开发、上架等每个步骤和细节进行分享，也包含部分模块源码。 心率管家https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1 立项确定需求立项的初衷是满足随时测心率的需求（没有智能手环手表的人群），App 核心功能就是测量心率，围绕这个功能展开的是测量时更多细节的记录、对已有数据的筛选。再往深度挖掘的是数据分析、健康预测。 市场考察虽然 AppStore 已有，但是无一例外都特别丑，要么收费要么有广告，所以不如自己做一个。 测量原理光电容积脉搏波描记法（PPG） 是追踪可见光（通常为绿光）在人体组织中的反射。它具备一个可见光光源来照射皮肤，再使用光电传感器采集被皮肤反射回来的光线。PPG 有两种模式，透射式和反射式，像一般的手环手表这样，光源和传感器在同一侧的，就是反射式；而医院中常见的夹在指尖上的通常是透射式的，即光源和传感器在不同侧。 皮肤本身对光线的反射能力是相对稳定的，但是心脏泵血使得血管容积周期性地变化，导致反射光也呈现出周期性的波动值，特别是在指尖这种毛细血管非常丰富的部位，这种周期性的波动很容易被观察到。 Wikipedia: #Photoplethysmogram 对应到 App 上就是通过分析摄像头每一帧画面的色值，计算出颜色波动的频率，即为近似心率。 定价策略 付费版：价格波动，通过降价和限免吸引爬虫收录。 免费版：限制了部分个性化功能，核心功能不受影响，没有任何广告。 技术方案语言：Swift5设计模式：MVC路由方案：JLRoutes主题和UI管理：Inspire缓存方案：SQLite数据同步方案：暂定AppleHealth 设计初期使用 Sketch 制作效果图，在后期直接在项目中进行调整，没有再更新到 Sketch 中。下面这是最终发布到 AppStore 的应用截图： 开发心率测量组件心率测量功能开发为一个私有库，具体实现稍后补充。。。 可定制UI使用 Inspire 作为主题管理器，目前暂未支持主题切换，后续更新会加入。 快捷指令使用 JLRoutes 路由方案，目前支持 URLSchemes 启动并开始测量，可接受两个参数： // 直接启动heartmatepro://record// 自定义补光灯亮度（亮度值 l 为浮点数，取值范围是0~1）heartmatepro://record?l=0.3// 自定义补光灯亮度和测量样本容器大小（样本容器大小 c 为正整数，取值范围是1~20）heartmatepro://record?l=0.1&amp;c=10 免费版限制了自定义亮度，但是你依然可以通过这种方式来自定义。 ProHUD使用 ProHUD 来负责弹窗和操作表，包括隐私政策页面。 上架新建应用，填写名称、BundleId 等资料，然后在 App 页面填写描述、网址、隐私政策链接、上传截图、确定分级…… 待应用通过 testflight 测试无误后，打包上传。然后过几分钟 appstoreconnect 页面就可以选中刚才上传的包了，然后提交审核，第二天就审核通过。（现在 AppStore 新应用审核也太快了） https://appstoreconnect.apple.comhttps://appstoreconnect.apple.com 迭代数据价值后续迭代中会在测量详情页面下方的留白处加上【标签】、【备注】、【数据分析】模块，前两者利于检索数据，数据分析目前没有能力独自完成，计划使用第三方服务。 细节图标这是一次彻底重做，所以也可以算是初版。很多细节还比较粗糙，例如图标没有经过打磨，设置列表连图标都没有。 占位图很多页面在没有数据的时候也没有占位的图片，这个也会慢慢完善。 心率区间心率卡片的颜色、心率卡片右上角以及归档页面心率的底部的彩色长条代表的是当前所处的心率区间，App 中并没有说明，后续迭代中也会完善这里。并且心率区间的划分需要年龄和性别，这个也会在后期进行完善。 下篇：信号处理https://xaoxuu.com/blog/20200927/https://xaoxuu.com/blog/20200927/","tags":["iOS","Swift","心率"],"categories":["设计开发"]},{"title":"整理 iOS 老项目中混乱不堪的多语言翻译","path":"/blog/20171225/","content":"linksmart 项目截止目前已经支持了 17 个国家的语言，从诞生到现在也已经经历了很多程序员的修改和维护，代码已经变得十分混乱。因为公司一直在接新的定制项目，所以也没有时间进行一次彻底的重构，只能在维护某方面的 BUG 的时候，对相关代码进行局部重构。 现在的情况是： 同一个文本有些语言有翻译，有些语言没有翻译。 有些需要使用缩进的地方，由于某种原因，并没有使用 UIEdgeInsets 进行缩进，而是在文本前后加空格。(⊙﹏⊙)b 整理思路首先必须得找出一种合适的方法维护这些 Localizable.strings，在 Excel 里做一个总表，增加语言的时候，可以直接把英文的一列发给客户进行翻译。最大的优势是：随时可以用脚本把 Excel 里的所有语言导出成项目支持的 Localizable.strings 文件，极大提高效率。 1. 补全使用 genstrings 命令将所有 .m 文件中的 LocalizedString 文本生成 Localizable.strings。打开终端，进入需要检测的文件夹，执行以下命令： find ./ -name &quot;*.m&quot; -print0 | xargs -0 genstrings -o ./ 生成的这一份文件只包含所有 .m 文件中的国际化字符串，并不包含 plist 和 xib 中的字符串。接下来只要把这一份和原来的所有翻译合并起来去重，就得到一份最全的 key。 如果也需要检测 xib、.h 文件，则执行以下命令： find . -name &#x27;*.xib&#x27; -o -name &#x27;*.[mh]&#x27; -print0 | xargs -0 genstrings -o ./ 生成的文件会存在当前目录。 2. 合并去重我尝试过直接读取 Localizable.strings 文件，但提示编码错误，就暂时 copy 到 txt 文件中进行处理。 合并的Demo：https://github.com/xaoxuu/LocalizedTool-iOS 3. 导入Excel接下来的步骤工作量有点大，就是重新把那些翻译导入 Excel 中，补全缺少的那些翻译。 1. 下载，解压下载工具：https://github.com/CatchZeng/Localizable.strings2Excel 。 解压开之后把里面的两个zip也解压开 2. 安装工具pyexcelerator打开命令行工具，cd到 .../Localizable.strings2Excel-master/pyexcelerator-0.6.4.1 文件夹，执行： sudo python setup.py install xldcd到 .../Localizable.strings2Excel-master/xlrd-1.0.0 文件夹，执行： sudo python setup.py install 3. 使用脚本cd到 .../Localizable.strings2Excel-master/python 文件夹 如需将Excel表格转换成Localizable.strings或者strings.xml文件，执行： python LocalizableBack.py -f xxx/xxx.xls -t xxx/xxx 如需将Localizable.strings或者strings.xml文件转换成Excel表格，执行： python Localizable.py -f xxx/ -t xxx/ 工具的链接在：GitHub&#x2F;CatchZeng 感谢作者编写了如此方便的工具！更多详细使用脚本请阅读 官方README文件 。 附：检测中文字符串如果项目的默认语言是中文，而且前期没有用多语言写法，可以使用 Xcode 的替换功能，将中文字符串替换成多语言的写法： 搜索： (@&quot;[^&quot;]*[\\u4E00-\\u9FA5]+[^&quot; ]*?&quot;) 替换为： NSLocalizedStringFromTable($0, @&quot;Localizable&quot;, nil)","tags":["iOS","Code"],"categories":["解决方案"]},{"title":"在 iOS 开发中，如何实现只推迟而不会重复执行的函数","path":"/blog/20171109/","content":"在 iOS 开发中，如果想推迟执行一段代码，使用 dispatch_after 函数可以轻易实现，但有时候我们想在它推迟的期间再次推迟，直到最终不再推迟的时候，才真正的被调用一次。这就需要每次先将旧的事件取消，然后重新设置。 自动消失的视图 例如当用户的某种操作点击一下屏幕就发出一条状态栏消息，消息在2秒后消失，在消失前如果用户又触发了这个条件，理应是在这次触发的2秒后消失，如果简单的使用 dispatch_after 函数进行延迟，结果会是在第一次点击的2秒后消失，可能你在1.5秒的时候又点击了一下，但是只过了0.5秒就消失了。 降低服务器访问次数 例如：用户修改了信息的30秒后上传至服务器。那么如果用户修改了姓名，然后30秒内又修改了头像，在修改了头像后的30秒内又修改了性别等等。我们希望的并不是每次修改就上传一次，而是在用户最后修改完所有信息之后，看起来似乎不准备继续修改了的时候，再上传至服务器。使用推迟而不重复执行的方法可以在避免多次访问服务器的同时及时地上传用户修改后的信息。 便捷的方案：GCD实现的方法很简单，步骤如下： 获取到函数 取消函数 重新赋值或启动 使用 Objective-C在 Objective-C 中，将要执行的代码保存成 dispatch_block_t 的静态类型变量，取出这个静态变量，然后使用 dispatch_block_cancel() 取消，然后重新设置它的值，然后调用 dispatch_after。 - (void)delayTest&#123; static dispatch_block_t task; if (task) &#123; dispatch_block_cancel(task); &#125; task = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123; // 被推迟执行的代码 &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC)), dispatch_get_main_queue(), task);&#125; 也可以使用 AXKit 实现也可以使用 AXKit 封装好的方法，将要执行的代码保存成 ax_dispatch_operation_t 的静态类型变量，使用 ax_dispatch_cancel_operation() 取消之前的任务，然后使用 ax_dispatch_cancellable() 再次赋值。- (void)delayTest2&#123; static ax_dispatch_operation_t animationToken; ax_dispatch_cancel_operation(animationToken); animationToken = ax_dispatch_cancellable(duration, dispatch_get_main_queue(), ^&#123; // 被推迟执行的代码 &#125;);&#125;.. 使用 Swift创建静态变量 static var task = DispatchWorkItem.init&#123;&#125;，先取消 task.cancel()，再赋值 DispatchWorkItem，然后使用 DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task) 延迟调用。 internal static var task = DispatchWorkItem.init &#123;&#125;internal static func hide(duration: TimeInterval) &#123; task.cancel() task = DispatchWorkItem.init(block: &#123; // 被推迟执行的代码 &#125;) DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task)&#125; 更高效的方案：定时器上述方案存在一定的性能问题，在低频触发时没有问题，但是在每一秒都要触发一次或多次的时候，显然不合适。这时候可以设置一个定时器，通过定时器延迟调用，每次触发的时候只是修改定时器的 fireDate 属性，实现步骤不再赘述。","tags":["GCD","ObjC","Swift"],"categories":["解决方案"]},{"title":"iOS 接入 Strava 分享模块（下篇：StravaSDK）","path":"/blog/20170628/","content":"StravaKit 是一个比较新而且代码比较规范的第三方SDK，但是目前还没有上传功能（详见 todo）。所以我不得已对 StravaKit 0.9.5 增加上传功能，并进行一些简单封装和改编，使之能够植入到公司项目中。由于时间有限，我只增加了上传fit文件的功能，并且使用了第三方框架 Alamofire，所以需要在项目中导入 Alamofire。 开始使用StravaSDK 下载：StravaSDK.zip 配置环境需要三个参数：ClientId、ClientSecret 和app的 URLSchemes。其中前两个是在 Strava平台 注册一个app的时候会给出。示例代码： StravaSDK.config(clientId: &quot;18583&quot;, clientSecret: &quot;a05fde98a830effde2e0f84cc39d76b040d4d67e&quot;, appSchemes: &quot;hitfit&quot;) 授权获取授权 StravaSDK.authorize() 取消授权 StravaSDK.deauthorize() 查询是否已授权 StravaSDK.isAuthorized 上传活动数据（.fit）StravaSDK.uploadActivity(path: &quot;.../test.fit&quot;, type: &quot;run&quot;, name: &quot;Afternoon Run&quot;) &#123; (response, error) in&#125;","tags":["iOS","StravaSDK"],"categories":["解决方案"]},{"title":"iOS 接入 Strava 分享模块（上篇：FitSDK）","path":"/blog/20170622/","content":"fit 是一种文件协议，体积小巧，多用于可穿戴设备记录、传输运动与健康数据。官方提供了 C、C++、Java 语言的 SDK 和非常详细的使用文档。因此在 iOS 端接入 fit 就需要在 C 或 C++ 的 SDK 基础上进行一点面向对象的封装。 认识 Fit我使用的 C 语言的 SDK，官方有示例 demo，在 fit_mgr 文件中提供了一些示例，这些代码未必全部都要用到。创建一个最简单的 .fit 文件的流程是： 写 fileidvoid fit_transaction_file(FIT_FILE type, FIT_MANUFACTURER manufacturer, FIT_UINT16 product, FIT_UINT32Z serial_number)&#123; // Write file id message. FIT_UINT8 local_mesg_number = 0; FIT_FILE_ID_MESG file_id; Fit_InitMesg(fit_mesg_defs[FIT_MESG_FILE_ID], &amp;file_id); // @xaoxuu: type FIT_FILE_ACTIVITY = 4 活动数据 file_id.type = type; // @xaoxuu: 厂商 file_id.manufacturer = manufacturer; // @xaoxuu: 产品 // file_id.product_name file_id.product = product; // @xaoxuu: 序列号 file_id.serial_number = serial_number; // @xaoxuu: 生产日期 // time_t now; // time(&amp;now); // file_id.time_created = now; WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FILE_ID], FIT_FILE_ID_MESG_DEF_SIZE, static_fp); WriteMessage(local_mesg_number, &amp;file_id, FIT_FILE_ID_MESG_SIZE, static_fp);&#125;void fit_transaction_field_desc() &#123; // Write a Field Description FIT_UINT8 local_mesg_number = 1; FIT_FIELD_DESCRIPTION_MESG field_description_mesg; Fit_InitMesg(fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], &amp;field_description_mesg); field_description_mesg.developer_data_index = 0; field_description_mesg.field_definition_number = 0; field_description_mesg.fit_base_type_id = FIT_BASE_TYPE_UINT16; WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], FIT_FIELD_DESCRIPTION_MESG_DEF_SIZE, static_fp); WriteMessage(local_mesg_number, &amp;field_description_mesg, FIT_FIELD_DESCRIPTION_MESG_SIZE, static_fp);&#125; 写 record// 写入Record Defenitionvoid fit_transaction_record_def()&#123; FIT_UINT8 local_mesg_number = 2; WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_RECORD], FIT_RECORD_MESG_DEF_SIZE, static_fp);&#125;// 循环写入record数据void fit_transaction_record_msg(unsigned int timestamp, int position_lat, int position_long, unsigned int distance, unsigned short altitude, unsigned short speed, unsigned char heart_rate)&#123; //Record message FIT_UINT8 local_mesg_number = 2; FIT_RECORD_MESG record; Fit_InitMesg(fit_mesg_defs[FIT_MESG_RECORD], &amp;record); record.timestamp = timestamp; record.position_lat = position_lat; record.position_long = position_long; record.distance = distance; record.altitude = altitude; record.speed = speed; record.heart_rate = heart_rate; WriteMessage(local_mesg_number,&amp;record,FIT_RECORD_MESG_SIZE,static_fp);&#125; 开始封装设计模型FitActivity.h //// FitAcitvity.h// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@class FitActivityRecord;typedef NS_ENUM(NSUInteger, FitActivityType) &#123; FitActivityTypeWalk = 11, // 枚举值等于FIT_SPORT值 FitActivityTypeRun = 1, FitActivityTypeRide = 2, FitActivityTypeSwim = 5, FitActivityTypeHike = 17,&#125;;@interface FitActivity : NSObject// @xaoxuu: fit 文件路径@property (copy, readonly, nonatomic) NSString *path;// @xaoxuu: 活动名@property (copy, nonatomic) NSString *name;// @xaoxuu: 活动类型@property (assign, nonatomic) FitActivityType type;// @xaoxuu: 活动类型@property (copy, readonly, nonatomic) NSString *typeString;// @xaoxuu: records@property (strong, nonatomic) NSMutableArray&lt;FitActivityRecord *&gt; *records;/** 添加一条record @param record record */- (void)addRecord:(void (^)(FitActivityRecord *aRecord))record;@end@interface FitActivityRecord : NSObject// @xaoxuu: timestamp@property (assign, nonatomic) unsigned int timestamp;// @xaoxuu: position_lat@property (assign, nonatomic) int position_lat;// @xaoxuu: position_long@property (assign, nonatomic) int position_long;// @xaoxuu: distance@property (assign, nonatomic) unsigned int distance;// @xaoxuu: altitude@property (assign, nonatomic) unsigned short altitude;// @xaoxuu: speed@property (assign, nonatomic) unsigned short speed;// @xaoxuu: heart_rate@property (assign, nonatomic) unsigned char heart_rate;@end FitActivity.m //// FitAcitvity.m// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import &quot;FitAcitvity.h&quot;@implementation FitActivity- (instancetype)init &#123; if (self = [super init]) &#123; _records = [NSMutableArray array]; self.type = FitActivityTypeWalk; &#125; return self;&#125;- (void)setType:(FitActivityType)type&#123; _type = type; switch (type) &#123; case FitActivityTypeWalk: _typeString = @&quot;walk&quot;; break; case FitActivityTypeRun: _typeString = @&quot;run&quot;; break; case FitActivityTypeRide: _typeString = @&quot;ride&quot;; break; case FitActivityTypeSwim: _typeString = @&quot;swim&quot;; break; case FitActivityTypeHike: _typeString = @&quot;hike&quot;; break; &#125;&#125;- (void)setName:(NSString *)name&#123; _name = name; _path = [self pathWithName:name];&#125;- (void)addRecord:(void (^)(FitActivityRecord *aRecord))record&#123; if (record) &#123; FitActivityRecord *rec = [FitActivityRecord new]; record(rec); [self.records addObject:rec]; &#125;&#125;- (NSString *)pathWithName:(NSString *)name&#123; NSString *path = [[NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;com.xaoxuu.fitsdk&quot;] stringByAppendingPathComponent:name]; path = [path stringByAppendingPathExtension:@&quot;fit&quot;]; // create dir if not exist NSFileManager *fm = [NSFileManager defaultManager]; NSString *dir = path.stringByDeletingLastPathComponent; BOOL result = [fm createDirectoryAtPath:dir withIntermediateDirectories:YES attributes:nil error:nil]; if (!result) &#123; NSLog(@&quot;can not create the directory at path %@&quot;,dir); &#125; return path;&#125;@end@implementation FitActivityRecord- (instancetype)init&#123; if (self = [super init]) &#123; _timestamp = 702940946; _position_lat = 0; _position_long = 0; _distance = 0; _altitude = 0; _speed = 0; _heart_rate = 0; &#125; return self;&#125;@end 封装接口FitSDK.h //// FitSDK.h// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &quot;FitAcitvity.h&quot;@interface FitSDK : NSObject/** 创建一个活动数据fit文件 @param activity 活动数据 @return 活动数据模型 */+ (FitActivity *)createActivity:(void (^)(FitActivity *activity))activity;@end FitSDK.m //// FitSDK.m// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import &quot;FitSDK.h&quot;#import &quot;fit_mgr.h&quot;@implementation FitSDK+ (FitActivity *)createActivity:(void (^)(FitActivity *activity))activity&#123; FitActivity *act = [FitActivity new]; if (activity) &#123; activity(act); &#125; [self createActivityWithModel:act]; return act;&#125;+ (void)createActivityWithModel:(FitActivity *)activity&#123; // @xaoxuu: fit file const char *fp = [activity.path cStringUsingEncoding:NSUTF8StringEncoding]; fit_transaction(fp, activity.type, ^&#123; [activity.records enumerateObjectsUsingBlock:^(FitActivityRecord * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; fit_transaction_record_msg(obj.timestamp, obj.position_lat, obj.position_long, obj.distance, obj.altitude, obj.speed, obj.heart_rate); &#125;]; &#125;);&#125;@end 使用FitActivity *activity = [FitSDK createActivity:^(FitActivity *activity) &#123; activity.name = @&quot;test&quot;; activity.type = FitActivityTypeRun; for (int i = 0; i&lt;100; i++) &#123; [activity addRecord:^(FitActivityRecord *aRecord) &#123; aRecord.timestamp = [[NSDate date] timeIntervalSince1970] - 631065600; aRecord.position_lat = 495280430+i*1000; aRecord.position_long = -872696681-i*1500; aRecord.distance = 2+i/100; aRecord.altitude = 287.2+i; aRecord.speed = 0.29+i/50; aRecord.heart_rate = 68+i/4; &#125;]; &#125;&#125;];// activity.path就是生成的fit文件路径NSLog(@&quot;%@&quot;, activity.path);","tags":["iOS","FitSDK"],"categories":["解决方案"]},{"title":"如何封装自己的 iOS Framework 静态库","path":"/blog/20161106/","content":"像工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库。 步骤 创建工程，最好是起名为 xxxDemo 例如 AXKitDemo，然后新建一个 target 名为 AXKit，并把原来的工程改名为 AXKit。（为了方便在 demo 中调试静态库） 新建一个 target ，选择类型为 framework。 在 framework 中创建需要封装的类，写好代码。 在 Build Setting 里更改参数，Math-O Type 为 Static Library。 在 Build Phases -&gt; Headers 里将需要暴露出来的头文件从 Project 移动到 Public。 添加一个 Aggregate 的 target，并添加运行脚本。目的是把编译出来的真机版和模拟器版的 framework 合并。 模拟器编译一下，真机编译一下，然后 Aggregate 编译一下，然后在项目的 Products 文件夹里就有了最终生成的静态库。 自动合成脚本Aggregate 的 Run Script 脚本： if [ &quot;$&#123;ACTION&#125;&quot; = &quot;build&quot; ]thenINSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.frameworkDEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.frameworkif [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]thenrm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;fimkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;#ditto &quot;$&#123;DEVICE_DIR&#125;/Headers&quot; &quot;$&#123;INSTALL_DIR&#125;/Headers&quot;lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot;#open &quot;$&#123;DEVICE_DIR&#125;&quot;#open &quot;$&#123;SRCROOT&#125;/Products&quot;fi","tags":["iOS","Framework"],"categories":["解决方案"]},{"title":"如何从 UIImageView 指定的坐标点取色？","path":"/blog/20160914/","content":"开发中有时候会遇到这样的需求，要给用户一个取色板，让用户从中自由地选取颜色，用来改变主题或者控制灯具的颜色等。这时候我们就需要获取一个视图的指定坐标的颜色值。 有时候我们可能会需要一个取色器，例如我的蓝牙灯项目，让用户从一个取色器中随意取色： #import &lt;CoreGraphics/CoreGraphics.h&gt;#import &quot;UIImage+ColorAtPixel.h&quot;@implementation UIImage (ColorAtPixel)- (UIColor *)colorAtPixel:(CGPoint)point &#123; // Cancel if point is outside image coordinates if (!CGRectContainsPoint(CGRectMake(0.0f, 0.0f, self.size.width, self.size.height), point)) &#123; return nil; &#125; // Create a 1x1 pixel byte array and bitmap context to draw the pixel into. // Reference: http://stackoverflow.com/questions/1042830/retrieving-a-pixel-alpha-value-for-a-uiimage NSInteger pointX = trunc(point.x); NSInteger pointY = trunc(point.y); CGImageRef cgImage = self.CGImage; NSUInteger width = CGImageGetWidth(cgImage); NSUInteger height = CGImageGetHeight(cgImage); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); int bytesPerPixel = 4; int bytesPerRow = bytesPerPixel * 1; NSUInteger bitsPerComponent = 8; unsigned char pixelData[4] = &#123; 0, 0, 0, 0 &#125;; CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGColorSpaceRelease(colorSpace); CGContextSetBlendMode(context, kCGBlendModeCopy); // Draw the pixel we are interested in onto the bitmap context CGContextTranslateCTM(context, -pointX, -pointY); CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, (CGFloat)width, (CGFloat)height), cgImage); CGContextRelease(context); // Convert color values [0..255] to floats [0.0..1.0] CGFloat red = (CGFloat)pixelData[0] / 255.0f; CGFloat green = (CGFloat)pixelData[1] / 255.0f; CGFloat blue = (CGFloat)pixelData[2] / 255.0f; CGFloat alpha = (CGFloat)pixelData[3] / 255.0f; return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];&#125;@end 开始优化/** 从圆形范围内的指定点获取UIColor对象，并在block中执行操作 @param point 指定坐标点 @param completion 取色完成后执行的block */- (void)ax_getColorFromCircleWithPoint:(CGPoint)point completion:(void (^)(UIColor *color))completion; 调用起来应该是这样的： // 已知imageView、point[imageView ax_getColorFromCircleWithPoint:point completion:^(UIColor *color)&#123; // 在这里直接用color&#125;]; 因为取色板一般是圆形的，如果坐标点超出了圆形但依然在imageView的frame内，可能会返回一些用户不期望的结果，用block巧妙地解决了这一问题，超出范围就不再有回调。如果你认为我的封装使用起来更加方便，可以继续阅读下面详细内容。 开始使用推荐CocoaPods方式，在podfile中添加一行： pod &#x27;AXKit&#x27; 然后在终端中执行 pod install 即可完成安装。 AXKit的全局头文件是： // 通过CocoaPods或静态库方式安装#import &lt;AXKit/AXKit.h&gt;// 通过手动方式#import &quot;AXKit.h&quot; 接口声明从指定点获取RGBA值- (void)ax_getRed:(nullable CGFloat *)red green:(nullable CGFloat *)green blue:(nullable CGFloat *)blue alpha:(nullable CGFloat *)alpha withPoint:(CGPoint)point;// 调用起来是这样的：// 已知imageView、pointCGFloat r,g,b,a;[imageView ax_getRed:&amp;r green:&amp;g blue:&amp;b alpha:&amp;a withPoint:point];// 然后r/g/b/a就有了值 需要自己创建变量，然后把地址传进去，然后才能用，不推荐直接使用。 从指定点获取RGBA值，并在block中执行操作加了一个block，调用起来就方便许多： - (void)ax_getRGBAWithPoint:(CGPoint)point completion:(void(^)(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getRGBAWithPoint:point completion:^(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha)&#123; // 在这里直接用red/green/blue/alpha&#125;]; 优点是不需要自己创建变量，直接调用方法，在block回调里直接获得red&#x2F;green&#x2F;blue&#x2F;alpha值。 但是，很多时候，我们用的取色器是圆形的，就需要再进行一点封装。 从圆形范围内的指定点获取RGBA值，并在block中执行操作- (void)ax_getRGBAFromCircleWithPoint:(CGPoint)point completion:(void (^)(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getRGBAFromCircleWithPoint:point completion:^(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha)&#123; // 在这里直接用red/green/blue/alpha&#125;]; 跟第2种调用方法一模一样，但是区别是超出圆形范围之后就不再执行block回调了，这是一种安全的做法。如果不用block方式，那么即使超出了圆形范围，也一定会返回对应的rgba值，会造成不想要的后果。 block的回调机制巧妙地解决了这个问题。 如果我想直接获得一个UIColor对象呢，跟获取RGBA一样有三种方法。 从指定点获取UIColor对象- (nullable UIColor *)ax_getColorWithPoint:(CGPoint)point;// 调用起来是这样的：// 已知imageView、pointUIColor *color = [imageView ax_getColorWithPoint:point];// 获得UIColor对象 由声明可以看出来，返回的值是一个可空类型，因此这跟第一种方法一样是不安全的。 从指定点获取UIColor对象，并在block中执行操作- (void)ax_getColorWithPoint:(CGPoint)point completion:(void(^)(UIColor *color))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getColorWithPoint:point completion:^(UIColor *color)&#123; // 在这里直接用color&#125;]; 这种方法比第4种要方便一些，如果超出UIImageView的时候就不执行block里的代码。 从圆形范围内的指定点获取UIColor对象，并在block中执行操作- (void)ax_getColorFromCircleWithPoint:(CGPoint)point completion:(void (^)(UIColor *color))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getColorFromCircleWithPoint:point completion:^(UIColor *color)&#123; // 在这里直接用color&#125;]; 引言中的Demo用的就是这一种方法，在圆形取色器中取色，既方便又安全。 附：Gist","tags":["iOS","开源项目"],"categories":["解决方案"]},{"title":"ObjC 使用链式语法更优雅地管理沙盒文件","path":"/blog/20160912/","content":"假如你需要把一个字典或者别的什么东西保存到沙盒里，你准备怎么做？也许你已经条件反射的想到了操作步骤……其实，你可以不必每次都那么老老实实的把每一步写出来，一行代码就可以了：【路径+保存文件】两个关键点，组成一条链式语法。 @&quot;文件名&quot;.cachePath.save(要保存的内容); 接入AXKit如果你的项目里还没有AXKit，可以在pod文件里添加一条 pod &#39;AXKit&#39; 进行接入，也可移步至AXKit在线文档查看详细的安装和使用方法。 路径我封装了几个常用的沙盒路径，如下： - (nullable NSString *)mainBundlePath; // mainBundlePath就是主工程项目里的文件路径- (NSString *)docPath; // 文档，iTunes会备份，适合保存重要的数据- (NSString *)cachePath; // 缓存，iTunes不会备份，适合保存不太重要的较大的数据- (NSString *)tempPath; // 临时文件，iTunes不会备份，系统空闲时会自动删除，设备重启时也会删除 除此之外，还提供了所有的路径，通过枚举的方式获取： - (NSString *(^)(NSSearchPathDirectory))path; // 传入NSSearchPathDirectory枚举就可得到路径 示例在沙盒的文档路径里有个叫 abc.plist 的文件，它的描述就是： @&quot;abc.plist&quot;.docPath; 路径的拼接任何一个字符串都可以使用 .append() 进行拼接。 保存保存的方法目前提供有四个： - (BOOL(^)(id))savePlist;- (BOOL(^)(NSObject&lt;NSCoding&gt; *))saveArchivedPlist;- (BOOL(^)(NSObject&lt;NSCoding&gt; *))saveArchivedObject;- (BOOL(^)(id &lt;NSCoding&gt;))save; 示例 在doc路径下保存一个名为”arr.plist”的文件： NSArray *arr = [NSArray array];BOOL result = @&quot;arr&quot;.docPath.savePlist(arr); 在cache路径下归档一个名为”myfile.plist”的文件： MyProfiles *myfile = [[MyProfiles alloc] init];// MyProfiles类需实现NSCoding协议BOOL result = @&quot;myfile&quot;.cachePath.saveArchivedPlist(myfile); ​ 读取读取的方法目前提供了七个： - (nullable __kindof NSArray *)readArray;- (nullable __kindof NSDictionary *)readDictionary;- (nullable id)readArchivedPlist;- (nullable id)readJson;- (nullable NSString *)readTxt;- (nullable id)readArchivedFile;- (nullable id)readArchivedObject; 示例 在doc路径下读取一个名为”arr.plist”的文件： NSArray *arr = @&quot;arr&quot;.docPath.readArray; 在cache路径下解档一个名为”myfile.plist”的文件： MyProfiles *myfile = @&quot;myfile&quot;.cachePath.readArchivedPlist; ​ 查询遍历路径下所有文件 // 获取doc/myDir 路径下所有的扩展名为&quot;plist&quot;文件路径NSArray *paths = @&quot;myDir&quot;.docPath.subpaths(@&quot;plist&quot;);// 如果传入值为空，则不区分扩展名获取所有文件路径NSArray *paths2 = @&quot;myDir&quot;.docPath.subpaths(@&quot;&quot;);// paths里面装的是doc/myDir路径下的所有文件完整路径 删除结构：【路径+删除】 - (BOOL)removePlist;- (BOOL)removeJson;- (BOOL)removeTxt;- (BOOL)remove; 示例 在doc路径下删除一个名为”arr.plist”的文件： BOOL result = @&quot;arr.plist&quot;.docPath.remove; 在cache路径下删除一个名为”myfile.plist”的文件： MyProfiles *myfile = @&quot;myfile.plist&quot;.cachePath.remove; 详细文档https://xaoxuu.com/wiki/axkit/https://xaoxuu.com/wiki/axkit/","tags":["iOS","链式语法","沙盒","缓存"],"categories":["设计开发"]},{"title":"我关于未来的智能生活的畅想","path":"/blog/20160211/","content":"我从小就对「活着」的机械十分着迷，就是我们现在所说的人工智能，当我初次了解到这个概念的时候，就确定了我将奉献一生的事业。 然而梦想很遥远，遥远到我这辈子无法见证《I, Robot》那样的时代。 智能家居我相信，不久的未来会有越来越多的东西要接入互联网，接入互联网就可以用手机控制。网络就像神经，门窗联了网，门窗就活了，扫把联了网，扫把就活了。等所有的家具家电都联网的时候，就需要一个平台来管理这些智能硬件了。 所有接入互联网的传感器都成为了这个智能系统的感官，神经将这些信息传递到可以分析、处理数据的终端，经过计算后作出应答，并由这些神经传递指令到相应的智能设备上。 人与人、人与物之间的联系就更加紧密了，随时的远程互动，远程协助都更加方便了。当然，这中间涉及到的隐私和网络安全问题也十分重要，但问题总要解决，不能因噎废食。 传统硬件，将一步一步被替换为智能硬件，至少是能用手机 app 控制，用手机 app 来控制，就是一种雏形了。毕竟目前没有足够多的智能硬件，没有到需要开发一个系统的程度。 平台化现在智能硬件也越来越多了，网络也十分发达了，但是它们的「语言」不同，各厂商的产品都用自己的标准，不同厂商之间的硬件是无法协同工作的。它们需要一个协议、或者一个平台，来实现合作。平台，也许就是智能家居时代来临的一个必要条件吧。","categories":["闲聊时间"]},{"title":"如何进行有效的团队合作","path":"/blog/20130206/","content":"本文只是我在大学时期关于小组决策效率与分工方面的思考，可能不适用于其它场景。 在任何一个团队中，我始终都是先做一个观察者，因为在掌握足够的信息之前，我的看法可能是片面的，由此产生的观点及推论发表出来可能会误导人。 偏执我印象非常深刻的一次经历：初二的时候，物理老师提问一个思考问题，我的答案和班上其它同学的都不一样，我有点犹豫了，老师说了一句话：有时候，真理往往掌握在少数人手中 正是那一次的正确的坚持，让我受益匪浅。这件事在我的成长过程中起到了非常重要的作用，所以现在我是一个对认定事情非常偏执的人。 要相信自己有理有据的判断，在追求真理的路上敢于以一敌众，后来的某些经历也表明，即使所有人都反对你，你也未必要因此放弃，因为真相总有浮出水面的时候。 交流意见然而我却又是一个不爱争论的人，往往我发表完我的意见，也理解了对方的意见之后，就不会再继续谈论了。 为什么不说服别人呢？我会尝试去说服别人，但是当说服的难度远远大于它所带来的意义的时候，我就放弃了。我没有当过领导者，所以说服别人对我来说也不是个必选项，尤其是考虑到这个过程所花费的时间成本跟成果的价值孰轻孰重，我会越来越谨慎行事。 独立决策与民主决策两者并非不可兼得。为什么要兼得？为了效率。 我的眼中只有效率，不在乎形式，假如一个问题有两种既定方案，如果三十个人讨论半天各执己见，有些人选择A方案，有些人选择B方案，选择A方案的人试图说服选择B方案的人，选择B方案的人也试图说服选择A方案的人，最终的结果可能是选A也可能是选B，也可能出来一种新的C方案。 不是所有人都能看见真相，经过讨论可能会让更多人走向正确的道路，也有可能会让少部分持有最佳方案却意志不够坚定的人被说服放弃，历史上这样的例子并不少见，每时每刻，都有数不清的人会在讨论中与成为历史或被历史遗忘擦肩而过。 我们更需要的是：交流意见 –&gt; 独立思考 –&gt; 独立决策。 合力不等于力量的叠加力量都是有方向的，方向相同则相加。很多时候一次糟糕的合作导致若干力量相抵消，最终还不如一个人的效率高，一个聪明的团队应该在力量和方向上都作出最优选择。 我自认为是一个没有大家所谓的“团队精神”的人，因为我认为即使我们做不到最好，也不要硬撑着搞形式，作出最糟糕的选择，效率才是最终目的。","categories":["胡思乱想"]},{"path":"/about/index.html","content":"友链关于xaoxuuLive long and prosper. 🖖 本站是 @xaoxuu 的个人站，博主目前主要从事于 iOS 开发行业，活跃于开源社区，热衷于设计和打磨美妙的东西。代表作有：ProHUD、ValueX、Stellar、心率管家 等，更多的作品可以去 项目 页查看，希望大家喜欢～ 音乐游戏话题非常热爱音乐，喜欢的品类很多，尤 Hans Zimmer 和 Two Steps From Hell 的史诗音乐，夜深人静的时候喜欢听 Ludovico Einaudi 的钢琴曲，除此之外，电音、摇滚、轻音乐等都是我喜欢的类型。喜欢的音乐家或音乐公司有： Hans ZimmerTwo Steps From HellThomas BergersenLudovico EinaudiCapo ProductionsAviciiAlan WalkerDavid ArkenstoneRoberto CacciapagliaAudiomachine 游戏 推荐指数 游玩时间 Red Alert 2 ★★★★ 2005-2012 World of Warcraft ★★★★☆ 2006-2020 Red Alert 3 ★★★★☆ 2013-2021 Minecraft ★★★★ 2013-2016 Bad Piggies ★★★★★ 2014-2017 Terraria ★★★★☆ 2014-2021 Don‘t Starve ★★★★☆ 2015-2021 Ori and the Blind Forest ★★★★★ 2018-2020 Human Fall Flat ★★★★★★ 2018-2021 此外，也渴望了解和思考这方面的知识：产品设计、摄影、宇宙、时间、自由意志与宿命论。 博主近期的动态 关于本站 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎去对应的仓库点个赞，或者在对应的文章下面留言互动一下。 开源项目无任何盈利目的，只在工作闲暇时间进行维护，有相关需求请前往对应项目提 Issue 进行反馈，通过私人邮件询问开源项目问题可能得不到答复。"},{"path":"/bookmark/index.html","content":"随记收藏收藏 Mac 应用下载 appstorrenthttps://appstorrent.ruMacBL马可菠萝 - 分享你喜欢的MAC应用Xclient精品MAC应用分享MacApp分享频道https://macapp.org.cn/app/MACYYhttps://www.macyy.cn/resources 设计灵感和素材 UnsplashPhotos for everyone.DribbbleDiscover the world’s top designers & creatives.FlaticonAccess 3,260,000 vector icons.HeroiconsFree Open Source SVG Icon LibraryuplabsUnlimited Android Templates Ready for Commercial Use - UpLabsCodyHouseWeb Design Made Easier创造狮导航Discover the world’s top designers & creatives.Pinterest寻找值得尝试的新点子Iconfont阿里巴巴矢量图标库HTML5 UPHTML5 网站模板getwallpapersUniverse of Awesome Curated WallpapersWallpaperAccess高质量壁纸pixel4k高清壁纸Material PaletteMaterial Design Color Palette Generator.设计师网址导航优设导航 - 学设计从这里开始！ 开发工具 在线工具国内镜像站screenshot快速生成网站截图thum.io快速生成网站截图Neumorphism.ioGenerate Soft-UI CSS codeShields IOhttps://shields.iojson.cnhttps://www.json.cnFavicon Generatorhttps://realfavicongenerator.net去不图床免费图床david-smith.org查询iOS各个版本用户量iPhone 参数大全https://kylebing.cn/tools/iphone/LaTeX公式编辑器https://www.latexlive.com/清华大学开源软件镜像站https://mirrors.tuna.tsinghua.edu.cn阿里云官方镜像站https://developer.aliyun.com/mirror/ 技术加油站 行业大佬技术社区OneV's Den上善若水，人淡如菊曾静的博客但行好事，莫问前程唐巧的博客记录下自己学习的点滴步步走前端大佬Stack Overflowhttps://stackoverflow.comRUNOOBhttp://www.runoob.comW3schoolhttp://www.w3school.com.cn廖雪峰的官方网站https://www.liaoxuefeng.com"},{"path":"/friends/index.html","content":"友链关于小伙伴们如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。 [2023-12] 友链失联了怎么办?添加友链后如果网站长期无法访问，可能会被取消友链！如果您的网站恢复了，可以在申请友链时创建的那条 issue 中评论告知。 朋友们近期的文章 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与 xaoxuu 有至少 半年 的有效互动，例如 issue 或者评论留言。 [2023-12] 友链申请条件变更说明降低了对商业广告的要求，可以有但是不能太多。提高了「有效互动」的定义：5次更改为半年。 我已满足全部条件，快告诉我如何交换友链！如果您没有满足上述条件，即时提交了申请也不会通过哦～第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中：title: xaoxuuurl: https://xaoxuu.comavatar: https://bu.dusays.com/2021/09/24/2f74810ceb3d3.pngscreenshot: https://bu.dusays.com/2022/10/23/63542895cfd29.png待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"},{"path":"/notes/index.html","content":"随记收藏随记"},{"path":"/privacy/index.html","content":"隐私政策本站不收集和存储您的任何数据本站非常重视所有访客的隐私和个人信息保护，未使用任何访客统计和分析工具，未追踪您的 IP 地址、运营商信息，不会请求获取定位信息，不获取访问设备和浏览器信息，仅在您使用评论时，会要求登录 GitHub 账号进行授权，相关隐私政策见 GitHub 隐私声明，此第三方服务与本站无关，本站不存储任何数据。"},{"path":"/timeline/index.html","content":"探索者手记 本页面数据来源于：memos"},{"path":"/blog/hot/index.html","content":""},{"path":"/friends/rss/index.html","content":"朋友文章"},{"title":"Flutter 相关问题","path":"/notes/flutter/index.html","content":"运行时弹出「无法打开“iproxy”，因为无法验证开发者。」弹窗，手动添加信任： sudo xattr -r -d com.apple.quarantine futter的SDK目录/bin/cache/artifacts/usbmuxd/iproxy 清除缓存，重新 build： rm -rf buildflutter cleanflutter build ios --debug"},{"title":"Json在线解析工具","path":"/notes/json/index.html","content":""},{"title":"Mac 相关问题","path":"/notes/mac/index.html","content":"提示 “安装包已损坏” 怎么办？如何清理 Mac 的 DNS 缓存sudo killall -HUP mDNSRespondersudo killall mDNSResponderHelpersudo dscacheutil -flushcacheTNT 团队的应用无法使用怎么办？TNT 的证书签署的软件在 2019年7月12日 后都不能运行了，临时的解决办法，就是自己签名。1. 安装 Xcode安装 Xcode，你可以在 App Store 中下载安装，并且至少运行一次。2. 安装 Command Line Tools 工具打开终端工具输入如下命令：弹出后选择继续安装。3. 为应用签名打开终端工具输入并执行如下命令：codesign --force --deep --sign - /Applications/name.app注意后面的文件路径，你可以打开访达找到应用程序，找到要签名的软件，直接拖入「终端」界面，即可自动生成路径。如何显示隐藏文件显示隐藏外置磁盘路径/volume/磁盘路径/~~~例如一个名称为 “Files” 的磁盘里的文件夹 “Projects” 路径是:/Volumes/Files/Projects/使用终端将 json 文件转为 plist 文件plutil -convert xml1 data.json -o data.plist其中 data.json、data.plist 分别对应转换前后的文件路径。sudo 依然没有权限的解决办法查询 SIP 状态关闭 SIP开启 SIP如果输出以下信息，说明 SIP 开启，需要暂时将 SIP 关闭。System Integrity Protection status: enabled.重启 Mac，按住 command + R 直到出现开机 logo，此时会进入 Recovery 模式，选择「实用工具」-&gt;「Terminal」并输入以下命令：然后重新启动电脑即可关闭 SIP。重启 Mac，按住 command + R 直到出现开机 logo，此时会进入 Recovery 模式，选择「实用工具」-&gt;「Terminal」并输入以下命令：然后重新启动电脑即可开启 SIP。搭载 Intel 芯片的 Mac 启动组合键Command (⌘)-R：从内建的 macOS 恢复系统启动。或者，您也可以使用 Option-Command-R 或 Shift-Option-Command-R 以通过互联网从 macOS 恢复功能启动。macOS 恢复功能可以安装不同版本的 macOS，具体取决于您在电脑启动时使用的组合键。如果您的 Mac 使用了固件密码，系统将提示您输入这个密码。Option (⌥) 或 Alt：启动进入“启动管理器”，您可以从中选取其他可用的启动磁盘或宗卷。如果您的 Mac 使用了固件密码，系统将提示您输入这个密码。Option-Command-P-R：重置 NVRAM 或 PRAM。如果您的 Mac 使用了固件密码，电脑会忽略这个组合键或从 macOS 恢复功能启动。Shift (⇧) ：以安全模式启动。如果使用了固件密码，这个组合键将被停用。D：启动进入“Apple 诊断”实用工具。也可以使用 Option-D 通过互联网启动进入这个实用工具。如果使用了固件密码，这个组合键将被停用。N：从 NetBoot 服务器启动，前提是您的 Mac 支持网络启动宗卷。要使用服务器上默认的引导映像，请按住 Option-N。如果使用了固件密码，这个组合键将被停用。Command-S：以单用户模式启动。如果运行的是 macOS Mojave 或更高版本，或者使用了固件密码，这个组合键会被停用。T：以目标磁盘模式启动。如果使用了固件密码，这个组合键将被停用。Command-V：以详细模式启动。如果使用了固件密码，这个组合键将被停用。推出键 (⏏)、F12、鼠标按钮或触控板按钮：推出可移动介质，例如光盘。如果使用了固件密码，这个组合键将被停用。"},{"title":"Node.js 相关问题","path":"/notes/nodejs/index.html","content":"查看当前的源： 官方源： 淘宝源："},{"title":"服务器相关问题","path":"/notes/server/index.html","content":"GitHub Action + Hexo 部署到服务器在本地电脑生成 ssh key 创建 git 用户 设置 ssh把本机的 id_isa.pub 内容复制到这里： /home/git/.ssh/authorized_keys 如果通过 ssh 登录仍需要密码的解决方法找到并修改 /etc/ssh/sshd_config 文件： #禁用root账户登录，如果是用root用户登录请开启PermitRootLogin yes# 是否让 sshd 去检查用户家目录或相关档案的权限数据，# 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。# 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入StrictModes no# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys# 有了证书登录了，就禁用密码登录。PasswordAuthentication no 然后重启 sshd 服务 网站路径创建网站，以 /www/wwwroot/xaoxuu.github.io 为例，/www/wwwroot/xaoxuu.github.io 的权限要改成 777 并且所有者为 www 才可以访问。 GitHub Action/blog/20221126/https://xaoxuu.com/blog/20221126/ 设置 webhookpost-receive#!/bin/shWEBROOT=/www/wwwroot/xaoxuu.github.iogit --work-tree=$WEBROOT checkout -f master 把上述的 post-receive 文件放在这里： /home/git/xxx.git/hooks/post-receive /www/wwwroot/xaoxuu.github.io 的权限要改成 777 才行 https://zhuanlan.zhihu.com/p/58654392https://zhuanlan.zhihu.com/p/58654392 GitLab把上述的 post-receive 文件放在这里： /var/opt/gitlab/git-data/repositories/root/xxx.git/custom_hooks/post-receive GitLab 的 ssh 能记住密钥， hook 也正常，缺点就是每个月多花10块钱满足 GitLab 最低配置要求。 404打开 nginx 配置文件，拉到最后，看到： include /www/server/panel/vhost/nginx/*.conf; 然后根据这个路径找到自定义的配置文件： /www/server/panel/vhost/nginx/xaoxuu.com.conf 在其中添加如下代码就可以了： server&#123; ... fastcgi_intercept_errors on; error_page 404 /404.html; location = /404.html &#123; root /www/wwwroot/xaoxuu.github.io; &#125; ...&#125; 宝塔相关关闭面板SSL如果不小心打开了SSL且无法访问，可以在云服务商那边登录，输入这行命令关闭面板SSL："},{"title":"综合型ObjC开发工具包","path":"/wiki/axkit/index.html","content":"特性沙盒文件 使用链式语法快速存取沙盒文件 .toJson() .toJson() 快速将字典、数组与 json 进行转换以及非空判断 Blocks 构造方法的 block 支持 EventTarget 的 block 支持 给视图添加手势的 block 支持（Runtime） Cooldown 代码冷却机制（基于 GCD 实现） Date+ NSDate 的链式封装（日期的格式化和操作） 开始使用在 Podfile 中添加：pod &#x27;AXKit&#x27; 然后执行：pod install 示例沙盒文件与ToJson保存 NSDictionary *dict = @&#123;@&quot;name&quot;: @&quot;Alex&quot;&#125;;@&quot;File.json&quot;.docPath.saveJson(dict); 读取和转换 id read = @&quot;File.json&quot;.docPath.readJson();NSDictionary *readDict = NSDictionary.safe(read);NSArray *readArr = NSArray.safe(read); 转换 NSUserDefaults.setObjectForKey(@23, @&quot;age&quot;);NSUserDefaults.numberForKey(@&quot;age&quot;);NSUserDefaults.setObjectForKey(@&quot;23&quot;, @&quot;age&quot;);NSUserDefaults.numberForKey(@&quot;age&quot;);// 以上两种情况都可以正常读取到值，因为内部做了自动转换 Cooldown// 10秒内即使多次调用也不会重复执行ax_dispatch_cooldown(0, 10, &quot;cool&quot;, dispatch_get_main_queue(), ^&#123; // do something&#125;, ^&#123; NSLog(@&quot;正在冷却，请稍后&quot;)&#125;); Date+NSDate *date = NSDate.initWithFormat(@&quot;yyyyMMdd&quot;, @&quot;20160802&quot;);date = date.addDays(1).addhours(-1).addWeeks(-2).addMinutes(20);NSString *str = date.stringWithFormat(@&quot;yyyyMMdd&quot;); Blocks手势 [view ax_addTapGestureHandler:^(UITapGestureRecognizer * sender) &#123; // 点击事件&#125;];[view ax_addPanGesture:nil handler:^(UIPanGestureRecognizer * sender) &#123; // 拖拽&#125;];[view ax_addLongPressGesture:^(UILongPressGestureRecognizer * sender) &#123; sender.minimumPressDuration = 5;&#125; handler:^(UILongPressGestureRecognizer * sender) &#123; // 长按&#125;];... 事件 UIButton *button;[button ax_addTouchUpInsideHandler:^(UIButton * sender) &#123; // 点击&#125;];UISlider *slider;[slider ax_addEventHandler:^(UISlider * sender) &#123; // 事件&#125; forControlEvents:UIControlEventValueChanged];..."},{"path":"/wiki/cloud-shell/index.html","content":"什么是 cloud-shell 一个轻量级云端脚本库，里面的脚本不依赖任何包管理工具，一行代码即可使用。 在终端中输入以下指令可以安装对应脚本： curl -s https://sh.xaox.cc/install | sh 脚本名 也可以指定分支或版本号： curl -s https://sh.xaox.cc/install | sh 脚本名 分支或版本号 快来试一试吧～"},{"title":"认识 Git","path":"/wiki/git/index.html","content":"什么是 Git ？Git 是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 与 SVN 区别点 Git 是分布式的，SVN 不是。这是 Git 和其它非分布式的版本控制系统如 SVN，CVS 等最核心的区别。 Git 把内容按元数据方式存储，而 SVN 是按文件。 Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 Git 没有一个全局的版本号，而 SVN 有。目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 Git 的内容完整性要优于 SVN。Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 图片来源于 RUNOOB Git 工作区、暂存区和版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。"},{"title":"心率管家","path":"/wiki/heartmate/index.html","content":"专为那些没有智能手环或手表却需要测量心率的用户而设计，可以方便快捷的测量和记录心率。 使用Heart Mate心率助手，你可以在没有智能手环等心率监测设备的情况下随时检测并记录自己的心率。 通过设置tag标签，快速记录当前状态，如饭后、运动后等，方便以后检索具有同样标签的心率数据，从而分析这些情景下的心率数据，发现健康问题。 心率管家App（仅iOS端），专业版不定期限免，欢迎下载体验。 如果您看到的时候已经过了限免期，可以先下载免费版使用。为了吸引app推荐类网站的爬虫进行推荐，专业版的价格通常在1元到68元之间浮动变化的。 下载安装心率管家（免费版）https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1 心率管家（专业版）https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1463348922?ls=1 如何测量 第一步，调整位置请用一只手指同时按住手机后方的摄像头和闪光灯，调整遮挡的位置使上方的取景器看起来是红色的。 第二步，保持不动太好了，现在手指尽量不要动，请等待数据稳定，这大概需要10秒钟。 第三步，继续保持不动正在采集数据，马上就要成功了，手指请继续保持不动。 第四步，请松开手恭喜您，测量已经完成，您可以松开手指结束此次测量，也可以保持不动继续测量更长时间以提高准确性。 App内部有详细的使用帮助。 近期限免日程 付费真不是为了赚钱，是为了骗应用推荐类网站的爬虫给我做推广，同时这样也减少了免费时的莫名其妙的大量差评。已经高价购买的用户实在是抱歉，我的其它 App 也会采用类似的定价策略，所以请多多关注我的博客，能省下不少钱呢。 安装测试版安装地址：https://testflight.apple.com/join/rqNjAxg1"},{"title":"基于主题的Swift开发工具包","path":"/wiki/inspire/index.html","content":"特性可缓存的 App 的样式参数（颜色、字体、布局）存储于 json 文件中。 可配置的 可由用户修改主题参数并保存或者分享。 提供便利 便捷的方式获取屏幕布局参数、如各边安全区域尺寸，便于机型适配。 开始使用在 Podfile 中添加：pod &#x27;Inspire&#x27; 然后执行：pod install 用法示例颜色view.backgroundColor = .backgroundview.tintColor = .accent 字体let lb = UILabel()lb.font = .regular(15)lb.font = .bold(20, for: .title)lb.font = .regular(14, for: .code) 边距let topMargin = layout.topBarHeight(for: self)let bottomMargin = layout.bottomBarHeight(for: self)let safeArea = layout.safeAreaInsets(for: self)let safeArea2 = Inspire.shared.screen.safeAreaInsets let layout = Inspire.shared.layoutview.frame.size.height = layout.rowHeightview.layer.cornerRadius = layout.cornerRadius.large 缓存// 保存Inspire.shared.cache()Inspire.shared.cache(named: &quot;myTheme&quot;)// 读取let ipr = Inspire.init(&quot;myTheme&quot;)"},{"title":"NEXUS","path":"/wiki/nexus/index.html","content":"点击屏幕左上角，即可呼出搜索栏，此搜索栏对于一些常用的网站如[优酷]、[淘宝]等等可以直达官网，省去了搜索引擎检索的步骤。左上角热键是透明的，不影响视觉，只有在允许后台运行时才会生效。 适用平台Windows 7~10 下载https://github.com/xaoxuu/NEXUS-Windows/releases/https://github.com/xaoxuu/NEXUS-Windows/releases/ 已归档这是一个已经归档的项目，最后一次更新时间是在2017年1月。"},{"title":"易于上手又完全可定制化的专业HUD库","path":"/wiki/prohud/index.html","content":"易于上手 用极少的参数就可以创建并显示一个实例。 用相似的接口调用Toast、Alert、Sheet。 功能丰富 具有完善的实例管理（多实例共存方案、查找与更新方案）。 可对已发布的实例进行数据更新。 横竖屏和iPad布局优化。 完全可定制化 支持只使用ProHUD的容器，而容器内容可完全自定义。 程序初始化时配置自定义UI样式，调用的时候只需要关注数据。 易于扩展，可以很方便的添加任意控件。 Toast（顶部通知横幅）通知条控件，用于非阻塞性事件通知。显示效果如同原生通知，默认会自动消失，可以支持手势移除，有多条通知可以平铺并列显示。 方式一：传入ViewModel生成实例这种方式创建的实例在调用push()之后才会显示出来，结构为： let 实例 = Toast(视图模型)实例.push() 也可以连在一起写，例如： Toast(.message(&quot;要显示的消息内容&quot;)).push() 如何创建ViewModelViewModel有多种创建方式，也可以自行扩展更多常用场景，例如： // 纯文本let vm = .message(&quot;要显示的消息内容&quot;)// 持续2s的文本let vm = .message(&quot;要显示的消息内容&quot;).duration(2)// 标题 + 正文let vm = .title(&quot;标题&quot;).message(&quot;正文&quot;) 内置了几种常见的场景扩展，例如正在加载的场景： static var loading: ViewModel &#123; let obj = ViewModel(icon: UIImage(inProHUD: &quot;prohud.windmill&quot;)) obj.rotation = .init(repeatCount: .infinity) return obj&#125;static func loading(_ seconds: TimeInterval) -&gt; ViewModel &#123; let obj = ViewModel(icon: UIImage(inProHUD: &quot;prohud.windmill&quot;), duration: seconds) obj.rotation = .init(repeatCount: .infinity) return obj&#125; 使用的时候可以： // 无限持续时间let vm = .loading// 无限持续时间, 带有文字let vm = .loading.message(&quot;正在加载&quot;)// 持续10slet vm = .loading(10)// 持续10s, 带有文字let vm = .loading(10).message(&quot;正在加载&quot;) 方式二：以闭包形式创建并显示实例对于复杂实例，建议以这种方式使用，例如给实例增加事件响应： let title = &quot;您收到了一条消息&quot;let message = &quot;点击通知横幅任意处即可回复&quot;Toast &#123; toast in toast.vm = .msg.title(title).message(message) toast.onTapped &#123; toast in toast.pop() Alert(.success(1).message(&quot;操作成功&quot;)).push() &#125;&#125; 也可以增加多个按钮，横向平铺，在这个例子中，左侧图标位置自定义为头像： let title = &quot;您收到了一条好友申请&quot;let message = &quot;丹妮莉丝·坦格利安申请添加您为好友，是否同意？&quot;Toast(.title(title).message(message)) &#123; toast in toast.isRemovable = false toast.vm.icon = UIImage(named: &quot;avatar&quot;) toast.imageView.layer.masksToBounds = true toast.imageView.layer.cornerRadius = toast.config.iconSize.width / 2 toast.add(action: &quot;拒绝&quot;, style: .destructive) &#123; toast in // 按钮点击事件回调 ... &#125; toast.add(action: &quot;同意&quot;) &#123; toast in // 按钮点击事件回调 toast.pop() Alert(.success(1).message(&quot;Good choice!&quot;)).push() &#125;&#125; 如果存在就更新，不存在就创建新的实例例如弹出一个loading，有多个地方需要更新这个loading，为了避免重复弹出多个实例，可以使用 lazyPush 方法： Toast.lazyPush(identifier: &quot;loading&quot;) &#123; toast in toast.vm = .loading.title(&quot;正在加载\\(i)&quot;).message(&quot;这条消息不会重复显示多条&quot;)&#125; 如果存在就更新，不存在就忽略指令如果要对一个已经存在的实例进行更新，假如实例已经结束显示了，那就不进行任何操作，这时候可以使用 find 方法： Toast.find(identifier: &quot;loading&quot;) &#123; toast in toast.vm = .success(2).message(&quot;加载成功&quot;)&#125; Alert（页面中心弹窗）弹窗控件，用于强阻塞性交互，用户必须做出选择或者等待结果才能进入下一步，当多个实例出现时，会以堆叠的形式显示，新的实例会在覆盖旧的实例上层。 Alert和Toast一样有两种创建方法，不再赘述。 修改实例内容在实例弹出后仍然可以修改实例内容： // 持有实例的情况下：Alert(.note) &#123; alert in alert.vm.message = &quot;可以动态增加、删除、更新文字&quot; alert.add(action: &quot;增加标题&quot;) &#123; alert in alert.vm.title = &quot;这是标题&quot; alert.reloadTextStack() &#125; alert.add(action: &quot;增加正文&quot;) &#123; alert in alert.vm.message = &quot;可以动态增加、删除、更新文字&quot; alert.reloadTextStack() &#125; alert.add(action: &quot;删除标题&quot;, style: .destructive) &#123; alert in alert.vm.title = nil alert.reloadTextStack() &#125; alert.add(action: &quot;删除正文&quot;, style: .destructive) &#123; alert in alert.vm.message = nil alert.reloadTextStack() &#125; alert.add(action: &quot;取消&quot;, style: .gray)&#125;// 未持有实例时，可通过 identifier 查找并更新：Alert.find(identifier: &quot;my-alert&quot;) &#123; alert in alert.vm.title = &quot;这是标题&quot; alert.reloadTextStack()&#125; 按钮的增删改查Alert(.note) &#123; alert in alert.vm.message = &quot;可以动态增加、删除按钮&quot; alert.add(action: &quot;在底部增加按钮&quot;, style: .filled(color: .systemGreen)) &#123; alert in alert.add(action: &quot;哈哈1&quot;, identifier: &quot;haha1&quot;) &#125; alert.add(action: &quot;在当前按钮下方增加&quot;, style: .filled(color: .systemIndigo), identifier: &quot;add&quot;) &#123; alert in alert.insert(action: .init(identifier: &quot;haha2&quot;, style: .light(color: .systemOrange), title: &quot;哈哈2&quot;, handler: nil), after: &quot;add&quot;) &#125; alert.add(action: &quot;修改当前按钮文字&quot;, identifier: &quot;edit&quot;) &#123; alert in alert.update(action: &quot;已修改&quot;, for: &quot;edit&quot;) &#125; alert.add(action: &quot;删除「哈哈1」&quot;, style: .destructive) &#123; alert in alert.remove(actions: .identifiers(&quot;haha1&quot;)) &#125; alert.add(action: &quot;删除「哈哈1」和「哈哈2」&quot;, style: .destructive) &#123; alert in alert.remove(actions: .identifiers(&quot;haha1&quot;, &quot;haha2&quot;)) &#125; alert.add(action: &quot;删除全部按钮&quot;, style: .destructive) &#123; alert in alert.remove(actions: .all) DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; alert.pop() &#125; &#125; alert.add(action: &quot;取消&quot;, style: .gray)&#125; 添加自定义控件Alert &#123; alert in alert.vm.title = &quot;自定义控件&quot; // 图片 let imgv = UIImageView(image: UIImage(named: &quot;landscape&quot;)) imgv.contentMode = .scaleAspectFill imgv.clipsToBounds = true imgv.layer.cornerRadiusWithContinuous = 12 alert.add(subview: imgv).snp.makeConstraints &#123; make in make.height.equalTo(120) &#125; // seg let seg = UISegmentedControl(items: [&quot;开发&quot;, &quot;测试&quot;, &quot;预发&quot;, &quot;生产&quot;]) seg.selectedSegmentIndex = 0 alert.add(subview: seg).snp.makeConstraints &#123; make in make.height.equalTo(40) make.width.equalTo(400) &#125; // slider let slider = UISlider() slider.minimumValue = 0 slider.maximumValue = 100 slider.value = 50 alert.add(subview: slider) alert.add(spacing: 24) alert.add(action: &quot;取消&quot;, style: .gray)&#125; Sheet（底部操作表）操作表控件，用于弱阻塞性交互。显示区域为从屏幕底部向上弹出的新图层，可以放置丰富的内容，自由度较高。 布局操作表控件空间较大，可以放置更多的文字、按钮和其它任何控件。 Sheet &#123; sheet in sheet.add(title: &quot;ProHUD&quot;) sheet.add(subTitle: &quot;什么是操作表控件&quot;) sheet.add(message: &quot;操作表控件，用于弱阻塞性交互。显示区域为从屏幕底部向上弹出的新图层，可以放置丰富的内容，自由度较高。&quot;) sheet.add(spacing: 24) sheet.add(action: &quot;确认&quot;, style: .destructive) &#123; sheet in Alert(.confirm) &#123; alert in alert.vm.title = &quot;处理点击事件&quot; alert.add(action: &quot;我知道了&quot;) &#125; &#125; sheet.add(action: &quot;取消&quot;, style: .gray)&#125; 同样支持添加任意其它视图： Sheet &#123; sheet in sheet.add(title: &quot;ProHUD&quot;) // 图片 let imgv = UIImageView(image: UIImage(named: &quot;landscape&quot;)) imgv.contentMode = .scaleAspectFill imgv.clipsToBounds = true imgv.layer.cornerRadiusWithContinuous = 16 sheet.add(subview: imgv).snp.makeConstraints &#123; make in make.height.equalTo(200) &#125; // seg let seg = UISegmentedControl(items: [&quot;开发&quot;, &quot;测试&quot;, &quot;预发&quot;, &quot;生产&quot;]) seg.selectedSegmentIndex = 0 sheet.add(subview: seg).snp.makeConstraints &#123; make in make.height.equalTo(40) make.width.equalTo(400) &#125; // slider let slider = UISlider() slider.minimumValue = 0 slider.maximumValue = 100 slider.value = 50 sheet.add(subview: slider).snp.makeConstraints &#123; make in make.height.equalTo(50) &#125;&#125; 拦截背景点击事件有时候如果不希望点击背景直接pop掉，可以实现 onTappedBackground 以拦截背景点击事件 Sheet &#123; sheet in sheet.add(title: &quot;ProHUD&quot;) sheet.add(message: &quot;点击背景将不会dismiss，必须在下方做出选择才能关掉&quot;) sheet.add(spacing: 24) sheet.add(action: &quot;确认&quot;) sheet.add(action: &quot;取消&quot;, style: .gray)&#125; onTappedBackground: &#123; sheet in print(&quot;点击了背景&quot;) Toast.lazyPush(identifier: &quot;alert&quot;) &#123; toast in toast.vm = .error toast.vm.title = &quot;点击了背景&quot; toast.vm.message = &quot;点击背景将不会dismiss，必须在下方做出选择才能关掉&quot; toast.vm.duration = 2 &#125;&#125; 定制属于自己的UI个性化配置ProHUD内置的布局也支持丰富的个性化参数，例如： 标题、正文、按钮字体字号 背景颜色、模糊效果 文字颜色 图标大小 卡片圆角 Sheet组件卡片距离屏幕的边距 具体请探索 ProHUD.Configuration 类代码。 完全自定义布局ProHUD支持完全自定义布局，即将整个容器交给使用者来布局，在 Alert.Configuration.shared 中配置了 reloadData 规则之后，实例在显示前以及更新内容时都会进入此函数，执行自定义的 reloadData 代码。也可以指定部分 identifier 走自定义布局代码，其余走内置布局代码，例如： Alert.Configuration.shared &#123; config in config.reloadData &#123; vc in if vc.identifier == &quot;custom&quot; &#123; return true &#125; return false &#125;&#125;Alert &#123; alert in alert.identifier = &quot;custom&quot; alert.contentView.backgroundColor = .systemYellow alert.view.addSubview(alert.contentView) alert.contentView.layer.cornerRadiusWithContinuous = 32 alert.contentView.snp.makeConstraints &#123; make in make.width.equalTo(UIScreen.main.bounds.width - 100) make.height.equalTo(UIScreen.main.bounds.height - 200) make.center.equalToSuperview() &#125; DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; alert.pop() &#125;&#125; 横屏和iPad适配"},{"title":"项目架构设计（iOS）","path":"/wiki/project-management/architectural-design.html","content":"iOS 项目架构设计是指为应用程序构建一个合理的、可扩展的、易于维护的架构。这涉及到选择适当的技术和设计模式，以确保应用程序在不同阶段的开发和维护过程中能够高效地运行。 项目层级划分以下是一个示例，在不同场景下可以根据项目的需要进行调整： 层 职责 描述 4 业务模块层 模块化业务代码，如直播模块、私信模块等。 3 业务服务层 面向业务需求的数据封装层，例如项目内通用的UI组件、网络服务等。 2 抽象服务层 跨项目通用的面向协议的服务或通用组件。 1 基础工具层 包含第三方库以及跨项目通用的基础工具，如类扩展等。 依赖关系要保持单向线性：上层可以依赖下层，下层不可以依赖上层，同一层级内不可互相依赖。例如： 第 4 层的模块可以依赖第 3、2、1 层的组件 第 3 层的组件只可以依赖第 2、1 层的组件 第 2 层的组件只可以依赖第 1 层的组件 第 1 层的组件只可以依赖其它第三方库 第 4 层的一个组件连同其依赖的底层组件能够成为一个独立的模块，这样可以保证依赖链清晰且没有冗余。 模块间的解藕前面实现了分层，但是如何处理模块与模块之间的通信呢？常用路由方案参考如下： casatwy&#x2F;CTMediator：基于消息传递的路由框架，它通过定义一组消息和对应的处理方法来实现页面之间的跳转和数据传递。简单易用，可以快速实现页面之间的跳转和数据传递，但是灵活性较差，不适合处理复杂的页面逻辑。 joeldev&#x2F;JLRoutes：基于 URL 路由的框架，它通过解析 URL 来实现页面之间的跳转和数据传递。灵活性较高，可以处理复杂的页面逻辑，但是需要更多的代码来实现页面之间的跳转和数据传递。 SwiftUI&#x2F;NavigationStack：SwiftUI 提供的一个路由框架，它通过视图栈和状态管理的方式实现页面之间的跳转和数据传递。简洁易用、可以处理复杂的页面逻辑；但是只能在 iOS 16 及以上版本中使用。 面向协议设计组件组件内部避免为了实现某个功能而直接依赖具体的第三方库，例如一个本地资源远程化功能的组件，需要拿到一个链接，下载资源、解压、然后本地缓存并提供获取资源接口。 不推荐的做法 👎直接依赖一个网络库和解压库（或实现下载和解压代码），内部实现完全部流程（下载、解压、后续处理）之后返回结果。看似组件开箱即用，但是却为项目的维护性、扩展性埋下了坑。如果项目里已有网络库和解压库，那么直接使用它就会额外被迫导入组件A直接依赖的库。 推荐的做法 👍声明一个 Downloader 协议：要求传入下载连接返回解压好的文件夹路径（异步）组件A内部不关心如何下载以及解压，只知道 Downloader 协议的对象返回的结果就是解压好的文件夹路径，因此内部依然能够继续进行后续流程并返回结果。调用层需要额外实现一下这个协议，如果项目里已有网络库和解压库，那么直接使用它就不会额外被迫导入组件A直接依赖的库。"},{"title":"部署代码管理和维护","path":"/wiki/project-management/code-management.html","content":"SVN &amp; Git虽然 git 相对于 SVN 的优越性显而易见，但是一般对员工而言，用什么取决于就职时公司用的是什么。我有幸主导过团队从 SVN 向自建 git 服务迁移。 SVN 与 Git 优缺点对比SVN 优点管理方便，逻辑明确，符合一般人思维习惯。易于管理，集中式服务器更能保证安全性。代码一致性非常高。适合开发人数不多的项目开发。SVN 缺点服务器压力太大，数据库容量暴增。如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。不适合开源开发。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。Git 优点适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。Git 缺点新手学习周期相对而言比较长。对于刚入门的人来说不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。 如何部署 git 服务以前曾在公司内部的 Mac 服务器上部署 Gitblit 供团队使用，现在公司用的是阿里云的 codeup 服务，但是我还是用 docker 在自己的云服务器上部署了一个 gitea 来作为 github 的镜像，比之前用的 Gitblit 更加完善好用。部署方法详见这篇文章： 搭建 Git 服务器https://xaoxuu.com/wiki/git/git-server"},{"path":"/wiki/project-management/index.html","content":"关于项目管理知识库本知识库为 @xaoxuu 根据自己的工作经验进行的思考和沉淀，采用 CC BY-NC-SA 4.0 许可协议，转载时请注明出处。内容未必适用于您的团队，仅供参考。"},{"title":"产研协作","path":"/wiki/project-management/product-development.html","content":"良好的产研协作规范有助于缩短产品研发周期、提高研发效率、降低研发成本，同时也能够推动企业的技术创新和产品升级。 iOS 素材规格iPhone 各代屏幕尺寸与分辨率经典屏幕iPhone iPhone 对角线 缩放 逻辑分辨率 物理分辨率 ppi 1、3G、3GS 3.5 @1x 320x480 320x480 163 4、4s 3.5 @2x 320x480 640x960 326 5、5s、SE 4 @2x 320x568 640x1136 326 6、6s、7、8、SE2、SE3 4.7 @2x 375x667 750x1334 326 6 Plus、6s Plus、7 Plus、8 Plus 5.5 @3x 414x736 1242x2208 401 全面屏iPhone iPhone 对角线 缩放 逻辑分辨率 物理分辨率 ppi X、XS、11 Pro 5.8 @3x 375x812 1125x2436 458 XR、11 6.1 @2x 414x896 828x1792 326 XS Max、11 Pro Max 6.5 @3x 414x896 1242x2688 458 12 mini、13 mini 5.4 @3x 375x812 1080x2340 476 12、12 Pro、13、13 Pro、14 6.1 @3x 390x844 1170x2532 460 12 Pro Max、13 Pro Max、14 Plus 6.7 @3x 428x926 1284x2778 458 14 Pro 6.1 @3x 393x852 1179x2556 460 14 Pro Max 6.7 @3x 430x932 1290x2796 460 iPad 各代屏幕尺寸与分辨率经典屏幕iPad iPad 对角线 缩放 逻辑分辨率 物理分辨率 ppi 1、2 9.7 @1x 768x1024 768x1024 132 mini 1 7.9 @1x 768x1024 768x1024 163 mini 2&#x2F;3&#x2F;4 7.9 @2x 768x1024 1536x2048 326 Air 1&#x2F;2 9.7 @2x 768x1024 1536x2048 264 Pro (9.7) 9.7 @2x 768x1024 1536x2048 264 iPad (10.2) 10.2 @2x 810x1080 1620x2160 264 Pro (10.5) 10.5 @2x 834x1112 1668x2224 264 全面屏iPad iPad 对角线 缩放 逻辑分辨率 物理分辨率 ppi mini 6 7.9 @2x 744x1133 1488x2266 326 Air 5 10.9 @2x 820x1180 1640x2360 264 Pro (11’ 2018) 11 @2x 834x1194 1668x2388 264 Pro (12.9’ 2018) 11 @2x 1024x1366 2048x2732 264 官方设计素材下载https://developer.apple.com/design/resources/ Logo &amp; 启动图UI 只需要提供一张 1024*1024 尺寸的图即可，开发使用 IconKit 工具可以直接生成开发需要的各种尺寸的图片及其 json 配置文件，直接拖进 Xcode 工程中就可以使用了。使用传统方式不同尺寸一张一张的切图不仅浪费 UI 的时间，开发也需要一张图一张图往对应位置拖，双方都很麻烦。 如果使用 LaunchImage 方式，需要切各个尺寸的图片，参考 iPhone 各代屏幕尺寸与分辨率 表，如果需要兼容 iPhone 4、4s 机型，则需要提供一共7种尺寸的图片，如果最低兼容 iPhone5 的话，就只需要提供6种尺寸的图片。 注意：iOS 并不需要 1920*1080 这种尺寸的图片。 icon 素材iOS 端的切图需要同时提供 @2x 和 @3x 两种尺寸的图片，例如某个名为 “imagename” 的图片需要提供两个文件分别命名为： imagename@2x.pngimagename@3x.png 素材名（imagename）命名可以根据公司或团队规范而异，但是两种尺寸的文件的素材名部分要保持一致，唯一的不同就是 @2x 和 @3x。"},{"title":"依赖库管理及其优化","path":"/wiki/project-management/project-dependency.html","content":"常见的依赖管理器优缺点对比CocoaPods优点 支持大量的第三方库。 简单易用的命令行界面。 自动处理库的依赖关系。 缺点 可能会遇到一些与 CocoaPods 本身或第三方库的兼容性问题。 可能会导致项目构建速度变慢。 Carthage优点 支持多种平台，包括 iOS、macOS 和 tvOS。 可以选择使用二进制文件或源代码构建库。 不会在项目中引入额外的依赖。 缺点 需要手动处理库的依赖关系。 可能需要更多的时间来设置和构建项目。 Swift Package Manager优点 是 Apple 官方提供的工具，与 Xcode 深度集成。 支持 Swift 和 Objective-C 库。 可以通过源代码或二进制文件管理库。 缺点 相对较新，可能不支持某些较旧的库。 依赖管理功能相对较弱。 Cocoapods基础使用最新版安装流程 （首次安装）移除现有Ruby默认源 （首次安装）使用新的源 （首次安装）验证新源是否替换成功 （可选）更新 gem 安装 CocoaPods Podfile 文件中的一些写法https://guides.cocoapods.org/using/the-podfile.htmlhttps://guides.cocoapods.org/using/the-podfile.html # 设置镜像源source &#x27;https://cdn.cocoapods.org/&#x27;# 忽略警告inhibit_all_warnings! 消除 Pod 版本过低的警告post_install do |installer| # 如果第三方库最低支持版本低于13，就改为13（消除xcode警告） installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if config.build_settings[&#x27;IPHONEOS_DEPLOYMENT_TARGET&#x27;].to_f &lt; 13.0 config.build_settings[&#x27;IPHONEOS_DEPLOYMENT_TARGET&#x27;] = &#x27;13.0&#x27; end end end # ... 也可以做一些其它的操作end 同理也可以批量对其它字段进行修改，用法很灵活。 发布和使用私有 Pod 库发布私有 podspec创建一个私有 Specs 仓库你需要在 GitHub 或其他 Git 托管服务上创建一个私有仓库，用于存储你的 Podspecs。创建 Podspec在你的项目根目录下创建一个新文件，名为 YourPod.podspec，其中 YourPod 是你的 Pod 的名称。在这个文件中，你需要填写 Pod 的相关信息，例如名称、版本、作者、源代码等。注册私有 Specs 仓库在终端中运行以下命令，将你的私有 Specs 仓库添加到 CocoaPods 的源列表中：pod repo add YourRepoName https://github.com/YourGitHubAccountName/YourSpecsRepo.git如果是公司内部使用，也可以使用内部的 git 仓库。验证 Podspec在终端中运行以下命令，验证你的 Podspec 是否有效：如果一切正常，你应该看到类似以下的输出：YourPod.podspec passed validation.推送 Podspec在终端中运行以下命令，将你的 Podspec 推送到你的私有Specs 仓库中：pod repo push YourRepoName YourPod.podspec这将把你的 Podspec 上传到你的私有Specs 仓库中。 你需要通过适当的权限设置确保私有 Specs 仓库对团队内部可见，否则其他团队成员无法使用。 使用方法在你的项目中，你可以使用 CocoaPods 来引入你的私有 Pod。在你的 Podfile 中添加以下内容： pod &#x27;YourPod&#x27;, :podspec =&gt; &#x27;https://github.com/YourGitHubAccountName/YourSpecsRepo.git&#x27; 然后，在终端中运行以下命令，安装你的私有 Pod： 如何使用本地的 Pod 库流程和私有 Pod 库相似，但是省略掉了发布过程，Specs 文件放置在某个本地目录就可以。这种方式一般用于本地调试或者通过 git submodule 来引用库。 发布开源库到 CocoaPods 官方平台准备工作1. clone 远程仓库到本地git clone 你的仓库链接 2. 注册 trunk注册的命令 pod trunk register 你的邮箱 你的用户名 记得去邮箱里验证，然后可以输入以下命令查看个人信息 pod trunk me 步骤1. 创建 .podspecpod spec create AXKit 2. 修改 .podspec 并验证有很多类似的教程，可以参考。 一个小技巧：你可以去GItHub搜索一些热门的第三方库，然后点击查看这些大牛的 .podspec 是怎么写的。传送门：YYKit的podspec、ReactiveObjC的podspec、BlocksKit的podspec 最容易出错的地方就是资源路径 s.source_files = &quot;AXKit/**/*.&#123;h,m&#125;&quot; 常见写法 &quot;Directory1/*&quot; 表示匹配所有文件&quot;Directory1/Directory2/*.&#123;h,m&#125;&quot; 表示匹配所有以.h和.m结尾的文件&quot;Directory1/**/*.h&quot; 表示匹配所有子目录 s.source 常见写法 # 推荐写法：与版本号绑定s.source = &#123; :git =&gt; &quot;https://github.com/TeaseTian/HTQRCode.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;# 与commit id 绑定s.source = &#123; :git =&gt; &quot;https://github.com/TeaseTian/HTQRCode.git&quot;, :commit =&gt; &quot;68defea&quot; &#125; tag &#x3D;&gt; s.version 表示将这个 Pod 版本与 Git 仓库中相同版本的 comit 绑定 注意如果仓库中对应的tag是 “v1.0.0”\b 这样以字母开头的，可以在 #{s.version} 前面加上对应的字母。commit &#x3D;&gt; “68defea” 表示将这个 Pod 版本与 Git 仓库中某个 commit 绑定 验证 pod spec lint AXKit.podspec 3. 上传到远程仓库修改 .podspec 时指定的版本号，如 0.0.1。那么远程仓库中必须始终存在这个版本的 branch 或 tag 才能够下载。建议使用 tag。s.source 中的 tag 需要与远程仓库中的 tag 对应起来。 s.version = &quot;0.0.1&quot;s.source = &#123; :git =&gt; &quot;https://github.com/xaoxuu/AXKit.git&quot;, :tag =&gt; &quot;v#&#123;s.version&#125;&quot; &#125; 这里指向的是 &quot;v0.0.1&quot; 这个分支，因为分支我们用完之后习惯把它删掉，所以这里也可以指向 tag，也就是说打一个 &quot;v0.0.1&quot; 的 tag 并推送到远程就可以了。 git tag v0.0.1git push --tags 这样做的好处就是删掉当前分支不影响 CocoaPods 中指向的仓库源码。 4. 发布到 CocoaPodspod trunk push AXKit.podspec n. 删除一个 podspec 版本删除的命令是： pod trunk delete 项目名 版本号 官方建议使用 deprecate 来弃用 pod trunk deprecate 项目名 这两种方法执行完有很大几率会出现一串很长很长的错误，不要着急，这实际上这是一个 html。把它保存到一个 html 文件中，打开，是个404错误页，原因众所周知。 删除之后立即搜索还是能搜到的，因为有一定的延迟，可能要半个小时才能更新。 pod trunk 命令在终端输入 pod trunk --help 可以查看帮助 使用脚本没必要每次都重复每个步骤，如果你已经发布过一个，可以省去注册的步骤，直接把已经发不过的 podspec 复制一份，改一下仓库模块名，验证通过就可以发布了。 我写了一个便于发布更新的脚本，把脚本放在与 podspec 同级目录下，当你更新了项目之后，如果需要更新到 cocoapods，可以执行此脚本。流程是： 输入版本号 -&gt; commit、push tag -&gt; pod spec lint -&gt; 询问是否发布(y/n) -&gt; 发布(y) https://github.com/xaoxuu/podspec.shhttps://github.com/xaoxuu/podspec.sh Swift Package Manager创建 Package按照下面操作创建： 菜单入口：File -&gt; New -&gt; Package 快捷键：⌃ + ⇧ + ⌘ + N 项目根目录下会有一个名为 Package.swift 的文件，该文件描述了你的项目的依赖项和设置。&gt; API 文档 如何增加 ObjC 代码和 Swift 大致相似，但是需要开放的头文件需要放在 include 文件夹中，文件路径参考如下： Sources/MyLibrary/xxx.swiftSources/MyLibrary/include/xxx.hSources/MyLibrary/xxx.m 增加图片等素材以开源库 ProHUD 为例： // swift-tools-version:5.6import PackageDescriptionlet package = Package( name: &quot;ProHUD&quot;, platforms: [.iOS(.v13)], products: [ .library(name: &quot;ProHUD&quot;, targets: [&quot;ProHUD&quot;]), ], dependencies: [ .package(url: &quot;https://github.com/SnapKit/SnapKit.git&quot;, &quot;5.0.0&quot; ..&lt; &quot;6.0.0&quot;), ], targets: [ .target( name: &quot;ProHUD&quot;, dependencies: [&quot;SnapKit&quot;], resources: [.process(&quot;Resources/ProHUD.xcassets&quot;)] ) ]) 相应的 xcassets 文件路径是： Sources/ProHUD/Resources/ProHUD.xcassets 为了使用方便，可以封装一下： extension UIImage &#123; public convenience init?(inProHUD named: String) &#123; self.init(named: named, in: .module, with: .none) &#125;&#125; 如何引用静态库有时候我们为了提高构建效率，会发布和使用二进制化的静态库： // swift-tools-version: 5.9// The swift-tools-version declares the minimum version of Swift required to build this package.import PackageDescriptionlet package = Package( name: &quot;MyPackage&quot;, platforms: [.iOS(.v13), .macOS(.v11)], products: [ // Products define the executables and libraries a package produces, making them visible to other packages. .library( name: &quot;MyBinaryLibrary&quot;, targets: [&quot;MyBinaryLibrary&quot;]), ], targets: [ // Targets are the basic building blocks of a package, defining a module or a test suite. // Targets can depend on other targets in this package and products from dependencies. .binaryTarget( name: &quot;MyBinaryLibrary&quot;, path: &quot;path/to/MyBinaryLibrary.xcframework&quot; ), ])"},{"title":"部署 Jenkins 进行持续集成","path":"/wiki/project-management/use-jenkins.html","content":""},{"title":"一个简约的在线简历主题","path":"/wiki/resume/index.html","content":"在线演示https://resume.js.org/zh-cn/ 主题源码https://github.com/xaoxuu/hexo-theme-resume 如何使用方式一 下载 示例源码 的整个仓库代码。 git clone https://github.com/xaoxuu/resume-docs 然后安装必要的依赖包 npm i 方式二创建全新的博客，通过 npm 命令安装： npm i hexo-theme-resume 然后删除多余的依赖包（重要），打开 package.json 复制并全部替换为以下内容： &#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;5.0.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;hexo server&quot;, &quot;build&quot;: &quot;node pre-deploy.js &amp;&amp; hexo clean &amp;&amp; hexo generate&quot;, &quot;deploy&quot;: &quot;npm run build &amp;&amp; hexo deploy&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=8.9.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^5.0.0&quot;, &quot;hexo-all-minifier&quot;: &quot;^0.5.3&quot;, &quot;hexo-autonofollow&quot;: &quot;^1.0.1&quot;, &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;, &quot;hexo-fs&quot;: &quot;^3.1.0&quot;, &quot;hexo-lazyload-image&quot;: &quot;^1.0.9&quot;, &quot;hexo-offline&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^1.1.0&quot;, &quot;hexo-server&quot;: &quot;^1.0.0&quot; &#125;&#125; 然后输入 npm i 安装依赖包。 编写简历打开 index.md 文件： resume-docs/src/index.md 按照示例中的提示语将信息修改为自己的。 部署打开站点配置文件： resume-docs/_config.yamldeploy: - type: git repo: # 项目路径 branch: master message: update pages Hexo官方教程：https://hexo.io/zh-cn/docs/one-command-deployment 小提示图标从这里找：https://fontawesome.com/如果需要更多DIY，请自行修改源码。简历主题不支持评论，如果需要，请自行集成。"},{"title":"蓝牙智能灯毕业设计项目","path":"/wiki/smartlamp/index.html","content":"特性调节亮度、颜色、定时关闭 主页是核心功能，实现一键连接蓝牙灯、自由调节颜色、亮度、设置定时关灯等功能。情景页是保存用户设置的情景模式，可以根据使用场景不同快速切换至对应的工作模式。设备页可以管理多台蓝牙灯。发现页提供一些智能家居相关资讯。 技术点ATTitleBar 支持横向滑动切换tab，并具有点击涟漪效果。 titlebar是在app中广泛应用的一种tab设计。我写的这个小框架模仿Google的Material Design设计，涟漪效果代码由MaterialControls框架改写。 页面较多时采用类似tableview的懒加载模式，只加载需要显示的几页，减少内存占用，提高流畅度。 ReactiveCocoa 本项目大量使用了ReactiveCocoa框架进行响应式编程，大幅简化代码、提高可读性。 RAC的订阅机制使得一对多传值有了新的选择，如蓝牙中心设备。 RAC的信号监听机制使得我更容易根据需要定制个性化控件。如带翻转、旋转效果的tabbar、带缩放和回弹效果的slider等，使app的界面栩栩如生。 CBCentralManager CBCentralManager是蓝牙类app的核心，本项目在编写这部分代码时使用了链式语法进行封装，外界调用起来十分方便。 ATCarouselView 轮播图也是在app中广泛存在的一种自定义控件，我将这部分代码封装至ATKit中，以Pods导入方式使用，便于维护和扩展，同时也使得本项目代码更加简洁。 部分app的轮播图可以根据下方列表的滑动而改变高度或者添加蒙版效果，我目前实现了改变高度的功能。"},{"title":"开始您全新的博客之旅","path":"/wiki/stellar/index.html","content":"Stellar 是一个内置文档系统的简约商务风 Hexo 主题，支持丰富的标签和动态数据组件，帮助您简单从容地应对各种表达需求，十分推荐内容创作者使用 Stellar 开始您全新的博客之旅。 了解 Stellar 的设计理念“真正的简约远不止删繁就简，而是在纷繁中建立秩序。”人的注意力是有限的，要提高有效信息的醒目程度，就必须降低不重要信息醒目程度，删除所有无效信息。降低视觉密度增加留白，增加间距。减少颜色丰富度，大面积出现的是中性色，彩色必须有其特殊意义，意义相同的元素使用同一种颜色。提高有效信息优先级文章标题永远是最大的，对比度最高的不可交互的不重要的小标题（如侧边栏某个插件的标题）降低对比度与文章相关的不重要的小标题，使用小号字体删掉无效信息文章标签、字数、阅读量、评论数网站访问量、字数、搭建时间全局播放器（除了特殊文章） 开始前的准备工作尽管我们致力于降低使用门槛，但是自建独立博客仍然需要一定的相关知识，markdown 常用语法是必须要掌握的，除此之外，您还需要知道 yaml 文件格式、简单的 git 知识，最最重要的是，遇到问题知道该如何高效地寻找答案： 翻阅和搜索文档 搜索 issues 中是否已经有解决办法 如果没有，新建 issue 并按照要求进行操作，详尽地描述您遇到的问题 如果您没有使用过 Hexo 也不要着急，我十分建议您去通读一遍 Hexo 中文文档。 https://hexo.io/zh-cn/docs/https://hexo.io/zh-cn/docs/ 此外，如果您从旧版本更新或者其它主题迁移，请确保环境版本不要太低，否则会产生兼容性问题： 建议的版本Hexo: 6.3.0 ~ 7.0.0hexo-cli: 4.3.0 ~ latestnode: 14.17.3 ～ 20.10.0 # 建议选择 LTS 版本，过高的版本 hexo 还没有进行兼容。npm: 6.14.13 ~ 10.2.3 安装与更新稳定版最新版自定义引用源码安装方法在终端中输入：在 blog/_config.yml 文件中找到并修改：更新方法在 package.json 中修改 stellar 的版本号，然后执行：阅读 更新日志 进行迁移操作。适用范围稳定版适用于以内容创作为主，不需要自定义主题，追求稳定和可靠性的用户。安装方法把 Stellar 主题仓库添加为博客仓库的子模块在 blog/_config.yml 文件中找到并修改：更新方法打开终端并进入主题文件夹，执行：阅读 更新日志 进行迁移操作。适用范围最新版适用于以内容创作为主，不需要自定义主题，追求新特性的用户。安装方法把 Stellar 主题仓库 fork 到您的 GitHub 账号下把您 fork 的 Stellar 主题仓库添加为博客仓库的子模块在 blog/_config.yml 文件中找到并修改：更新方法在您 fork 的 Stellar 主题仓库打开终端，执行：阅读 更新日志 进行迁移操作。适用范围自定义版适用于对主题有自定义需求，且掌握了一定的前端知识和动手能力的用户。安装方法下载源码放到 themes/ 文件夹下面试用。适用范围仅适合测试，无法获得更新。 Star History本项目永久开源免费，如果您喜欢本项目，请点个赞支持一下吧～ 开源许可协议项目中的许可声明文件应包含在所有副本中 本项目是由 @xaoxuu 设计和开发，后期也合并了 开源贡献者 提交的代码，使用 MIT License 开源许可协议进行授权，拷贝、分享或基于此进行创作时请遵守协议内容： MIT LicenseCopyright (c) 2021 xaoxuuPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE."},{"title":"实用的ObjC安全对象类型转换库","path":"/wiki/valuex/index.html","content":"特性 有效避免后台返回数据类型异常导致程序崩溃 快速由已知对象得到期望的对象类型 开始使用在 Podfile 中添加：pod &#x27;ValueX&#x27; 然后执行：pod install 确保类型正确以字符串为例，通过 NSSafeString(obj) 拿到的值如果不为空，则其类型一定是 NSString，不会是 NSNumber 或者 NSNull。 测试代码- (void)test01 &#123; NSDictionary *d1 = @&#123;@&quot;name&quot;: @&quot;Mr. Xu&quot;, @&quot;info&quot;: @&quot;&#123; \\&quot;age\\&quot; : \\&quot;23\\&quot;, \\&quot;userId\\&quot; : \\&quot;123123123\\&quot;, \\&quot;deviceId\\&quot; : \\&quot;&lt;null&gt;\\&quot; &#125;&quot;&#125;; NSLog(@&quot; d1: %@&quot;, d1); NSDictionary *d11 = NSSafeDictionary([d1 dictionaryForKey:@&quot;name&quot;]); NSDictionary *d12 = NSSafeDictionary([d1 dictionaryForKey:@&quot;info&quot;]); NSLog(@&quot; d11: %@, d12: %@&quot;, d11, d12); NSDictionary *d2 = @&#123;@&quot;age&quot;: @23, @&quot;userId&quot;: @&quot;123123123&quot;, @&quot;deviceId&quot;: @&quot;&lt;null&gt;&quot;&#125;; NSLog(@&quot; d2: %@&quot;, d2); NSNumber *d21 = [d2 numberForKey:@&quot;userId&quot;]; NSString *d22 = [d2 stringForKey:@&quot;userId&quot;]; NSNumber *d23 = [d2 numberForKey:@&quot;age&quot;]; NSString *d24 = [d2 stringForKey:@&quot;age&quot;]; NSNumber *d25 = [d2 numberForKey:@&quot;deviceId&quot;]; NSString *d26 = [d2 stringForKey:@&quot;deviceId&quot;]; NSLog(@&quot; d21: %@, d22: %@, d23: %@, d24: %@, d25: %@, d26: %@&quot;, d21, d22, d23, d24, d25, d26);&#125; 安全地获取字典值字典中的值存在很多不确定性，例如 age 可能是 NSNumber，也可能是 NSNull 的实例对象。 通过 [dict numberForKey:@&quot;age&quot;] 得到的值，如果不为空，则一定是 NSNumber 的实例对象。 测试代码/** 测试: 从后台接收到字典 @param value 后台返回的字典数据 */- (void)test1:(NSDictionary *)value &#123; NSLog(@&quot;value: %@&quot;, value); // 真实类型并不一定是NSDictionary，要确保拿来用的时候一定是NSDictionary VXObject *vx = ValueX(value); NSDictionary *dict = ValueX(value).dictionaryValue; NSLog(@&quot;ValueX(value).dictionaryValue: %@&quot;, dict); // 获取其中的某个值 NSNumber *deviceId = [dict numberForKey:@&quot;deviceId&quot;]; NSString *userId = [dict stringForKey:@&quot;userId&quot;]; NSNumber *age = [dict numberForKey:@&quot;age&quot;]; NSLog(@&quot;deviceId: %@, userId: %@, age: %@&quot;, deviceId, userId, age); NSString *str = vx.stringValue; NSLog(@&quot;ValueX(value).stringValue: %@&quot;, str);&#125; 数据类型转换如果我们已知一个字典，想要得到它的Json字符串，只需要通过 ValueX(dict).stringValue 获取。 同理，只要是能互相转换的值均能通过类似的格式一行代码获取，如果不能转换，得到的值是 nil。 测试代码- (void)test2:(NSDictionary *)value &#123; NSLog(@&quot;value: %@&quot;, value); // 真实类型并不一定是NSDictionary，要确保拿来用的时候一定是NSDictionary NSDictionary *dict = ValueX(value).dictionaryValue; NSLog(@&quot;ValueX(value).dictionaryValue: %@&quot;, dict); // 获取其中的某个值 NSDictionary *info = [dict dictionaryForKey:@&quot;info&quot;]; NSLog(@&quot;info: %@&quot;, info);&#125;"},{"title":"Volantis for Hexo","path":"/wiki/volantis/index.html","content":"Volantis 是一个高度模块化的 Hexo 主题，拥有丰富的内置标签和第三方插件支持，拥有庞大的开发者团队和年轻活跃的社区文化。得益于其强大的模块化特性，您可以轻松搭建一个极简风格的轻博客，也可以仿照社区主页搭建一个多人协作的、包含 wiki 的综合型站点。 Volantis X 是 Volantis 社区文化的符号。在过去的五年里，40+ 开发者为其贡献了 2200+ commits，数以千计的用户为瓦兰提斯点亮了星星，60+ 来自各行各业的热情的小伙伴们参与了社区建设，因为大家的参与，Volantis 变得越来越强大和富有生命力。 https://volantis.js.orghttps://volantis.js.org 开始之前尽管我们致力于降低使用门槛，但是自建独立博客仍然需要一定的相关知识，markdown 常用语法是必须要掌握的，除此之外，您还需要知道 yaml 文件格式、简单的 git 知识，最最重要的是，遇到问题知道该如何高效地寻找答案： 翻阅和搜索文档 搜索 issues 中是否已经有解决办法 如果没有，新建 issue 并按照要求进行操作，详尽地描述您遇到的问题 如果您没有使用过 Hexo 也不要着急，可以先通读一遍 Hexo 中文文档，要想使用地得心应手，最好参照团队提供的开源项目的源码进行搭建： Demo 源码｜官网源码 如果您从旧版本更新或者其它主题迁移，请确保环境版本不要太低，否则会产生兼容性问题。 Hexo: 5.3.0hexo-cli: 4.2.0node.js: 14.15.4 LTS # 选 LTS 就行，过高的版本 hexo 还没有进行兼容。npm: 6.14.10 LTS 快速体验如果您已经具备环境配置条件，可以在终端中输入下面这行代码，稍等片刻就可以看到示例站点已经运行起来了： 下载与安装 如果您是 Mac 用户，可以在博客路径打开终端，下载安装并应用主题： 如果您是内容创作者，推荐使用 npm 稳定版本： 如果您需要定制主题，请 fork 主题，然后添加为子模块，详细教程如下： 如何正确地更新主题（Fork篇）https://github.com/volantis-x/hexo-theme-volantis/issues/459#issuecomment-679465906 温馨提示请一定不要直接下载源码并进行修改使用，因为这样会导致失去版本管理系统且无法获得更新。 配置与使用完整而详细的文档请移步 Volantis 社区查看： https://volantis.js.org/v4/site-settings/https://volantis.js.org/v4/site-settings/"},{"title":"[blog] 管理与发布博客的脚本","path":"/wiki/cloud-shell/blog/index.html","content":"Mac 用户可以在终端体验一下： 这条指令可以自动检测并安装必要环境和依赖，并初始化一个博客。 下载并安装脚本 如果您已经执行过上面那条命令，就已经安装过了，可以跳过此步骤。 打开终端，输入这行命令： 如需安装指定分支或版本，在后面加上分支名或版本号即可，例如： 使用方法 在忘记功能的时候可以输入 blog help 以打开此页面查看脚本所有支持的指令。 快速搭建环境如果您重装了系统或者更换了电脑，可以 copy 这条命令迅速完成环境的搭建： 新用户快速搭建博客如果您从未使用过 hexo 博客，那么可以执行这条命令完成初始化并看到效果： 已安装blog脚本未安装blog脚本 脚本会依次执行以下这些操作： 检测 node.js 环境，如果没有就安装。 检测 hexo 环境，如果没有就安装。 输入自定义博客名，在当前目录执行初始化。 安装 Stellar 主题。 安装所有依赖包。 执行 hexo s 运行博客。 打开 localhost:4000 预览博客。 注意安装 node.js 或者 hexo 的时候需要输入一次本机密码，别忘了哦。搭建博客的时候你需要输入博客名，其他时间就可以坐和放宽了。 使用脚本快速更新博客有时候如果修改了 _config.yml 是需要重新启动博客的，有些参数甚至需要 clean 之后重启才能生效，这时候你只需要输入： 就执行 hexo clean &amp;&amp; hexo server 了。 如果你已经修改完毕，需要发布更新，可以输入： 脚本就会执行 hexo clean、hexo generate、hexo deploy，然后执行一系列的 git 命令把源码的更新提交至远程仓库。 所有支持的命令 命令 功能 blog init 检查并安装环境，然后创建并运行博客 blog test 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog test stellar 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog test vlts 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog test 主题名 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） blog i node 安装 node.js blog i hexo 安装 hexo blog i stellar 安装 stellar 主题，同理换成其它主题名字都可以 blog i 主题名 安装任意主题 blog c 同 hexo clean 然后打开 localhost:4000 blog cs 同 hexo clean &amp;&amp; hexo g 然后打开 localhost:4000 blog cgd 同 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add --all &amp;&amp; git commit &amp;&amp; git push origin blog help 打开文档页面 其中，上述的「主题名」需要是发布到 npmjs.org 的主题，匹配到 hexo-theme-主题名 的部分。"},{"title":"[podspec] 快速发布 podspec 版本的脚本","path":"/wiki/cloud-shell/podspec/index.html","content":"开始使用let path &#x3D; 你的项目的 podspec 所在的路径 打开终端，cd 到 path ，输入下面这条命令下载脚本到当前文件夹： 如需安装指定版本，在后面加上版本号即可，例如： 需要发布 podspec 到时候，在终端中输入： 就会自动开始执行发布流程。 发布流程 如果目录下有一个 podspec 文件，直接询问版本号，然后打包验证、询问是否发布。 如果目录下有多个 podspec 文件，遍历每一个 podspec 文件，询问版本号，然后打包验证、询问是否发布。 脚本运行权限如果提示没有权限，就输入以下命令修改 podspec.sh 的权限"},{"title":"[tag] 快速发布 git 版本的脚本","path":"/wiki/cloud-shell/tag/index.html","content":"安装脚本打开终端，输入并执行这一行命令即可： 发布版本当您需要进行版本发布时，在 git 仓库中打开终端，输入： tag 版本号 描述 然后稍等片刻即可完成发布。 删除版本tag del 版本号"},{"title":"[vimcn] 快速批量上传图片的脚本","path":"/wiki/cloud-shell/vimcn/index.html","content":"直接使用打开终端，cd 到存放图片的文件夹，输入这行命令就开始上传图片： 为了简化指令，建议下载安装后使用。 安装脚本打开终端，输入这行命令： 如需安装指定版本，在后面加上版本号即可，例如： 然后就会开始下载脚本并安装到 usr/local/bin 路径，可能需要输入电脑密码以授权。 上传文件需要上传图片到时候，打开终端，cd 到存放图片的文件夹，输入 upload 就可以了。当然，还可以传递参数： upload [扩展名] [操作] 扩展名 含义 all 或者不传任何参数 上传所有格式的文件 png、jpg、ico 等具体的某个扩展名 上传指定格式的文件 操作 含义 open 上传成功后打开链接 常见的用法示例上传当前文件夹中的所有文件upload上传当前文件夹中的所有文件，并打开链接upload all open上传当前文件夹中的所有png格式的图片upload png 支持的文件格式经测试，可以上传的格式有：png、jpg、ico、gif、svg、tiff、webp、pdf、mp3、mp4、zip等。 支持的文件大小大概在 50MB 以内。 请勿滥用注意为了大家都能愉快使用，请不要上传一些奇奇怪怪的图片。"},{"title":"搭建 Git 服务器","path":"/wiki/git/git-server/index.html","content":"横向对比表格中的符号含义: ✓ - 支持 ⁄ - 部分支持 ✘ - 不支持 ? - 不确定 主要特性代码管理IssuesPull/PR第三方集成 特性 Gitea Gogs GitHub EE GitLab CE GitLab EE BitBucket RhodeCode CE 开源免费 ✓ ✓ ✘ ✓ ✘ ✘ ✓ 低资源开销 (RAM&#x2F;CPU) ✓ ✓ ✘ ✘ ✘ ✘ ✘ 支持多种数据库 ✓ ✓ ✘ ⁄ ⁄ ✓ ✓ 支持多种操作系统 ✓ ✓ ✘ ✘ ✘ ✘ ✓ 升级简便 ✓ ✓ ✘ ✓ ✓ ✘ ✓ 支持 Markdown ✓ ✓ ✓ ✓ ✓ ✓ ✓ 支持 Orgmode ✓ ✘ ✓ ✘ ✘ ✘ ? 支持 CSV ✓ ✘ ✓ ✘ ✘ ✓ ? 支持第三方渲染工具 ✓ ✘ ✘ ✘ ✘ ✓ ? Git 驱动的静态 pages ✘ ✘ ✓ ✓ ✓ ✘ ✘ Git 驱动的集成化 wiki ✓ ✓ ✓ ✓ ✓ ✓ (cloud only) ✘ 部署令牌 ✓ ✓ ✓ ✓ ✓ ✓ ✓ 仓库写权限令牌 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 内置容器 Registry ✓ ✘ ✓ ✓ ✓ ✘ ✘ 外部 Git 镜像 ✓ ✓ ✘ ✘ ✓ ✓ ✓ WebAuthn (2FA) ✓ ✘ ✓ ✓ ✓ ✓ ? 内置 CI&#x2F;CD ✘ ✘ ✓ ✓ ✓ ✘ ✘ 子组织：组织内的组织 ✘ ✘ ✘ ✓ ✓ ✘ ✓ 特性 Gitea Gogs GitHub EE GitLab CE GitLab EE BitBucket RhodeCode CE 仓库主题描述 ✓ ✘ ✓ ✓ ✓ ✘ ✘ 仓库内代码搜索 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 全局代码搜索 ✓ ✘ ✓ ✘ ✓ ✓ ✓ Git LFS 2.0 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 组织里程碑 ✘ ✘ ✘ ✓ ✓ ✘ ✘ 细粒度用户角色 (例如 Code, Issues, Wiki) ✓ ✘ ✘ ✓ ✓ ✘ ✘ 提交人的身份验证 ⁄ ✘ ? ✓ ✓ ✓ ✘ GPG 签名的提交 ✓ ✘ ✓ ✓ ✓ ✓ ✓ SSH 签名的提交 ✓ ✘ ✘ ✘ ✘ ? ? 拒绝未用通过验证的提交 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 仓库活跃度页面 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 分支管理 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 建立新分支 ✓ ✘ ✓ ✓ ✓ ✘ ✘ 在线代码编辑 ✓ ✓ ✓ ✓ ✓ ✓ ✓ 提交的统计图表 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 模板仓库 ✓ ✘ ✓ ✘ ✓ ✓ ✘ 特性 Gitea Gogs GitHub EE GitLab CE GitLab EE BitBucket RhodeCode CE 工单跟踪 ✓ ✓ ✓ ✓ ✓ ✓ (cloud only) ✘ 工单模板 ✓ ✓ ✓ ✓ ✓ ✘ ✘ 标签 ✓ ✓ ✓ ✓ ✓ ✘ ✘ 时间跟踪 ✓ ✘ ✓ ✓ ✓ ✘ ✘ 支持多个负责人 ✓ ✘ ✓ ✘ ✓ ✘ ✘ 关联的工单 ✘ ✘ ⁄ ✓ ✓ ✘ ✘ 私密工单 ✘ ✘ ✘ ✓ ✓ ✘ ✘ 评论反馈 ✓ ✘ ✓ ✓ ✓ ✘ ✘ 锁定讨论 ✓ ✘ ✓ ✓ ✓ ✘ ✘ 工单批处理 ✓ ✘ ✓ ✓ ✓ ✘ ✘ 工单看板 ✓ ✘ ✘ ✓ ✓ ✘ ✘ 从工单创建分支 ✘ ✘ ✘ ✓ ✓ ✘ ✘ 工单搜索 ✓ ✘ ✓ ✓ ✓ ✓ ✘ 工单全局搜索 ✘ ✘ ✓ ✓ ✓ ✓ ✘ 工单依赖关系 ✓ ✘ ✘ ✘ ✘ ✘ ✘ 通过 Email 创建工单 ✘ ✘ ✘ ✘ ✓ ✓ ✘ 服务台 ✘ ✘ ✘ ✓ ✓ ✘ ✘ 特性 Gitea Gogs GitHub EE GitLab CE GitLab EE BitBucket RhodeCode CE Pull&#x2F;Merge requests ✓ ✓ ✓ ✓ ✓ ✓ ✓ Squash merging ✓ ✘ ✓ ✓ ✓ ✓ ✓ Rebase merging ✓ ✓ ✓ ✘ ⁄ ✘ ✓ 评论 Pull&#x2F;Merge request 中的某行代码 ✓ ✘ ✓ ✓ ✓ ✓ ✓ 指定 Pull&#x2F;Merge request 的审核人 ✓ ✘ ⁄ ✓ ✓ ✓ ✓ 解决 Merge 冲突 ✘ ✘ ✓ ✓ ✓ ✓ ✘ 限制某些用户的 push 和 merge 权限 ✓ ✘ ✓ ⁄ ✓ ✓ ✓ 回退某些 commits 或 merge request ✓ ✘ ✓ ✓ ✓ ✓ ✘ Pull&#x2F;Merge requests 模板 ✓ ✓ ✓ ✓ ✓ ✘ ✘ 查看 Cherry-picking 的更改 ✓ ✘ ✘ ✓ ✓ ✘ ✘ 下载 Patch ✓ ✘ ✓ ✓ ✓ &#x2F; ✘ 特性 Gitea Gogs GitHub EE GitLab CE GitLab EE BitBucket RhodeCode CE 支持 Webhook ✓ ✓ ✓ ✓ ✓ ✓ ✓ 自定义 Git 钩子 ✓ ✓ ✓ ✓ ✓ ✓ ✓ 集成 AD &#x2F; LDAP ✓ ✓ ✓ ✓ ✓ ✓ ✓ 支持多个 LDAP &#x2F; AD 服务 ✓ ✓ ✘ ✘ ✓ ✓ ✓ LDAP 用户同步 ✓ ✘ ✓ ✓ ✓ ✓ ✓ SAML 2.0 service provider ✘ ✘ ✓ ✓ ✓ ✓ ✘ 支持 OpenId 连接 ✓ ✘ ✓ ✓ ✓ ? ✘ 集成 OAuth 2.0（外部授权） ✓ ✘ ⁄ ✓ ✓ ? ✓ 作为 OAuth 2.0 provider ✓ ✘ ✓ ✓ ✓ ✓ ✘ 二次验证 (2FA) ✓ ✓ ✓ ✓ ✓ ✓ ✘ 集成 Mattermost&#x2F;Slack ✓ ✓ ⁄ ✓ ✓ ⁄ ✓ 集成 Discord ✓ ✓ ✓ ✓ ✓ ✘ ✘ 集成 Microsoft Teams ✓ ✘ ✓ ✓ ✓ ✓ ✘ 显示外部 CI&#x2F;CD 的状态 ✓ ✘ ✓ ✓ ✓ ✓ ✓ Gitea👍&nbsp;推荐Gitea 是一个开源社区驱动的轻量级代码托管解决方案，后端采用 Go 编写，采用 MIT 许可证。我现在使用的就是它。相较于 gitlab 更轻量级，内存占用更小，适合个人或小型团队使用。 使用 Docker 安装使用包管理器安装https://docs.gitea.io/zh-cn/install-with-docker/https://docs.gitea.io/zh-cn/install-with-docker/ docker-compose.ymlversion: &quot;3&quot;networks: gitea: external: falseservices: server: image: gitea/gitea:1.17.3 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 restart: always networks: - gitea volumes: - ./gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - &quot;3000:3000&quot; - &quot;222:22&quot; 在宝塔上使用 Docker 安装在宝塔面板进入 Docker 设置页面，如图所示获取 Gitea 镜像，填最新版：gitea/gitea:latest创建基于 Gitea 镜像的 Docker 容器，如图：已经安装完成了，现在需要新建站点、解析域名、设置反向代理：打开域名，进入初始化配置，配置完成即可使用。原文地址：https://www.bangzhujiaocheng.com/337.htmlhttps://docs.gitea.io/zh-cn/install-from-package/https://docs.gitea.io/zh-cn/install-from-package/ 以 macOS 为例，输入这两行代码就可以完成本地安装： brew tap gitea/tap https://gitea.com/gitea/homebrew-giteabrew install gitea Gitblit🚫&nbsp;不推荐这是我曾在公司内网搭建供团队使用的工具，相较于前面提到的几款而言不是很推荐使用这个了。 安装 JDK下载并安装 JDK：javase-downloads安装并配置 Gitblit下载 Gitblit：gitblit解压 Gitblit，进入目录 ~/gitblit-1.8.0/data/defaults.properties用编辑器打开 defaults.propertiesgit.repositoriesFolder = /Users/用户名/gitserver/gitRepositoryserver.httpPort = 7070启动服务在终端中执行 gitblit.sh 脚本即可启动服务：./gitblit.sh建议设置开机自启动通过 Mac 的自动化工具，将启动指令写成脚本，系统启动后自动运行脚本即可。Windows 平台可以添加到启动计划任务中。客户端访问用服务器 IP + 端口号来访问。例如我的电脑的 IP 是 10.8.12.200，那么在局域网内另外一台电脑访问 http://10.8.12.200:7070 就可以看到管理页面了：网页操作和使用 GitHub、Coding 等平台相似，非常简单。"},{"title":"安装与配置","path":"/wiki/git/install-and-config/index.html","content":"安装LinuxWindowsMac下载地址https://git-scm.com/download/linux 安装指定系统的依赖包： Centos/RedHat$ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel Debian/Ubuntu$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev 解压安装下载的源码包： $ tar -zxf git-1.7.2.2.tar.gz$ cd git-1.7.2.2$ make prefix=/usr/local all$ sudo make prefix=/usr/local install 使用终端指令安装Debian&#x2F;Ubuntu$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2CentOS&#x2F;RedHat$ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel$ yum -y install git-core$ git --versiongit version 1.7.1下载地址https://gitforwindows.org/ 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 在开始菜单里找到 Git -&gt; Git Bash，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。下载地址https://git-scm.com/download/mac Mac 自带 git 并且随着系统版本的更新，自带的 git 也会升级到最新，一般无需手动安装。 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 用户信息git config --global user.name xaoxuugit config --global user.email git@xaoxuu.com 如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 查看配置信息git config --listhttp.postbuffer=2Muser.name=xaoxuuuser.email=git@xaoxuu.com git-sshssh-keygen -t rsa -C user@example.com 其中 user@example.com 对应的是你的 Git 邮箱。 ssh-agent 是一种控制用来保存公钥身份验证所使用的私钥的程序，其实 ssh-agent 就是一个密钥管理器，运行 ssh-agent 以后，使用 ssh-add 将私钥交给 ssh-agent 保管，其他程序需要身份验证的时候可以将验证申请交给 ssh-agent 来完成整个认证过程。 eval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent： ssh-add ~/.ssh/id_rsa 登陆 Github，添加 ssh： 把 id_rsa.pub 文件里的内容复制到这里："},{"title":"基本操作入门","path":"/wiki/git/usage/index.html","content":"基本操作流程 在对代码进行了一些修改之后，使用：git add --all 将本地所有新增文件和修改内容添加到暂存区。 使用：git commit -m 备注 将代码提交到本地版本库。（备注内容没有空格的话不需要加引号） 使用：git pull origin 从服务器拉取代码，更新本地版本库。 使用：git push origin 将本地版本库推送到服务器。 克隆与配置克隆版本库git clone https://github.com/xaoxuu/AXKit.git# 或者git clone https://github.com/xaoxuu/AXKit.git AXKit 配置版本库要忽略某些文件的改动需要配置 .gitignore 文件： # 这是macOS文件夹属性的隐藏文件，不需要同步到git.DS_Store# 某个文件夹不想要同步到git/public/node_modules# 某个文件不想要同步到gittest.txt# 通配符._* 基本操作指令创建与切换分支创建并切换 branchgit checkout -b 分支名 仅仅切换 branchgit checkout 分支名 创建 taggit tag 标签名 创建 tag 并备注git tag -a 标签名 -m 备注信息 创建 PGP tag 并备注git tag -s 标签名 -m 备注信息 查看分支和标签查看本地 taggit tag 查看某个本地 tag 详情git show 标签名 查看本地 branch listgit branch 分支名 查看远程 branch listgit branch -r 分支名 查看所有 branch listgit branch -a 分支名 删除分支和标签删除本地 branch / taggit branch -d 分支名或标签名 删除所有未推送的本地 branchgit fetch -p 仅仅删除某个远程 branch / taggit push origin :分支名或标签名# 或者git push origin --delete 分支名或标签名 推送分支和标签推送某个 branch / taggit push origin 分支名或标签名 推送所有 branchgit push --all origin 推送所有 taggit push --tags 重命名分支重命名本地分支： git branch -m 旧分支名 新分支名 重命名远程分支： 删除远程分支 重命名本地分支 推送本地分支 拉取、合并分支拉取某个远程标签git fetch origin tag 远程标签名 合并某本地分支到当前分支git merge 分支名 合并某远程分支到当前分支git pull origin 远程分支名 merge 和 rebase简单的说：用 rebase 方式合并的分支会合并成一条直线，而 merge 方式合并会记录合并操作。 合并前： 使用 merge 进行合并： 使用 rebase 进行合并： 代码冲突我一般使用 Tower 客户端操作，pull 之后有冲突的文件会列出来。建议使用一个比较好的编辑器如 Atom，有冲突的部分会用两种颜色高亮。 未完待续 代码回退如果冲突文件没有妥善解决就提交到版本库导致严重后果，这是需要查看某个历史时刻的代码，使用： git log# 查看提交记录 然后 copy 某个 commit id 进行回退，回退的类型有两种： soft这是默认的回退方式，版本库的 HEAD 回滚到某个 commit 但本地代码不变，处于未 commit 的状态。 git reset [commit id]# 或者git reset --soft [commit id] hardHEAD 和本地代码都回到某个 commit，后面的更改将会被丢弃。（如同时光穿梭） git reset --hard [commit id] 版本迭代查看本地所有标签 git tag 把当前 HEAD 打个标签（名为：1.0） git tag 1.0# 也可以添加备注信息，如同commitgit tag 1.0 -m &#x27;message&#x27; 切换到某个标签（1.0） git checkout 1.0 把标签 push 到远程 push指定的taggit push origin 1.0 push所有未push的taggit push --tags 删除标签（1.0） # 删除本地taggit tag -d 1.0# 删除远程tag# 方法一：将空白tag覆盖到远程taggit push origin :1.0# 方法二：执行删除命令git push origin --delete 1.0 客户端操作Stash save：将当前未 commit 的代码保存到 stash，并且回到上次 commit 的状态。 apply：应用某个 stash 的代码。 Git-Flow自动化管理功能，例如： 准备开发新版本的时候：点击 Start Release，客户端会自动新建一个 release 分支。 准备增加一个新特性的时候：点击 Start Feature，客户端会新建一个 feature 分支。 需要修复 bug 的时候：点击 Start Hotfix，客户端会新建一个 fix 分支。 当修复完 bug，点击 Finish Hotfix 的时候，客户端会自动把 fix 分支合并到创建它的分支，并且创建一个 tag。 当一个新特性开发完成，点击 Finish Feature 的时候，客户端会自动把 feature 分支合并到创建它的分支，并且创建一个 tag。 当一个新版本开发完成，点击 Finish Release 的时候，客户端会自动把 release 分支合并到创建它的分支，并且创建一个 tag。"},{"title":"探索个性化配置","path":"/wiki/stellar/advanced-settings/index.html","content":"主题色支持 HEX &amp; HSL 表示颜色 blog/_config.stellar.ymlstyle: ... color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: &#x27;hsl(212 16% 98%)&#x27; # 浅色背景颜色 block: &#x27;hsl(212 8% 95%)&#x27; # 块背景颜色 code: &#x27;hsl(14 100% 48%)&#x27; # 行内代码颜色 text: &#x27;hsl(0 0% 20%)&#x27; # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: &#x27;hsl(192 98% 55%)&#x27; # 主题色 accent: &#x27;hsl(14 100% 57%)&#x27; # 强调色 link: &#x27;hsl(207 90% 54%)&#x27; # 超链接颜色 button: &#x27;hsl(192 98% 55%)&#x27; # 按钮颜色 hover: &#x27;hsl(14 100% 57%)&#x27; # 按钮高亮颜色 字体系统字体blog/_config.stellar.ymlstyle: font-size: root: 16px body: .9375rem # 15px code: 85% # 14px codeblock: 0.8125rem # 13px font-family: logo: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; body: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; code: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; codeblock: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; 外部字体要想引用外部字体，你需要先在 _config.yml 中 inject 引入 举例，引用 Noto Serif SC 在 _config.yml 中写入 blog/_config.ymlinject: head: - &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Noto+Serif+SC&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt; script: 并在 _config.stellar.yml 中填写你引入的字体名称 blog/_config.stellar.ymlstyle: font-family: body: &#x27;&quot;Noto Serif SC&quot;, &quot;Microsoft Yahei&quot;,..., sans-serif&#x27; 选择在线字体： https://www.googlefonts.cn/https://www.googlefonts.cn/ 本地字体若您想引用本地字体，举例，引用得意黑（SmileySans-Oblique.ttf）这个字体，先将字体放置于 blog/source/font/ 目录下，然后改动一下主题文件 Blog/themes/stellar/source/css/_custom.styl@font-face font-family: &#x27;Smiley Sans&#x27; src: url(&#x27;/font/SmileySans-Oblique.ttf&#x27;) font-weight: normal font-style: normal font-family 是你引入的字体家族名，src 中填写字体文件相对于 source 文件夹的路径 同样，你需要在 _config.stellar.yml 中填写你引入的字体名称（font-family） blog/_config.stellar.ymlstyle: font-family: body: &#x27;&quot;Smiley Sans&quot;, &quot;Microsoft Yahei&quot;,..., sans-serif&#x27; 但是我个人并不推荐引用本地字体，相比于英文字体，中文字体囊括了众多的字符，这也无法避免地导致字体文件体积的增加，拿 Noto Serif SC 来说，单个ttf文件就有9mb之大，这对于您的站点而言加载速度可想而知。 文本对齐方向blog/_config.stellar.ymlstyle: ... text-align: left # justify/left/center/right 代码块复制blog/_config.stellar.ymlcopycode: enable: true js: /js/plugins/copycode.js default_text: &#x27;Copy&#x27; # 按钮显示文字 success_text: &#x27;Copied&#x27; # 复制成功信息 链接下划线blog/_config.stellar.ymllink: underline: true # true / false 圆角大小这个功能在 1.18.1 版本后开始支持。 blog/_config.stellar.ymlstyle: ... border-radius: card: 12px # 卡片圆角 block: 12px # 块圆角 bar: 6px # 导航栏圆角 image: 6px # 图片圆角 页面缓入效果blog/_config.stellar.yml# 默认关闭scrollreveal: enable: false js: https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 4px # 执行距离 duration: 400 # ms # 执行时长 interval: 100 # ms # 执行间隔（时间） scale: 0.1 # 0.1~1 # 执行方式（缩放） 此效果会和图片懒加载插件冲突，导致部分卡片和footer可能加载不出来 图片懒加载blog/_config.stellar.yml# 默认打开lazyload: enable: true # [hexo clean &amp;&amp; hexo s] is required after changing this value. js: https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js transition: blur # blur, fade 加载提示加载动态时间线、动态友链等显示提示 blog/_config.stellar.yml# 默认打开loading: loading: 正在加载 error: 加载失败，请稍后重试。 渐变色这个功能在 1.18.2 版本后开始支持。 您可以在搜索框与 wiki 项目的封面开始按钮处设置渐变色 CSS 代码 blog/_config.stellar.ymlstyle: ... gradient: # https://webgradients.com/ start: &#x27;linear-gradient(to right, #92fe9d 0%, #00c9ff 50%, #92fe9d 100%)&#x27; search: &#x27;linear-gradient(to right, #04F3FF, #08FFC6, #DDF730, #FFBD19, #FF1FE0, #C418FF, #04F3FF)&#x27; 当然，如果只想设置纯色的话可以直接设置单色，支持 HEX 和 HSL，例如 search: &#39;hsl(212 16% 98%)&#39; 顶部检索栏这个功能在 1.13.0 版本后开始支持。 blog/_config.stellar.yml######## Index ########post-index: # 近期发布 分类 标签 归档 and ... &#x27;朋友文章&#x27;: /friends/rss/ # 这里填写的链接要与对应页面一致，否则可能无法正确高亮 站点地图页面底部的站点导航，你也可以在 content 中自定义一些文字信息，支持 Markdown 格式。 sitemap: &#x27;博客&#x27;: - &#x27;[近期](/)&#x27; - &#x27;[分类](/categories/)&#x27; - &#x27;[标签](/tags/)&#x27; - &#x27;[归档](/archives/)&#x27; &#x27;项目&#x27;:# - &#x27;[开源库](/)&#x27; &#x27;社交&#x27;:# - &#x27;[友链](/)&#x27;# - &#x27;[留言板](/)&#x27; &#x27;更多&#x27;:# - &#x27;[关于本站](/)&#x27;# - &#x27;[GitHub](/)&#x27;content: | # 支持 Markdown 格式 本站由 [@anonymity](/) 使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。# 主题用户越多，开发者维护和更新的积极性就越高，如果您喜欢本主题，请在适当的位置显示主题信息和仓库链接以表支持。 自定义样式如果要修改样式，您需要删掉主题的样式文件的 CDN 链接，使用本地文件，然后在 themes/stellar/source/css/_custom.styl 中进行修改。 使用其它 highlight.js 代码高亮主题Hexo 官方有文档：https://hexo.io/docs/syntax-highlight.html#hljs Tip: When line_number is set to false, wrap is set to false and hljs is set to true, you can then use highlight.js theme directly in your site. 以 atom-one-dark 主题为例，翻译过来就是 _config.yml 找到 highlight 并修改为： highlight: enable: true line_number: false auto_detect: false tab_replace: &#x27; &#x27; wrap: false hljs: true 然后再找到 inject 新增一个 css 链接： inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.5.0/build/styles/atom-one-dark.min.css&quot;&gt; 外部文件注入在站点根目录下的配置文件中进行修改 inject.head 以在 &lt;head&gt; 标签末尾处注入代码，修改 inject.script 以在 &lt;body&gt; 标签末尾处注入代码。 blog/_config.ymlinject: head: - &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#2d89ef&quot;&gt; - &lt;meta name=&quot;msapplication-config&quot; content=&quot;/assets/favicon/browserconfig.xml&quot;&gt; - &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; script: - https://gcore.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"},{"title":"探索号专题教程分享","path":"/wiki/stellar/articles/index.html","content":"小提示如果您也有与 Stellar 相关的文章并希望显示在这里，可以直接在 hexo-theme-stellar 中选择【文章分享】模板按照格式提交即可，立即生效。"},{"title":"评论插件配置（6个）","path":"/wiki/stellar/comments/index.html","content":"BeaudarBeaudar 是 Utterances 的中文版本，相比 Utterances 有更多的体验优化，可以按时间倒序排序。 blog/_config.stellar.ymlcomments: service: beaudar beaudar: repo: xaoxuu/blog-comments Beaudar 的配置方法很简单，创建一个仓库，在仓库中创建一个 域名白名单文件，然后在 此处 授权安装即可。 utterancesA lightweight comments widget built on GitHub issues. Use GitHub issues for blog comments, wiki pages and more! blog/_config.stellar.ymlcomments: service: utterances utterances: repo: xaoxuu/blog-comments utterances 的配置方法很简单，创建一个仓库，在仓库中创建一个 域名白名单文件，然后在 此处 授权安装即可。 giscusgiscus 是由 GitHub Discussions 驱动的评论系统。让访客借助 GitHub 在你的网站上留下评论和反应吧！本项目受 utterances 强烈启发。 blog/_config.stellar.ymlcomments: service: giscus # giscus # https://giscus.app/zh-CN giscus: data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymous Twikooblog/_config.stellar.ymlcomments: service: twikoo twikoo: envId: https://xxx # vercel函数 https://twikoo.js.orghttps://twikoo.js.org Walineblog/_config.stellar.ymlcomments: service: waline waline: js: https://unpkg.com/@waline/client@v2/dist/waline.js css: https://unpkg.com/@waline/client@v2/dist/waline.css # Waline server address url, you should set this to your own link serverURL: https://xxx # waline 地址 # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom locales locale: placeholder: # 输入框内提示文字 # Custom emoji emoji: - https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji https://waline.js.orghttps://waline.js.org Artalkblog/_config.stellar.ymlcomments: service: artalk # Artalk # https://artalk.js.org/ artalk: css: https://unpkg.com/artalk@2.4.3/dist/Artalk.css js: https://unpkg.com/artalk@2.4.3/dist/Artalk.js server: # 后端服务地址 placeholder: &#x27;&#x27; darkMode: auto https://artalk.js.orghttps://artalk.js.org 评论的灵活用法共用评论数据如果您有多个页面需要共用评论数据，可以在 front-matter 中覆盖评论参数，例如： blog/source/about/index.mdtitle: 关于beaudar: &#x27;issue-term&#x27;: &#x27;留言板&#x27; blog/source/friends/index.mdtitle: 友链beaudar: &#x27;issue-term&#x27;: &#x27;留言板&#x27; 使用其它评论数据如果您有多个页面需要另外一个数据库的评论数据，以 Beaudar 为例，您可以这样： blog/source/wiki/stellar/index.mdtitle: 快速开始您的博客之旅giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226"},{"title":"开发者和社区支持","path":"/wiki/stellar/contributors/index.html","content":"开发者点赞支持者1-100 101-200 201-300 301-400 401-500 501-600 如何加入社区 社区建设主要包括以下几个方面： Issues 技术问题答疑、BUG反馈 Discussions 论坛、相关话题讨论 文档 维护 探索号 文章收录 QQ群：1146399464，验证码：vlts-2021（以聊天为主，技术问题未必跟进。） 无论在什么渠道，学习并掌握 提问的智慧(28k Stars) 可以方便大家更高效地帮你解决问题。 错误的提问XXX 功能怎么用？（文档有详细描述）这个功能怎么用不了啊（不说明自己操作了什么，也不展示实际效果）我怎么跑不起来，能帮我看看吗？（什么也不尝试，直接丢项目代码）怎么报错了呢？（不贴或只贴极少部分的出错提示）这个代码怎么改（扔过来一大段代码）XXX 什么意思？（没有经过任何搜索）正确的提问我这里遇到了一个问题：【问题描述】，我经过了以下尝试：【思路细节】，不能得到解决，报错如下：【报错截图&#x2F;线上预览地址&#x2F;仓库源代码地址】，请问该怎么解决？我不太理解【某处】里的【某处】，我的理解是这样的：【思路细节】，对吗？我查看了文档的【某处】，并尝试【做法】，但是没有得到【预想效果】，正确的做法应该是什么？"},{"title":"使用 Stellar 主题的博客","path":"/wiki/stellar/examples/index.html","content":"小提示如果您也使用了 Stellar 并希望显示在这里，可以在 hexo-theme-stellar-examples 中提交 issue 告知您的站点信息，在您提交后的大约 3 分钟内生效。"},{"title":"编写文章以及独立页面","path":"/wiki/stellar/pages/index.html","content":"文章封面在文章列表页面或者其他位置显示的文章摘要卡片上面的图片称之为「文章封面」 自动生成封面根据 tags 作为关键词为每一篇文章在线搜索封面： blog/_config.stellar.ymlarticle: auto_cover: true 引用外部图片在文章的 front-matter 中写上 cover: xxx 即可。例如： blog/source/_posts/xxx.md---# 本地图片路径为 blog/source/assets/xaoxuu/blog/2020-0927a@1x.svg# 也可以直接引用图片直链 https://xxx.jpgcover: /assets/xaoxuu/blog/2020-0927a@1x.svg--- 显示效果 上面这种方式会显示title与description或者摘要，若你想要图片全显示，可以加入如下参数： blog/source/_posts/xxx.md---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red...--- Stellar v1.14.0 更换 cover-title cover-cat cover-subtitle cover-text-color 为 poster 为了显示美观，建议 topic 和 caption 选择其一与 headline 搭配使用。 显示效果填写 topic 与 headline 时大标题位于上方只填写 headline 或填写 headline 与 caption 时大标题位于下方 如果您想使用 Unsplash 搜索图片作为封面，可以在 cover 设置搜索关键词（用英文逗号隔开）： blog/source/_posts/xxx.md---cover: workout,strava--- 内容摘要自动生成摘要建议您通过 description 或者 excerpt 方式生成摘要，但如果您希望自动从文章内容截取一定字数的文字作为摘要，可以这样设置： blog/_config.stellar.ymlarticle: auto_excerpt: 200 手动设置摘要一篇文章开头一段文字描述就是摘要，摘要和正文用 &lt;!-- more --&gt; 隔开，前后一定要有空行。例如： blog/source/_posts/xxx.md---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg---在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。&lt;!-- more --&gt;后面是正文部分，在主页看不到。 AI摘要感谢 @张洪Heo @Tianli 提供的项目 Post-Abstract-AI _config.stellar.yml# AI 摘要tianli_gpt: enable: true field: post # all, post, wiki api: 5Q5mpqRK5DkwT1X9Gi5e # 填写你的tianliGPT_key typingAnimate: false # 打字机动画 如何获取 tianliGPT_key：到 爱发电 中购买，购买完成后，进入 网页后台管理 绑定key并添加自己的站点 key与博客地址为绑定状态，所以本地调试时是无法接收到数据的。 文章模板使用 Hexo 自带模板实现命令行创建新文章时自动生成相关信息。 根目录下 scaffolds 文件夹中编辑 post.md 的 font-matter： blog/scaffolds/post.md---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: []categories: []description: cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选--- 文章页横幅图片文章页面顶部区域可以显示长长的横幅图片，设置方法如下： blog/source/_posts/xxx.mdbanner: /assets/xaoxuu/blog/2020-0927a@1x.svg 如果您想使用 Unsplash 搜索图片作为横幅，可以在 banner 中设置搜索关键词（用英文逗号隔开）： blog/source/_posts/xxx.md---banner: workout,strava--- 指定一级标题默认的一级标题是文章的 title，如果希望使用别的文字作为一级标题，可以指定 h1，例如： blog/source/_posts/xxx.md---h1: 快速开始--- 文章索引与推荐文章如果有分类和标签就会自动在主页出现「分类」、「标签」选项卡实现分类浏览，不需要手动添加页面。 文章分类在文章列表页面会显示文章所属的第一级分类，例如： blog/source/_posts/xxx.md---categories: [设计开发, iOS开发]--- 这样写就只会显示「设计开发」一级分类，而在文章页面顶部则会显示完整的面包屑导航。 文章标签文章标签目前不可见，用于关键词、搜索、按标签检索、相关文章推荐等功能，例如： blog/source/_posts/xxx.md---tags: [iOS, 心率]--- 相关文章推荐要实现相关文章推荐功能，您需要安装插件： 然后在主题配置文件中开启： blog/_config.stellar.ymlarticle: # npm i hexo-related-popular-posts related_posts: enable: true title: 您可能感兴趣的文章 开启后会在每篇文章的下方推荐相同类型的文章。 参考资料用 markdown 格式填写引用的文章，注意要写在引号中： blog/source/_posts/xxx.md---references: - &#x27;[心跳之旅—💗—iOS用手机摄像头检测心率(PPG)](https://punmy.cn/2016/07/28/15231176397746.html)&#x27; - &#x27;[PPG光电容积脉搏波描记法技术概况](https://www.jianshu.com/p/695c131abfa5)&#x27; ...--- 效果见这篇文章： https://xaoxuu.com/blog/20200927/#referenceshttps://xaoxuu.com/blog/20200927/#references 覆盖 OpenGraph如果分享到社交平台的缩略图不理想，可以通过这个特性覆盖为自己想要的： blog/source/_posts/xxx.mdopen_graph: image: /assets/xaoxuu/blog/2022-1029a@2x.webp 更多的独立页面Stellar 同时具有博客和 Wiki 两个大模块，为了能够正确进行导航栏高亮，引入了 menu_id 来进行区分，通常情况下，layout: post 和 layout: wiki 两种布局模板可以自动为 sidebar.menu.post 和 sidebar.menu.wiki 的导航栏按钮高亮。自己创建的独立页面也可以在 front-matter 中指定 menu_id 来使某个按钮处于选中状态。 例如您有关于、友链两个页面，都希望高亮「更多」按钮： blog/source/about/index.md---menu_id: moretitle: 关于--- blog/source/friends/index.md---menu_id: moretitle: 友链--- 在主题配置文件中设置导航栏： blog/_config.stellar.ymlsidebar: menu: ... more: &#x27;[更多](/more/)&#x27; 友链页面友链被设计成标签，您可以在任何页面任何位置插入友链，详见： #友链标签https://xaoxuu.com/wiki/stellar/tag-plugins/#友链标签 关于页面没有单独的关于页面布局，您可以自由组合丰富的标签来实现个性化的关于页面，例如：about、tabs、navbar、quot、timeline 标签。"},{"title":"更新日志与注意事项","path":"/wiki/stellar/releases/index.html","content":"版本命名规范：大版本 小版本 修复版本 大版本：较大范围改动和设计调整、重构 小版本：较小范围改动、增加删除功能，也可能包含部分修复 修复版本：仅包含修复或代码优化，可放心无缝升级 如何关注主题更新例如，您可以在自己博客任意位置用时间线标签显示主题最近一个版本更新内容：&#123;% timeline api:https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/releases?per_page=1 %&#125;&#123;% endtimeline %&#125;"},{"title":"侧边栏配置","path":"/wiki/stellar/sidebar/index.html","content":"Logo左上角的 logo 和标题取自站点根目录的配置文件： blog/_config.ymltitle: 网站名称avatar: 头像 设置鼠标指上 subtitle 后翻转另一行字（您可以将鼠标移至左上角的Stellar查看效果） blog/_config.ymlsubtitle: 标题1 | 标题2 如果您想用一个图片作为 logo，可以直接在主题配置文件 sidebar.logo.title 中设置： blog/_config.stellar.ymlsidebar: logo: title: &#x27;[&lt;img no-lazy height=&quot;32px&quot; src=&quot;xxx&quot;/&gt;](/)&#x27; Navbar（主导航栏）blog/_config.stellar.ymlsidebar: menu: post: &#x27;[btn.blog](/)&#x27; wiki: &#x27;[btn.wiki](/wiki/)&#x27; notes: &#x27;[笔记](/notes/)&#x27; more: &#x27;[更多](/more/)&#x27; 侧边栏宽度有限，如何在不影响观感的情况下设置更多的主导航栏按钮呢？建议设置一个「更多」按钮，然后在「更多」页面的侧边栏放上列表组件。 Search（搜索）local_searchothers在 1.17.1 版本后开始支持，无需安装插件，默认开启。 blog/_config.stellar.yml# 文章搜索search: service: local_search # local_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块（需要content: true)请提交PR… 在 _config.stellar.yml 中设置搜索选项并配置你想在侧边栏中显示的位置。 然后在 widgets.yml 文件中配置侧边栏搜索组件 blog/source/_data/widgets.ymlsearch: layout: search filter: auto # auto or &#x27;/path&#x27; placeholder: 文章搜索 # 搜索框处显示的文字search_blog: layout: search filter: /blog/ # or /posts/ ... placeholder: 文章搜索search_docs: layout: search filter: /wiki/ placeholder: 文档搜索 您可以设置 filter 按地址过滤搜索结果，默认 auto 是智能选择，规则如下： layout: wiki：只在 /wiki/当前项目 中搜索 其它：站内搜索 你可以在某些页面中通过覆盖 search 组件的 filter 参数来定制化搜索范围，例如: sidebar: - toc - layout: search override: search filter: /path/to/some 如果想始终进行不加过滤的站内搜索，那么设置为 filter: &#39;&#39; 即可。 Footer（页脚）blog/_config.stellar.ymlfooter: social: github: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/08a41b181ce68.svg&quot;/&gt;&#x27; url: https:// music: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/3845874.svg&quot;/&gt;&#x27; url: https:// unsplash: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/3616429.svg&quot;/&gt;&#x27; url: https:// comments: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/942ebbf1a4b91.svg&quot;/&gt;&#x27; url: https:// 自定义组件Stellar 支持丰富的自定义小组件，详见这篇文档： https://xaoxuu.com/wiki/stellar/widgets/https://xaoxuu.com/wiki/stellar/widgets/"},{"title":"使用标签组件增强阅读体验","path":"/wiki/stellar/tag-plugins/index.html","content":"Stellar 内置的标签组件和 Hexo 官方的一样使用空格分隔多个参数，所以如果参数内容中需要出现的空格被意外分隔开了的时候，请使用 &amp;nbsp; 代替。为了方便理解，本文档语法格式中的可选参数用方括号括起来，键值对参数用冒号分隔开，例如： &#123;% image src [description] [download:bool/string] %&#125; 就表明第一个参数是图片链接，第二个参数是图片描述，而 download 是可选参数，并且值是布尔或字符串类型，第二三个参数为可选参数。 了解参数解析规则以图片标签为例，使用空格分隔开之后得到一个数组，如果图片描述文字中有空格，多分出来的这些「参数」被合并到最后一个「非键值对参数」中，什么是「非键值对参数」呢？举个例子您就明白了：&#123;% image /assets/wiki/stellar/photos/183e71e0ad995.jpg 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone-rohit_vohra_12172020.zip %&#125;这个例子中，download:https://xxxx 是有冒号分隔开的，download 为键，后面的网址为值，所以叫做「键值对参数」；与此相对的，没有冒号分隔的就叫做「非键值对参数」。键值对参数可以放在任何位置，我可以通过匹配键来解析，而非键值对参数则只能通过顺序解析，所以它们必须和文档中要求的前后顺序一致。一般核心的、重要的参数会设置成非键值对参数，而可选参数设置成键值对参数。"},{"title":"网站和主题基本信息配置","path":"/wiki/stellar/theme-settings/index.html","content":"站点信息Stellar 会读取站点根目录下的 _config.yml 文件中的一些信息来生成您的网站，所以您需要修改以下值： blog/_config.ymltitle: 您的网站名称avatar: 您的头像链接favicon: 您的网站iconsubtitle: 您的网站副标题# 多语言language: - zh-CN - en 更多关于 Hexo 文件的配置请移步官方文档 https://hexo.io/zh-cn/docs/configurationhttps://hexo.io/zh-cn/docs/configuration 多语言设置主题中的默认文案都支持多语言，以简体中文为例，您可以在 themes/stellar/languages/zh-CN.yml 中修改文案。 更改网站优先语言，需要在站点根目录下的配置文件中进行修改： blog/_config.ymllanguage: - zh-CN - en - zh-TW 创建主题配置文件在博客根目录的 _config.yml 文件旁边新建一个文件： _config.stellar.yml ，在这个文件中的配置信息优先级高于主题文件夹中的配置文件。 头部标签自定义Open Graph默认生成 Open Graph 标签，如果您不希望生成它，可以在主题配置文件中关闭： blog/_config.stellar.ymlopen_graph: enable: true twitter_id: # for open_graph meta"},{"title":"项目进度和近期计划","path":"/wiki/stellar/todo/index.html","content":""},{"title":"自定义小组件的配置与使用（8个）","path":"/wiki/stellar/widgets/index.html","content":"实现并显示一个小组件需要两个步骤： 【配置】在组件库中声明组件 【使用】在需要的位置调用 组件库在 _data/widgets.yml 文件中，需要自己创建，内容形如： &#x27;我的小组件1&#x27;: layout: 小组件布局模板 ...(其它属性) 使用的地方有：【主题配置】、【项目配置】、【页面】，后者可以覆盖前者，例如： blog/source/_posts/xxx.md---sidebar: [&#x27;我的小组件1&#x27;, &#x27;我的小组件2&#x27;]--- 组件库在创建组件时，您可以使用以下这些 layout 布局： toc 这是文章&#x2F;文档的目录树组件，显示文章和文档的目录结构： blog/source/_data/widgets.ymltoc: layout: toc list_number: false # 是否显示序号 min_depth: 2 # 建议不要低于 2 即从 H2 标签开始解析（H1标签用于文章大标题） max_depth: 5 # 5 代表最多解析到 H5 标签 fallback: recent # Use a backup widget when toc does not exist. toc 的 fallback 默认是 recent，即一篇文章没有 TOC 的时候会显示一个 recent recent blog/source/_data/widgets.ymlrecent: layout: recent rss: # /atom.xml # npm i hexo-generator-feed limit: 5 # Count of posts 在 wiki 板块显示的是最近更新的 wiki 页面，其余地方显示最近更新的文章。 hexo 的覆盖规则是合并而不是替换，所以若不想使用 recent，除了在 _config.stellar.yml 中删除 recent 你还需要将此处的 recent 置空，即 blog/source/_data/widgets.ymlrecent:# layout: recent# rss: # /atom.xml # npm i hexo-generator-feed# limit: 5 # Count of posts 然后自己需要的地方用自己另建的一个 my_recent 组件 blog/source/_data/widgets.ymlmy_recent: layout: recent ... related 相关文档组件，用于显示具有相同 tags 的其它项目列表，暂不支持自定义内容： Stellar 1.12.0 已将 wiki_more，更名为 related blog/source/_data/widgets.ymlrelated: layout: related markdown 这是一个自由度很高的标签，可以显示 markdown 文本内容： blog/source/_data/widgets.ymlwelcome: layout: markdown title: 欢迎欢迎 content: | 欢迎使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 主题，下面是您的入门指南，祝您使用愉快！ &lt;br&gt; **第一步** 创建 `blog/_config.stellar.yml` 文件，在此文件中填写需要自定义的主题配置。 &lt;br&gt; **第二步** 创建 `blog/source/_data/widgets.yml` 文件，此文件中填写需要自定义的侧边栏组件，例如 `welcome` 组件。 &lt;br&gt; 如果有任何疑问，请先查阅 [文档](https://xaoxuu.com/wiki/stellar/)，如果文档中没有提供，请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues/) 向开发者询问。 tagcloud 标签云组件： blog/source/_data/widgets.ymltagcloud: layout: tagcloud title: 标签云 # 标签云配置 min_font: 12 max_font: 24 amount: 100 orderby: name order: 1 # 1, sac 升序；-1, desc 降序 color: false # 使用颜色 start_color: # 开始的颜色。您可使用十六进位值（&#x27;#b700ff&#x27;），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 end_color: # 结束的颜色。您可使用十六进位值（&#x27;#b700ff&#x27;），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 show_count: false # 显示每个标签的文章总数 ghuser 显示 GitHub 用户基础信息卡片： blog/source/_data/widgets.ymlghuser: layout: ghuser username: github # your github login username avatar: true # show avatar or not menu: true # show menu or not 因为它和侧边栏左上角默认的 header 功能存在重复，所以建议隐藏默认的 header 组件： blog/source/_posts/xxx.md---title: 某一篇文章sidebar: [ghuser, ...]header: false # 不显示左上角的 logo 和 menu--- ghrepo 显示 GitHub 仓库基础信息，需要搭配 repo 一起使用： blog/source/_data/widgets.ymlghrepo: layout: ghrepo 需要在需要显示的文章页面的 front-matter 中按照如下格式写上仓库持有者和仓库名： blog/source/_posts/xxx.md---repo: xaoxuu/hexo-theme-stellar--- 如果需要显示在 wiki 项目中，则在 _data/projects.yml 中填写到对应项目的信息中： blog/source/_data/projects.ymlStellar: title: Stellar subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; repo: xaoxuu/hexo-theme-stellar ... timeline 动态说说朋友圈微博动态时间线组件，这个功能在 1.12.0 版本后开始支持： 动态数据是从 GitHub Issues 中拉取的，使用方法为： 在 widgets.yml 中新建配置 blog/source/_data/widgets.ymltimeline: layout: timeline title: 近期动态 api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues # 若你想限制数量，在api链接后面加上?per_page=1指限制为1条 user: # 是否过滤只显示某个人发布的内容，如果要筛选多人，用英文逗号隔开 hide: # title,footer # 隐藏标题或底部 # 此功能需要 Stellar v1.13.0这个功能在 1.13.0 版本后开始支持。 https://xaoxuu.com/wiki/stellar/third-party/fcircle/https://xaoxuu.com/wiki/stellar/third-party/fcircle/ blog/source/_data/widgets.yml# 愣着干啥，新建啊&#x27;朋友圈&#x27;: layout: timeline title: 近期动态 api: https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator # 你的朋友圈数据文件地址 type: fcircle limit: # 可通过这个限制最大数量这个功能在 1.18.0 版本后开始支持： blog/source/_data/widgets.ymlweibo: layout: timeline title: 微博动态 api: https://raw.githubusercontent.com/GitHub用户名/仓库名/output/output/tweets.json # 你的微博爬取数据文件地址 type: weibo limit: 20 无论是哪种动态数据，你都可以在 _config.stellar.yml 中设置引用 blog/_config.stellar.ymlsidebar: ... widgets: home: welcome, recent, 朋友圈, weibo 或者在你需要显示的页面引入，页面内引入优先于配置文件引入： blog/source/_posts/xxx.md---sidebar: [ghuser, search, 朋友圈]--- 配置默认布局主题配置中可以配置默认布局顺序，在这些页面中，侧边栏会按照指定的顺序从组件库中读取组件并显示： blog/_config.stellar.ymlsidebar: ... widgets: #### 自动生成的页面 #### # 主页 home: search, welcome, recent, timeline # for home # 博客索引页 blog_index: search_blog, recent, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, timeline # for wiki # 其它（404） others: search, welcome, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: toc, ghrepo, search, ghissues # for pages using &#x27;layout:post&#x27; # 文档内页 wiki: search, ghrepo, toc, ghissues, related # for pages using &#x27;layout:wiki&#x27; # 其它 layout:page 的页面 page: welcome, toc, search # for custom pages using &#x27;layout:page&#x27; 灵活用法继承（覆盖）组件适合有多个相似组件的情况，例如有多个时间线组件，显示规则相同，仅 api 地址不同： blog/source/_data/widgets.ymlmy_timeline_lite: layout: timeline title: 近期动态 user: xaoxuu hide: title,footer api: 在不同的页面设置不同的 api 地址： blog/source/_posts/xxx.md---title: 某一篇文章sidebar: - toc # 只写一个字符串代表引用对应的通用组件 - override: my_timeline_lite api: https://xxx--- 匿名组件：仅在使用时创建适合仅在一个页面或项目中才需要用到的组件，例如在某个页面的侧边栏放一个公告： blog/source/_posts/xxx.md---title: 某一篇文章sidebar: - toc # 只写一个字符串代表引用对应的通用组件 - layout: markdown title: &#x27;重要通知 [NOTE.2022-09]&#x27; content: | 请不要原封不动的把本站内容复制到贵站中使用，这样一方面不尊重原作者，另一方面也会因为存在大量重复内容影响贵站收录甚至降权。 从2022年9月起本站已不再开源，已经持有源码副本或`fork`的朋友请及时删除以防止被他人恶意搬运的情况继续发生。 [&gt; 了解详情](https://github.com/xaoxuu/xaoxuu.github.io#readme)--- 又或者在项目的配置文件中创建专属于这个项目的组件： blog/_data/projects.ymlStellar: name: Stellar title: Stellar - 每个人的独立博客 subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; sidebar: - search - toc - ghrepo - layout: timeline title: 最近更新 api: https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/releases?per_page=1 hide: footer ..."},{"title":"如何使用文档系统","path":"/wiki/stellar/wiki-settings/index.html","content":"Stellar 独创了其它 Hexo 主题所没有的 Wiki 文档系统，可以自动找到一个项目的所有文档分页，生成一个目录树，还可以手动指定顺序、标题、分组，而非依赖文件路径、文件名来排序和显示。 基本流程1&#x2F;3 创建项目描述文件在 blog/source/_data/ 文件夹中创建一个 wiki 文件夹，在其中放入各个项目的文档。以 Stellar 项目为例，文件名就是项目的 id：blog/source/_data/wiki/hexo-stellar.ymlname: Stellartitle: Stellar - 每个人的独立博客subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27;tags: 博客主题cover: truelogo: src: /assets/wiki/stellar/icon.svg small: 108px large: 180pxdescription: Stellar 是一个内置文档系统的简约商务风 Hexo 主题，支持丰富的标签和动态数据组件。repo: xaoxuu/hexo-theme-stellarsidebar: - search: override: search filter: /wiki/stellar/ placeholder: 在 Stellar 中搜索... - toc - timeline_stellar_releases - relatedcomment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27;comments: service: giscus giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226path: /wiki/stellar/toc: &#x27;快速开始&#x27;: - index - examples - releases &#x27;基本使用&#x27;: - theme-settings - pages - sidebar - tag-plugins - tag-plugins/express - tag-plugins/data - tag-plugins/container - comments &#x27;文档系统&#x27;: - wiki-settings &#x27;进阶玩法&#x27;: - widgets - advanced-settings - notes - fcircle &#x27;技术支持&#x27;: - articles - todo - contributors2&#x2F;3 设置布局模板和项目名称在此文档项目的 md 文件的 front-matter 部分设置布局模板为 wiki 并且指定所属的项目 id （即上一步创建的文件名 id.yml）blog/source/wiki/stellar/index.md---layout: wiki # 使用wiki布局模板wiki: hexo-stellar # 这是项目id，对应 /data/wiki/hexo-stellar.ymltitle: 这是分页标题---3&#x2F;3 将此项目「上架」在 blog/source/_data/ 文件夹中创建一个 wiki.yml 文件，在其中写入需要显示的项目 id：blog/source/_data/wiki.yml- hexo-stellar- 其它项目这样在项目列表（wiki）页面就可以看到刚刚创建的项目了。 项目分页索引指定项目所在文件夹和目录树： blog/source/_data/wiki/hexo-stellar.ymlpath: /wiki/stellar/toc: &#x27;快速开始&#x27;: - index # 会被关联到 /wiki/stellar/index.md - examples # 会被关联到 /wiki/stellar/examples.md - releases &#x27;基本使用&#x27;: - theme-settings - pages - sidebar - tag-plugins - tag-plugins/express - tag-plugins/data - tag-plugins/container - comments &#x27;文档系统&#x27;: - wiki-settings &#x27;进阶玩法&#x27;: - widgets - advanced-settings - notes - fcircle &#x27;技术支持&#x27;: - articles - todo - contributors 如果目录树不需要分组，可以这样写： blog/source/_data/wiki/hexo-stellar.ymlpath: /wiki/stellar/toc: - index # 会被关联到 /wiki/stellar/index.md - examples # 会被关联到 /wiki/stellar/examples.md - ... 是否显示封面项目可以显示一个全屏封面，封面占据一个屏幕的高度，会居中依次显示项目的 logo、标题、描述。开启项目封面方法如下： blog/source/_data/wiki/hexo-stellar.ymlcover: truelogo: src: /assets/wiki/stellar/icon.svg small: 120px large: 240px 如果 logo 中已经包含了项目标题，可以这样设置不显示项目标题： blog/source/_data/wiki/hexo-stellar.ymlcover: [logo, description] 项目文档标签如果您有很多项目，有些项目是有相关性的，可以相同的 tags 值： blog/source/_data/wiki/hexo-stellar.ymltags: 博客主题 也可以设置多个 tags 值： blog/source/_data/wiki/hexo-stellar.ymltags: [博客主题, 开源项目] 项目的 GitHub 仓库信息设置了 repo 值就会在右上角显示项目仓库的相关链接： blog/source/_data/wiki/hexo-stellar.ymlrepo: xaoxuu/hexo-theme-stellar 项目评论设置如果希望项目的所有分页使用相同的评论数据，可以在这里覆盖评论配置： blog/source/_data/wiki/hexo-stellar.ymlcomment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27;comments: giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226 侧边栏组件如果您希望自定义某个项目的侧边栏组件，可以设置 sidebar 值： 可以覆盖组件： blog/source/_data/wiki/hexo-stellar.ymlsidebar: - search: override: search filter: /wiki/stellar/ placeholder: 在 Stellar 中搜索... - toc - timeline_stellar_releases - related 在目录树中隐藏某篇文章可以在 front-matter 中不设置 title 标题，或者将 title 改为 seo_title： blog/source/xxx/xxx.mdseo_title: 原本的标题 显示许可协议沿用主题配置文件中设置的： blog/source/_data/wiki/hexo-stellar.ymllicense: true 也可以指定协议内容： blog/source/_data/wiki/hexo-stellar.ymllicense: &#x27;本文采用 [署名-非商业性使用-相同方式共享 4.0 国际](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。&#x27; 显示分享blog/source/_data/wiki/hexo-stellar.ymlshare: true 修改 wiki 路径在根目录中添加 wiki_dir 指定 Wiki 主页的路径，若不指定路径，您在点击返回所有项目时会回到主页而非回到所有项目。 blog/_config.ymlwiki_dir: wiki 例如书籍类的“项目”可以改为： blog/_config.ymlwiki_dir: books 例如商品&#x2F;产品类的“项目”可以改为： blog/_config.ymlwiki_dir: products"},{"title":"容器类标签组件（9个）","path":"/wiki/stellar/tag-plugins/container/index.html","content":"box 盒子容器note 标签就是使用 box 容器实现的，它们样式是相同的： 更名记录（Stellar 1.18.0）因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：noteblock -&gt; grid -&gt; border -&gt; ablock -&gt; box详情见：#172 语法格式&#123;% box [title] [color:color] [child:codeblock/tabs] %&#125;...&#123;% endbox %&#125; 写法如下&#123;% box Stellar v1.12.0 color:warning %&#125;因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：noteblock -&gt; grid -&gt; border -&gt; ablock -&gt; box详情见：[#172](https://github.com/volantis-x/hexo-theme-volantis/issues/712)&#123;% endbox %&#125; 彩色代码块设置 child:codeblock 并设置 color:颜色枚举 可以实现 10 种不同颜色的代码块，彩色代码块一般可以用在代码正确与错误的示范对比场景。 示例示例代码推荐的写法func test() &#123; // ...&#125;不推荐的写法func test() -&gt; () &#123; // ...&#125; 嵌套其它标签例如嵌套一个 tabs 标签： 图文混排示例代码个人电脑作为办公设备时，我们该如何保护隐私？公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区进行加密。 folding 折叠容器折叠块标签的语法格式为： &#123;% folding title [codeblock:bool] [open:bool] [color:color] %&#125;content&#123;% endfolding %&#125; 参数说明codeblock: true/falseopen: true/falsecolor: red/orange/yellow/green/cyan/blue/purple/light/dark 彩色可折叠代码块备注标签相较于旧版进行了增强，可以实现更多种颜色，还可以通过设置 child:codeblock 来实现可折叠的代码块。以下是一个默认打开的代码折叠框： 默认打开的代码折叠框func test() &#123; print(&quot;hello world&quot;)&#125; 代码如下： &#123;% folding child:codeblock open:true color:yellow 默认打开的代码折叠框 %&#125;代码块&#123;% endfolding %&#125; 危险，请不要打开这个通过设置颜色，以实现更醒目的作用，但不要滥用色彩哦～警告，真的很危险通过设置颜色，以实现更醒目的作用，但不要滥用色彩哦～最后一次警告，千万不要打开这个不要说我们没有警告过你，Windows 10 不是為所有人設計，而是為每個人設計。 folders 多个折叠容器聚合样式相比 folding 简单一些，适用于多个折叠标签平铺显示的场景，例如题目列表： 题目1这是答案1题目2这是答案2题目3这是答案3 代码如下： &#123;% folders %&#125;&lt;!-- folder 题目1 --&gt;这是答案1&lt;!-- folder 题目2 --&gt;这是答案2&lt;!-- folder 题目3 --&gt;这是答案3&#123;% endfolders %&#125; tabs 分栏容器这个标签移植自 NexT 主题，但做了以下修改： 支持设置 align:center 来使内容居中 设置默认激活的标签方式为 active:1 而非 , 1（使用默认格式降低学习成本，且显式声明可读性更强） 不需要 &lt;!-- endtab --&gt; 来作为结束标识（因为 Stellar 会自动判断） 不需要 tabs id 来保证唯一性（因为 Stellar 会设置唯一标识） 不支持 @icon 方式设置图标（因为 Stellar 不再内置 fontawesome 图标库） 轮廓样式简化，可以搭配其它容器类标签嵌套使用。 演示效果示例代码图片代码块表格let x = 123print(&quot;hello world&quot;) a b c a1 b1 c1 a2 b2 c2 grid 网格分区容器这个功能在 1.12.0 版本后开始支持，目前只支持显示一行两列。 Unsplash PhotoThe Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Its mass is equal to four million suns. The center is located 25,800 light years away from Earth.Ōwhiro Bay, Wellington, New ZealandPublished on May 31, 2022SONY, ILCE-6000Free to use under the Unsplash License 普通块样式： 左侧内容右侧内容 卡片样式： 左侧内容右侧内容 示例代码： &#123;% grid bg:block %&#125;&lt;!-- cell left --&gt;&lt;center&gt;左侧内容&lt;/center&gt;&lt;!-- cell right --&gt;&lt;center&gt;右侧内容&lt;/center&gt;&#123;% endgrid %&#125; bg 为可选参数，默认没有背景，可设置为 block/card 两种样式 gallery 图库容器这个功能在 1.21.0 版本后开始支持，其内部只能填写 md 格式的图片，固定显示为 4 列。 eberhard in unsplasheberhard in unsplasheberhard in unsplasheberhard in unsplash 写法如下&#123;% gallery %&#125;![eberhard in unsplash](https://images.unsplash.com/photo-1533274221104-015a584a1005?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDE4fGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![eberhard in unsplash](https://images.unsplash.com/photo-1539604214100-ab860d9082e0?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDIxfGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![eberhard in unsplash](https://images.unsplash.com/photo-1700994630045-f7a20df6d92e?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8MjN8fHxlbnwwfHx8fHw%3D)![eberhard in unsplash](https://images.unsplash.com/photo-1698843848092-588f9c1bb0bd?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8Mzh8fHxlbnwwfHx8fHw%3D)&#123;% endgallery %&#125; banner 横幅容器这个功能在 1.21.0 版本后开始支持，将会取代 about 组件，请尽快完成迁移。 用于独立页面顶部 随记收藏随记 写法如下：&#123;% banner 随记 bg:/assets/banner/notes.jpg %&#125;&#123;% navbar active:/notes/ [随记](/notes/) [收藏](/bookmark/) %&#125;&#123;% endbanner %&#125; 用于用户个人资料页 某某这是个人简介 写法如下：&#123;% banner 某某 这是个人简介 avatar:/assets/xaoxuu/avatar/rect-256@2x.png bg:/assets/banner/nebula.jpg %&#125;&#123;% endbanner %&#125; 用作文章摘要卡片设置 link 可以让整个卡片响应点击事件，实现点击跳转到对应文章： &#123;% banner 博客进阶：自动化部署 本文讲了如何利用脚本和 GitHub Actions 简化博客搭建和部署流程，提高效率。 bg:/assets/xaoxuu/blog/2022-1126a@2x.jpg link:/blog/20221126/ %&#125;&#123;% endbanner %&#125; 博客进阶：自动化部署本文讲了如何利用脚本和 GitHub Actions 简化博客搭建和部署流程，提高效率。 about 关于块容器这个功能即将废弃在 1.21.0 版本后请使用 banner 组件代替。 方便在关于页面显示一段图文信息，比普通块容器稍微有一点点不一样： &#123;% about avatar:/assets/xaoxuu/avatar/rect-256@2x.png height:80px %&#125;&lt;img height=&quot;32px&quot; alt=&quot;XAOXUU&quot; src=&quot;/assets/xaoxuu/logo/180x30@2x.png&quot;&gt;**如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。**XAOXUU 目前是一个 iOS 开发者，代表作品有：ProHUD、ValueX 等。在业余时间也开发了 Stellar 博客主题，更多的作品可以去项目主页查看，希望大家喜欢～&#123;% navbar [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) %&#125;&#123;% endabout %&#125; swiper 轮播容器默认一张图片是 50% 宽度，通过设置 width:min 设置为 25% 宽度，width:max 设置为 100% 宽度。 写法如下&#123;% swiper effect:cards %&#125;![](https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)![](https://images.unsplash.com/photo-1528283648649-33347faa5d9e?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)![](https://images.unsplash.com/photo-1542272201-b1ca555f8505?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)![](https://images.unsplash.com/photo-1524797905120-92940d3a18d6?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)&#123;% endswiper %&#125; 宽度切换效果写法如下&#123;% swiper width:min/max %&#125;...&#123;% endswiper %&#125;&#123;% swiper effect:cards/coverflow %&#125;...&#123;% endswiper %&#125; 注意一个页面只能设置一次，第一个 swiper 容器的效果全局生效。"},{"title":"数据集合类标签组件（5个）","path":"/wiki/stellar/tag-plugins/data/index.html","content":"timeline 时间线支持静态和动态时间线数据源： 静态数据 github issues 支持多种筛选参数，详见 API github releases 支持多种筛选参数，详见 API gitea issues 支持多种筛选参数，详见 API gitea releases 支持多种筛选参数，详见 API memos … 常见的使用场景请看这篇文章： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 静态时间线静态数据是写死在 md 源文件中的，在 deploy 时就已经确定了。 2021 年 2 月 16 日主要部分功能已经开发的差不多了。2021 年 2 月 11 日今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。 写法如下&#123;% timeline %&#125;&lt;!-- node 2021 年 2 月 16 日 --&gt;主要部分功能已经开发的差不多了。&#123;% image /assets/wiki/stellar/photos/hello@1x.png width:300px %&#125;&lt;!-- node 2021 年 2 月 11 日 --&gt;今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。&#123;% endtimeline %&#125; 动态时间线动态说说朋友圈微博动态动态数据是从 GitHub Issues 中拉取的，使用方法为： 建一个仓库 创建一个 issue 并添加一个 label 进行测试 写 timeline 标签时加上 api:https://api.github.com/repos/your-name/your-repo/issues 例如： _posts/xxx.md&#123;% timeline api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?direction=asc&amp;per_page=3 %&#125;&#123;% endtimeline %&#125; 效果如下： https://xaoxuu.com/wiki/stellar/third-party/fcircle/https://xaoxuu.com/wiki/stellar/third-party/fcircle/ _posts/xxx.md&#123;% timeline type:fcircle api:https://raw.github.xaox.cc/xaoxuu/friends-rss-generator/output/data.json %&#125;&#123;% endtimeline %&#125; fork shaoyaoqian&#x2F;WeiboSpider 的爬虫，修改自己的仓库名 修改 .github/workflows/main.yml 中的微博ID为你想爬取的ID，修改完后每天会自动爬取你的微博，存储为 json 文件，输出文件在 output 分支 _posts/xxx.md&#123;% timeline limit:20 type:weibo api:你的json文件地址 %&#125;&#123;% endtimeline %&#125; 静态 + 动态用法同静态和动态单独使用时一样，例如： &#123;% timeline reversed:true api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=2 %&#125;&lt;!-- node 这条内容为静态数据 --&gt;这条内容为静态数据，静态数据在 `deploy` 时就已经确定了。&#123;% endtimeline %&#125; 数据筛选只显示某个人的数据筛选最近3条todo筛选评论最多的3条建议 上述示例代码如下： &#123;% folders %&#125;&lt;!-- 只显示某个人的数据 --&gt;&#123;% timeline user:xaoxuu api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues %&#125;&#123;% endtimeline %&#125;&lt;!-- 筛选最近3条todo --&gt;&#123;% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=todo&amp;per_page=3 %&#125;&#123;% endtimeline %&#125;&lt;!-- 筛选评论最多的3条建议 --&gt;&#123;% timeline api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues?labels=feature-request&amp;per_page=3&amp;sort=comments %&#125;&#123;% endtimeline %&#125;&#123;% endfolders %&#125; 更多用法详见： GitHub&nbsp;REST&nbsp;APIhttps://docs.github.com/en/rest/issues/issues#list-issues-assigned-to-the-authenticated-user friends 友链xaoxuu枋柚梓MHuiGColsrch杜老师说星日语 您可以在任何位置插入友链组，支持静态数据和动态数据，静态数据需要写在数据文件中： blog/source/_data/links.yml&#x27;开源大佬&#x27;: - title: 某某某 url: https:// screenshot: avatar: description: 在需要的位置这样写： &#123;% friends 开源大佬 %&#125; 实现动态友链从 xaoxuu&#x2F;issues-json-generator 作为模板克隆或者 fork 仓库 修改 config.yml 并打开 github action 的运行权限 config.yml# 要抓取的 issues 配置issues: repo: xaoxuu/friends # 仓库持有者/仓库名（改成自己的） label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue sort: # updated-desc # 排序，按最近更新，取消此项则按创建时间排序 不出意外的话，仓库中已经配置好了 issue 模板，只需要在模板中指定的位置填写信息就可以了。然后在自己的仓库里提交一个 issue 并将 Label 设置为 active 进行测试。 提交完 issue 一分钟左右，如果仓库中出现了 output 分支提交，可以点击查看一下文件内容是否已经包含了刚刚提交的 issue 中的数据，如果包含，那么前端页面就可以使用友链数据了： &#123;% friends api:https://raw.github.xaox.cc/xaoxuu/friends/output/v2/data.json %&#125; 数据托管与加速特别感谢特别感谢小冰博客的加速访问方案，解决了直接请求 GitHub API 速度过慢的问题，详见 小冰博客 的教程。 支持把数据托管到任何其他地方来使用，例如： &#123;% friends api:https://raw.github.xaox.cc/xaoxuu/friends/output/v2/data.json %&#125; Stellar 1.13.0动态数据 API 升级至 v2 版本，原使用 issue-api 仓库的需要将友链仓库同步更新。v1 版本已经停止维护。 你可以有 N 种办法加速访问 GitHub 仓库里的文件。 sites 网站卡片appstorrenthttps://appstorrent.ruMacBL马可菠萝 - 分享你喜欢的MAC应用Xclient精品MAC应用分享MacApp分享频道https://macapp.org.cn/app/MACYYhttps://www.macyy.cn/resources 您可以在任何位置插入网站卡片组，支持静态数据和动态数据，静态数据需要写在数据文件中： blog/source/_data/links.yml&#x27;分组名&#x27;: - title: 某某某 url: https:// screenshot: avatar: description: 在需要的位置这样写： &#123;% sites 分组名 %&#125; Stellar v1.13.0原 friends 和 sites 标签数据合并至 links.yml 文件，动态数据使用方法同友链，数据源格式相同，与友链共享数据，仅样式不同，也可以用 sites 标签做友链。 ghcard 卡片 写法如下&#123;% ghcard xaoxuu %&#125;&#123;% ghcard xaoxuu/hexo-theme-stellar theme:dark %&#125; GitHub&nbsp;Card&nbsp;APIhttps://github.com/anuraghazra/github-readme-stats toc 文档目录树&#123;% toc wiki:xxx [open:true] [display:mobile] title %&#125;"},{"title":"表达类标签组件（15+个）","path":"/wiki/stellar/tag-plugins/express/index.html","content":"emoji 表情包效果演示语法格式引入表情包内置了可配置的表情标签 使用方法如下： &#123;% emoji 爱你 %&#125;&#123;% emoji blobcat ablobcatrainbow %&#125;&#123;% emoji blobcat ablobcatattentionreverse %&#125;&#123;% emoji tieba 滑稽 %&#125;&#123;% emoji [source] name [height:1.75em] %&#125; 其中 source 可省略，默认为配置中的第一个 source（详见「引入表情包」部分） 如果对高度有特别要求，可以指定高度，例如：&#123;% emoji blobcat ablobcatrainbow height:4em %&#125; 表情速查表：Stellar内嵌blobcat小表情 blog/_config.stellar.ymltag_plugins: ... emoji: default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$&#123;name&#125;.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/$&#123;name&#125;.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$&#123;name&#125;.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/$&#123;name&#125;.gif tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/$&#123;name&#125;.png 在配置文件中，文件名用 ${name} 代替。 mark 标记标签支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 亮 暗 警告 错误 一共 12 种颜色。 支持多彩标记，包括：&#123;% mark 默认 %&#125; &#123;% mark 红 color:red %&#125; &#123;% mark 橙 color:orange %&#125; &#123;% mark 黄 color:yellow %&#125; &#123;% mark 绿 color:green %&#125; &#123;% mark 青 color:cyan %&#125; &#123;% mark 蓝 color:blue %&#125; &#123;% mark 紫 color:purple %&#125; &#123;% mark 亮 color:light %&#125; &#123;% mark 暗 color:dark %&#125; &#123;% mark 警告 color:warning %&#125; &#123;% mark 错误 color:error %&#125; 一共 12 种颜色。 hashtag 标签Stellar Hexo GitHub Gitea 如果没有指定颜色，且没有设置默认颜色，则随机取一个颜色，快来试试吧～ &#123;% hashtag Stellar https://xaoxuu.com/wiki/stellar/ %&#125;&#123;% hashtag Hexo https://hexo.io/ %&#125;&#123;% hashtag GitHub https://github.com/xaoxuu/ %&#125;&#123;% hashtag Gitea https://git.xaox.cc/ color:green %&#125; image 图片标签图片标签是一个精心设计的应对各种尺寸插图的标签，对于大图，可以放置一个「下载」按钮，语法格式如下： &#123;% image src [description] [download:bool/string] [width:px] [padding:px] [bg:hex] %&#125; 参数说明src: 图片地址description: 图片描述download: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth: 200px # 图片宽度padding: 16px # 图片四周填充宽度bg: &#x27;#ffffff&#x27; # 图片区域背景颜色，16进制 大尺寸图片无论在什么宽度的设备上都希望横向铺满的图片，一般不需要额外操作。可以在链接后面写上图片描述，如有必要，可以通过设置 download:true 使其显示一个「下载」按钮链接指向图片地址，如果下载链接与显示的图片地址不同，可以 download:下载链接 来使其能够下载原图。 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 来自澳大利亚的 Pieter de Vries 使用 iPhone 12 Pro Max 拍摄。 写法如下&#123;% image /assets/wiki/stellar/photos/183e71e0ad995.jpg 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone-rohit_vohra_12172020.zip %&#125;&#123;% image /assets/wiki/stellar/photos/bc7bda18328da.jpg 来自澳大利亚的 Pieter de Vries 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone_pieter_de_vries_011221.zip %&#125; 小尺寸图片优化宽度较小而高度较大的图片，可以设置宽、高、填充间距、背景色等对其布局进行优化，使得它在不同宽度的屏幕下都能获得不错的视觉体验： 有底色的图片没有底色的图片有底色的图片，可以填充图片底色： &#123;% image /assets/xaoxuu/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png width:200px padding:16px bg:white %&#125; 提示鼠标拖拽一下图片可以看看原图 如果不进行约束，在宽屏设备上阅读体验很糟糕没有底色的图片，可以填充 bg:var(--card) 动态颜色，能够适配暗黑模式： &#123;% image /assets/wiki/stellar/icon.svg bg:var(--card) padding:16px %&#125; 支持 Fancybox 插件点击放大由于 Stellar 主题的插件具有按需加载的特性，所以 Fancybox 插件默认也是已经配置好了的，在任意 image 标签中增加 fancybox:true 参数即可为特定图片开启缩放功能。如果一个页面没有任何地方使用，则不会加载 Fancybox 插件。 图片来自 Apple 官网 如果您希望全站所有的 image 标签都开启此功能，可在主题配置文件中修改以下参数： blog/_config.stellar.yml######## Tag Plugins ########tag_plugins: # &#123;% image %&#125; image: fancybox: false parse_markdown: true # 1.19.0 支持把 markdown 格式的图片解析成图片标签 quot 引用适合居中且醒目的引用：Stellar 是最好用的主题 支持自定义引号：热门话题 其中自定义引号素材在主题配置文件的 tag_plugins.quot 中配置： tag_plugins: ... # &#123;% quot %&#125; quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png 写法如下适合居中且醒目的引用：&#123;% quot Stellar 是最好用的主题 %&#125;支持自定义引号：&#123;% quot 热门话题 icon:hashtag %&#125;、&#123;% quot 特别引用 icon:default %&#125; 特别引用 此外，加上 el:h2/h3/h4/h5/h6 可以作为标题使用 poetry 诗词示例写法游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选&#123;% poetry 游山西村 author:陆游 footer:诗词节选 %&#125;莫笑农家腊酒浑，丰年留客足鸡豚。**山重水复疑无路，柳暗花明又一村。**箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。&#123;% endpoetry %&#125; note 备注块示例写法&#123;% note [title] content [color:color] %&#125;title: 标题（可选）content: 内容color: red/orange/yellow/green/cyan/blue/purple/light/dark/warning/error 具有标题的备注块直接写备注内容，默认是和代码块一样的样式，第一个空格前面的是标题，后面的是正文，如果标题中需要显示空格，请使用 &amp;nbsp; 代替。 示例写法这&nbsp;是标题这是正文 哈哈。&#123;% note 这&amp;nbsp;是标题 这是正文 哈哈。 %&#125; 彩色备注块示例写法一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。&#123;% note 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:cyan 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125; okr 目标管理这个功能在 1.20.0 版本后开始支持，这是一个 OKR（Objectives and Key Results）示例： O1 2024年的小目标：完成 Volantis 6.0 并发布上线 来自2025年的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 风险 0% 写法如下： &#123;% okr o1 %&#125;2024年的小目标：完成 Volantis 6.0 并发布上线来自2025年的复盘：已《基本》实现目标 &#123;% emoji tieba 滑稽 %&#125;&lt;!-- okr kr1 percent:1 --&gt;重构 tag-plugins 和 wiki 系统- 当 &#123;% mark KR %&#125; 进度为 100% 时，标签默认显示为 &#123;% mark color:green 已完成 %&#125;- 当 &#123;% mark KR %&#125; 未设置进度时，默认为 &#123;% mark 0% %&#125;- 当 &#123;% mark O %&#125; 未设置进度时，则显示所有 &#123;% mark KR %&#125; 进度平均值&lt;!-- okr kr2 percent:0.9 status:off_track --&gt;完成主要页面设计稿&#123;% tabs align:left %&#125;&lt;!-- tab 小提示1 --&gt;您可以在 _config.yml 文件中修改标签的颜色和文案&lt;!-- tab 小提示2 --&gt;您可以在 _config.yml 文件中增加任意的标签配置&#123;% endtabs %&#125;&lt;!-- okr kr3 percent:-0.12 status:unfinished --&gt;完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹）&#123;% checkbox 在咸水和海滩之间找一亩地 %&#125;&#123;% checkbox 求出圆周率后15位 %&#125;&#123;% checkbox 找出宇宙的终极逻辑 %&#125;&#123;% checkbox 去地狱里走两步 %&#125;&lt;!-- okr kr-4 status:at_risk --&gt;开发、测试和发布&#123;% image /assets/wiki/stellar/icon.svg height:64px 支持嵌套插入图片等其它简单组件 %&#125;&#123;% endokr %&#125; link 链接卡片效果演示语法格式写法示例https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/外链卡片标签的语法格式为： &#123;% link href [title] [icon:src] [desc:true/false] %&#125; 参数含义： href: 链接title: 可选，手动设置标题（为空时会自动抓取页面标题）icon: 可选，手动设置图标（为空时会自动抓取页面图标）desc: 可选，是否显示摘要描述，为true时将会显示页面描述不带摘要的样式：&#123;% link https://xaoxuu.com/blog/20221029/ %&#125;带摘要的样式：&#123;% link https://xaoxuu.com/blog/20221029/ desc:true %&#125; mermaid 图表安装插件 blog/_config.stellar.ymlmermaid: enable: false # js: https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js js: https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js # Available themes: default | dark | forest | neutral theme: neutral 使用前需要在 Markdown 文件开头加入 ---mermaid: true--- 演示效果代码示例graph LRA(Section A) --&gt;|option 1| B(Section A)B --&gt;|option 2| C(Section C) gitGraph commit commit branch develop commit commit commit checkout main commit commit 👆为什么我看不到效果？因为 xaoxuu 的博客没有安装这个插件 😂 https://mermaid.js.org/intro/https://mermaid.js.org/intro/ copy 复制行示例写法对于单行内容，可以使用 copy 标签来实现复制功能： 您可以设置 git:https 或者 git:ssh 或者 git:gh 来快速放置一个 git 仓库链接： &#123;% copy curl -s https://sh.xaox.cc/install | sh %&#125;&#123;% copy width:max curl -s https://sh.xaox.cc/install | sh %&#125;&#123;% copy git:https xaoxuu.com/hexo-theme-stellar %&#125;&#123;% copy git:ssh xaoxuu.com/hexo-theme-stellar %&#125;&#123;% copy git:gh xaoxuu.com/hexo-theme-stellar %&#125; radio 单选示例写法没有勾选的单选框 已勾选的单选框&#123;% radio 没有勾选的单选框 %&#125;&#123;% radio checked:true 已勾选的单选框 %&#125; 支持的参数checked: true/falsecolor: red/orange/yellow/green/cyan/blue/purple checkbox 复选示例写法普通的没有勾选的复选框 普通的已勾选的复选框 显示为加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框&#123;% checkbox 普通的没有勾选的复选框 %&#125;&#123;% checkbox checked:true 普通的已勾选的复选框 %&#125;&#123;% checkbox symbol:plus color:green checked:true 显示为加号的绿色的已勾选的复选框 %&#125;&#123;% checkbox symbol:minus color:yellow checked:true 显示为减号的黄色的已勾选的复选框 %&#125;&#123;% checkbox symbol:times color:red checked:true 显示为乘号的红色的已勾选的复选框 %&#125; 支持的参数checked: true/falsecolor: red/orange/yellow/green/cyan/blue/purplesymbol: plus/minus/times navbar 导航栏文章内也可以插入一个导航栏： &#123;% navbar active:/wiki/ [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) %&#125; active 传入要高亮的那个按钮的 url 文章项目留言GitHub frame 设备框架示例写法&#123;% frame iphone11 img:/assets/wiki/prohud/toast/demo-loading.png video:/assets/wiki/prohud/toast/demo-loading.mp4 focus:top %&#125; 文本修饰标签集 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 写法如下- 这是 &#123;% psw 密码 %&#125; 标签- 这是 &#123;% u 下划线 %&#125; 标签- 这是 &#123;% emp 着重号 %&#125; 标签- 这是 &#123;% wavy 波浪线 %&#125; 标签- 这是 &#123;% del 删除线 %&#125; 标签- 这是 &#123;% sup 上角标 color:red %&#125; 标签- 这是 &#123;% sub 下角标 %&#125; 标签- 这是 &#123;% kbd 键盘样式 %&#125; 标签，试一试：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125;"},{"title":"使用「友链朋友圈」极简版","path":"/wiki/stellar/third-party/fcircle/index.html","content":"特别感谢主题内置版本数据服务由 友链朋友圈 极简版提供。这个功能在 1.13.0 版本后开始支持。 第一步：fork repofork @Rock-Candy-Tea&#x2F;hexo-circle-of-friends第二步：设置自己的友链页面地址和主题类型修改 hexo_circle_of_friends/fc_settings.yaml 文件：- &#123;link: &quot;https://xaoxuu.com/friends/&quot;, theme: &quot;stellar&quot;&#125; # 友链页地址1，修改为你的友链页地址第三步：打开 Issues 友链抓取功能修改 hexo_circle_of_friends/fc_settings.yaml 文件：GITHUB_FRIENDS_LINKS: &#123; enable: true, # true 开启github issue兼容 type: &quot;volantis&quot;, # volantis/stellar用户请在这里填写volantis owner: &quot;xaoxuu&quot;, # 填写你的github用户名 repo: &quot;friends&quot;, # 填写你的github仓库名 state: &quot;open&quot;, # 填写抓取的issue状态(open/closed)&#125;第四步：打开 Actions 运行权限见官方教程 #simplemode第五步：放置在博客中支持首页文章导航栏、文章任意位置，创建一个文件，以本站 friends/rss/index.md 为例：---seo_title: 朋友文章robots: noindex,nofollowmenu_id: postcomments: falsepost_list: true # 这就意味着页面会显示首页文章导航栏sidebar: [welcome, recent]---&#123;% timeline type:fcircle api:https://raw.github.xaox.cc/xaoxuu/friends-rss-generator/output/data.json %&#125;&#123;% endtimeline %&#125;其中，api 部分替换为自己仓库地址及其对应的 data.json 文件真实路径。其中，post_list: true 意味着页面会显示首页文章导航栏，搭配主题配置文件中的：post-index: &#x27;朋友文章&#x27;: /friends/rss/即可实现在首页增加一个「朋友文章」栏目的效果。 你依然可以按照官方教程使用完整版。 本站示例仓库：@xaoxuu&#x2F;friends-rss-generator 如果把 data.json 输出到 output 分支，可以直接使用下面的 API 来访问文件： https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generatorhttps://raw.github.xaox.cc/xaoxuu/friends-rss-generator/output/data.json"},{"title":"使用「memos」极简版","path":"/wiki/stellar/third-party/memos/index.html","content":"需要有自己的 memos 账号，可以在别人部署的 memos 上注册，或者自建 memos 服务，详见官方文档： https://usememos.comhttps://usememos.com 作为侧边栏组件使用创建个人的 memos 时间线组件blog/source/_data/widgets.ymltimeline: layout: timeline title: 近期动态 api: https://memos.xaox.cc/api/v1/memo?creatorId=1&amp;limit=10 type: memos hide: user,footer 创建多人的 memos 时间线组件blog/source/_data/widgets.ymltimeline: layout: timeline title: 近期动态 api: https://s.dusays.com/api/v1/memo/all?limit=10 type: memos hide: footer 作为标签组件使用创建个人的 memos 时间线组件&#123;% timeline api:https://memos.xaox.cc/api/v1/memo?creatorId=1&amp;limit=10 type:memos avatar:/assets/xaoxuu/avatar/rect-256@2x.png %&#125;&#123;% endtimeline %&#125; 创建多人的 memos 时间线组件&#123;% timeline api:https://s.dusays.com/api/v1/memo/all?limit=10 type:memos %&#125;&#123;% endtimeline %&#125;"},{"title":"实现「笔记」页面","path":"/wiki/stellar/wiki-settings/notes/index.html","content":"创建描述文件blog/source/_data/wiki/notes.ymlname: 备忘录title: 备忘录icon: # 列表页图标cover: # 封面页大图coverpage: [cover, title, description] # 封面页显示的内容sidebar: - layout: search override: search filter: /notes/ placeholder: 在此处搜索... - toccomments: giscus: &#x27;data-term&#x27;: &#x27;23&#x27; &#x27;data-mapping&#x27;: numberpath: /notes/toc: &#x27;日常问题解决方案&#x27;: - mac &#x27;移动端开发笔记&#x27;: - ios - flutter &#x27;前端学习笔记&#x27;: - nodejs - server &#x27;在线工具&#x27;: - json 设置 menu_id然后笔记页面的 front-matter 中指定要高亮的 menu_id： blog/source/notes/index.md---layout: wikiwiki: notes # 这个跟上面的 /wiki/notes.yml 关联起来menu_id: notes # 这个跟配置文件中的 `sidebar.menu.notes` 关联起来，这很重要，如果没有这个，就像普通的wiki项目一样了--- 这样就可以啦～"}]
[{"title":"搭建环境与部署博客的最简便方法","url":"/blog/20221126/","content":"\n## 使用脚本自动化搭建\n\n{% folding 注：此脚本只适用于 Mac/Linux 平台 %}\n此脚本只适用于 Mac/Linux 平台，其中 Mac 平台 [全部指令](https://xaoxuu.com/wiki/cloud-shell/blog/) 均支持，而 Linux 平台有部分指令存在兼容性 BUG 有待解决：\n\n- `blog init`\n- `blog test xxx`\n- `blog i 主题`\n\n{% endfolding %}\n\n### 一键搭建环境\n\n如果电脑重装了系统，还没有安装 {% mark node.js %} 和 {% mark hexo %} 环境，可以在终端输入下面这行代码，一键完成前期准备工作：\n\n{% copy curl -s https://sh.xaox.cc/install | sh -s blog && blog check %}\n\n此命令会完成以下内容：\n1. 下载并安装 `blog` 脚本\n2. 由 `blog` 脚本检测 node.js 环境，如果没有则安装\n3. 由 `blog` 脚本检测 hexo 环境，如果没有则安装\n\n### 一键搭建环境并克隆自己的博客\n\n如果博客源码是私有仓库，且还没有配置过 ssh 或 git 账号密码，此时需要先配置一下。然后将后面的地址换成自己的博客源码地址：\n\n\n{% tabs align:left %}\n\n<!-- tab 已安装blog脚本 -->\n\n```\nblog resume https://github.com/user/repo\n```\n\n此命令会完成以下内容：\n1. 克隆博客及其子模块源码\n2. 执行 `npm i` 安装依赖\n3. 执行 `hexo s` 运行博客\n4. 打开 `http://localhost:4000` 预览博客\n\n<!-- tab 未安装blog脚本 -->\n\n```\ncurl -s https://sh.xaox.cc/install | sh -s blog && blog resume https://github.com/user/repo\n```\n\n此命令会完成以下内容：\n1. 下载并安装 `blog` 脚本\n2. 由 `blog` 脚本检测 node.js 环境，如果没有则安装\n3. 由 `blog` 脚本检测 hexo 环境，如果没有则安装\n4. 克隆博客及其子模块源码\n5. 执行 `npm i` 安装依赖\n6. 执行 `hexo s` 运行博客\n7. 打开 `http://localhost:4000` 预览博客\n{% endtabs %}\n\n### 测试主题效果\n\n如果遇到了问题，可以对比主题 demo 查看效果是否正常：\n\n{% tabs align:left %}\n<!-- tab 已安装blog脚本 -->\n{% copy blog test stellar %}\n<!-- tab 未安装blog脚本 -->\n{% copy curl -s https://sh.xaox.cc/install | sh -s blog && blog test stellar %}\n{% endtabs %}\n\n### 安装其它主题\n\n{% copy blog i stellar %}\n\n换成任意主题名，需要是发布到 [npmjs.org](https://www.npmjs.com/) 的主题，匹配到 `hexo-theme-主题名` 的部分。\n\n### 附：常用命令\n\n| 命令 | 功能 |\n| :-- | :-- |\n| `blog init` | 检查并安装环境，然后创建并运行博客 |\n| `blog test` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog test stellar` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog test vlts` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog test 主题名` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog i node` | 安装 node.js  |\n| `blog i hexo` | 安装 hexo  |\n| `blog i stellar` | 安装 stellar 主题，同理换成其它主题名字都可以 |\n| `blog i 主题名` | 安装任意主题 |\n| `blog c` | 同 `hexo clean` 然后打开 `localhost:4000` |\n| `blog cs` | 同 `hexo clean && hexo g` 然后打开 `localhost:4000` |\n| `blog cgd` | 同 `hexo clean && hexo g && hexo d && git add --all && git commit && git push origin` |\n| `blog help` | 打开文档页面 |\n\n## 设置 npm run 运行脚本\n\n打开博客的 `package.json` 文件，在 `scripts` 部分增加这些快捷指令：\n\n```json\n{\n  ...\n  \"scripts\": {\n    \"c\": \"hexo clean\",\n    \"s\": \"hexo clean && hexo server\",\n    \"g\": \"hexo clean && hexo generate\",\n    \"d\": \"hexo deploy\"\n  },\n  ...\n}\n```\n\n这样输入 `npm run s` 就相当于输入 `hexo clean && hexo server` 了，除此之外你也可以根据自己的需要增加其他脚本。\n\n## GitHub Actions 自动化部署\n\n通过 GitHub {% mark Actions %} 可以只提交源码到仓库，后续流程全部由 CI 自动完成，本质上是完成以下几个步骤：\n\n1. checkout 源码\n2. 配置环境\n3. 生成静态文件\n4. 部署到对应平台（GitHub Pages / Vercel / Server...）\n\n### 配置文件\n\n```yaml .github/workflows/auto-deploy.yml\nname: auto deploy\n\non:\n  [push] # 触发事件\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu\n    name: auto deploy\n    steps:\n    # 1. 获取源码\n    - name: Checkout\n      uses: actions/checkout@v1 # 使用 actions/checkout@v1\n      with: # 条件\n        submodules: true # Checkout private submodules(themes or something else). 当有子模块时切换分支？\n    # 2. 配置环境\n    - name: Setup Node.js 16.13.x\n      uses: actions/setup-node@master\n      with:\n        node-version: \"16.13.x\"\n    # 3. 生成静态文件\n    - name: Generate Public Files\n      run: |\n        npm i\n        npm install hexo-cli -g\n        hexo clean && hexo generate\n    # 4. 部署到 GitHub 仓库（可选）\n    - name: Deploy to GitHub Pages\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        deploy_key: ${{ secrets.DEPLOY_KEY }}\n        external_repository: xaoxuu/xaoxuu.github.io\n        publish_branch: gh-pages\n        publish_dir: ./public\n        commit_message: ${{ github.event.head_commit.message }}\n        user_name: 'github-actions[bot]'\n        user_email: 'github-actions[bot]@users.noreply.github.com'\n    # 5. 部署到服务器（可选）\n    - name: Deploy to Server\n      uses: easingthemes/ssh-deploy@v2\n      env:\n        SSH_PRIVATE_KEY: ${{ secrets.SERVER_SSH_KEY }}\n        ARGS: \"-rltgoDzvO --delete\"\n        EXCLUDE: \".well-known\"\n        SOURCE: public/\n        REMOTE_HOST: ${{ secrets.REMOTE_HOST }}\n        REMOTE_PORT: ${{ secrets.REMOTE_PORT }}\n        REMOTE_USER: ${{ secrets.REMOTE_USER }}\n        TARGET: ${{ secrets.TARGET }}\n```\n\n### 关键参数\n\n如果要部署到 GitHub 的仓库，需要配置 `DEPLOY_KEY` 参数，在 Settings -> Secrets 中填写对应的值：\n\n```yaml\nDEPLOY_KEY: xxx\n```\n\n如果要部署到服务器，需要配置这些参数，在 Settings -> Secrets 中填写对应的值：\n\n```yaml\nSERVER_SSH_KEY: 第一步本机生成的 id_isa 文件内容\nREMOTE_HOST: 服务器地址\nREMOTE_PORT: 服务器SSH端口\nREMOTE_USER: 用户名，例如 \"git\"\nTARGET: 生成的文件路径，例如 \"/www/wwwroot/xaoxuu.github.io/\"\n```\n\n## GitHub Codespaces\n\n如果你经常需要在一些临时电脑上写写稿子、预览效果，不能立即发布且需要多端同步，或许这是个不错的选择，详见这篇文章：\n\n{% link https://xaoxuu.com/blog/20221121/ desc:true %}","tags":["shell","hexo"],"categories":["技术分享"]},{"title":"浅尝 GitHub Codespaces","url":"/blog/20221121/","content":"\nGitHub 最近上线了 {% mark Codespaces %} 功能，页面入口如下：\n\n{% image https://bu.dusays.com/2022/11/21/637b8254e794a.png %}\n\n免费账号可以使用 120 core-hours compute • 15GB storage 额度：\n\n{% image https://bu.dusays.com/2022/11/21/637b8f99caa22.png %}\n\n感觉挺不错的，赶快来体验吧～\n\n{% quot el:h2 使用方法 %}\n\n现在，每个项目仓库 {% mark Code %} 的下拉菜单中多了一个 {% mark Codespaces %} 入口，点击就可以创建一个此项目仓库的 Codespaces 如图所示：\n\n{% image https://bu.dusays.com/2022/11/21/637b90778847c.png width:400px %}\n\n由于我的博客源码是通过 submodule 方式引用主题的，而且还设置了 GitHub Actions 自动化部署，所以几分钟等待过后 Codespaces 就已经把博客全套环境创建完成了，在这整个过程中不需要自己进行任何配置：\n\n{% image https://bu.dusays.com/2022/11/21/637b91cfb2d7e.png %}\n\n修改完代码直接提交到当前仓库，就和在本地提交 git 代码一样。\n\n{% quot el:h2 浅尝小结 %}\n\n初始化和博客环境搭建过程体验非常好，全程不需要操作。但是速度和本地相比是明显感觉到慢点的，由于我自己写了一个云脚本也可以在新装系统上一键完成全套流程，所以它可能不太适合我用来管理博客。\n\n{% link https://xaoxuu.com/blog/20221126/ desc:true %}\n\n但如果你经常需要在一些临时电脑上写写稿子、预览效果，不能立即发布且需要多端同步，或许这是个不错的选择。\n\n不知道大家会用它来做什么呢？{% emoji blobcat blobcatthink %}","tags":["GitHub","Codespaces"],"categories":["探索号"]},{"title":"探索 Stellar 时间线标签的 N 种用法","url":"/blog/20221029/","content":"\n时间线标签是 Stellar 最强大的特性之一，它可以以侧边栏组件身份出现在左侧边栏，可以以标签插件形式出现在文章任意位置，以下是笔者能想到的几种常见用法。\n\n<!-- more -->\n\n{% quot el:h2 icon:hashtag 教程与步骤 %}\n\n{% split %}\n<!-- cell left -->\n\n**效果**\n\n{% timeline %}\n<!-- node 第一步：打开 GitHub -->\n打开 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 的 GitHub 页面。\n<!-- node 第二步：点击 Star -->\n如果发现右上角的 Star 还没点亮，就点亮它！\n{% endtimeline %}\n\n<!-- cell right -->\n\n**源码**\n\n```\n{% timeline %}\n<!-- node 第一步：打开 GitHub -->\n打开 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 的 GitHub 页面。\n<!-- node 第二步：点击 Star -->\n如果发现右上角的 Star 还没点亮，就点亮它！\n{% endtimeline %}\n```\n\n{% endsplit %}\n\n{% quot el:h2 icon:hashtag 近期动态（说说） %}\n\n设置 `user:xxx` 则会只显示某人发的 `issue` 数据，可以用来展示个人动态。\n\n{% tabs %}\n\n<!-- tab 效果 -->\n{% timeline user:xaoxuu api:https://api.github.xaox.cc/repos/xaoxuu/blog-timeline/issues?per_page=2 %}\n{% endtimeline %}\n<!-- tab 源码 -->\n```\n{% timeline user:xaoxuu api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=2 %}\n{% endtimeline %}\n```\n\n{% endtabs %}\n\n{% quot el:h2 icon:hashtag 话题讨论 %}\n\n如果不限制 `user:xxx` 则会显示所有人发的 `issue` 数据，可通过 `labels` 筛选用于展示某一话题。\n\n{% tabs %}\n\n<!-- tab 效果 -->\n{% timeline api:https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/issues?labels=1.x+版本&per_page=3 %}\n{% endtimeline %}\n<!-- tab 源码 -->\n```\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=1.x+版本&per_page=3 %}\n{% endtimeline %}\n```\n\n{% endtabs %}\n\n\n{% quot el:h2 icon:hashtag 扩展阅读 %}\n\n可设置 `hide:title,footer` 隐藏标题和底部栏以进行紧凑型布局，例如 [#探索号](https://xaoxuu.com/wiki/stellar/articles/) 系列文章：\n\n{% tabs %}\n\n<!-- tab 效果 -->\n{% timeline hide:title,footer api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&labels=分享&per_page=3 %}\n{% endtimeline %}\n<!-- tab 源码 -->\n```\n{% timeline hide:title,footer api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&labels=分享&per_page=3 %}\n{% endtimeline %}\n```\n\n{% endtabs %}\n\n\n{% quot el:h2 icon:hashtag 更新日志 %}\n\n不只是 `issues` 数据，时间线也兼容 `releases` 数据，可直接用于展示项目更新日志：\n\n{% tabs %}\n\n<!-- tab 效果 -->\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/releases?per_page=3 %}\n{% endtimeline %}\n<!-- tab 源码 -->\n```\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/releases?per_page=3 %}\n{% endtimeline %}\n```\n\n{% endtabs %}\n\n\n{% quot el:h2 icon:hashtag 友链文章订阅 %}\n\n嗯，除了 `issues` 和 `releases` 数据，时间线还兼容「友链朋友圈」数据，可以展示小伙伴们最近发布的文章：\n\n{% split %}\n\n<!-- cell left -->\n**效果**\n{% timeline type:fcircle limit:3 api:https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator %}\n{% endtimeline %}\n<!-- cell right -->\n**源码**\n```\n{% timeline type:fcircle limit:3 api:https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator %}\n{% endtimeline %}\n```\n\n因为篇幅有限，这里设置了最多只显示 3 条数据，实际可根据需要进行设置。\n\n\n{% endsplit %}\n\n{% quot el:h2 icon:hashtag 热评文章 %}\n\n如果使用基于 issues 的评论系统，可以通过按评论数排序展示热评文章：\n\n{% tabs %}\n\n<!-- tab 效果 -->\n{% timeline hide:title,user user:utterances-bot,beaudar-bot api:https://api.github.com/repos/xaoxuu/blog-comments/issues?sort=comments&per_page=3 %}\n{% endtimeline %}\n<!-- tab 源码 -->\n```\n{% timeline hide:title,user user:utterances-bot,beaudar-bot api:https://api.github.com/repos/xaoxuu/blog-comments/issues?sort=comments&per_page=3 %}\n{% endtimeline %}\n```\n\n因为篇幅有限，这里设置了最多只显示 3 条数据，实际可根据需要进行设置。\n\n\n{% endtabs %}\n\n\n{% quot el:h2 icon:hashtag 侧边栏时间线 %}\n\n在 `source/_data/widgets.yml` 文件中创建时间线组件：\n\n```yaml\ntimeline:\n  layout: timeline\n  title: 近期动态\n  api: https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=1\n  user: xaoxuu\n\ntimeline_stellar_more:\n  layout: timeline\n  title: Stellar 探索号\n  api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&labels=分享&per_page=5\n  hide: title\n```\n\n然后在需要显示的页面的 `front-matter` 中的 `sidebar` 部分写上它的名字，例如本文的配置：\n\n```yaml\nsidebar: [toc, timeline_stellar_more]\n```\n\n大家有什么关于 Stellar 的文章想要分享吗？欢迎投稿，提完 `issue` 这里就可以看到了，不要乱投哦～\n\n{% link https://xaoxuu.com/wiki/stellar/articles/ desc:true %}","tags":["Stellar","Hexo"],"categories":["技术分享"]},{"title":"用 GitHub 搭建一个简单的脚本库","url":"/blog/20210102/","content":"\n{% note color:warning 接口变动 近期已升级至 v3 版本，文章内容已更新。 %}\n\n细心的朋友可能会发现，我提供的一些脚本都可以在不依赖任何包管理工具的情况下通过一行命令安装，并且它们的安装命令极为相似：\n\n```\ncurl -s https://sh.xaox.cc/install | sh -s hexo\ncurl -s https://sh.xaox.cc/install | sh -s tag\ncurl -s https://sh.xaox.cc/install | sh -s vimcn\ncurl -s https://sh.xaox.cc/install | sh -s podspec\n```\n\n虽然它们安装方式极为相似，但是安装逻辑却并非完全相同，例如前三者是安装到 `/usr/local/bin/` 目录下，在任意位置打开终端都可以使用，而  `podspec.sh` 则是下载到当前目录下。\n\n如果打开 `https://sh.xaox.cc/install` 文件，你会发现它并没有做任何实质性的操作，只是负责任务派发，根据不同的参数把「安装」指令指派给不同的项目，不同的项目对「安装」的具体实现可以相同也可以不同。\n\n对于相同的部分，以 `vimcn` 为例，它的 `index.sh` 实现如下：\n\n```sh\n#!/bin/sh\n# 这个脚本负责下载和安装的逻辑\n\n# function lib\nlib='https://sh.xaox.cc/lib/v3'\n# repository name\nREPO='vimcn'\n# clint file name\nTARGET='cli.sh'\n# clint file name\nRENAME='upload'\n# download version\nVERSION=$1\nif [ \"$VERSION\" = \"\" ];then\n\tVERSION='main'\nfi\n\non_success() {\n\tdoc_url=xxx\n\tprintf \"\\n> \\033[32m恭喜您，安装成功！\\033[0m 请收藏这个页面，在您遇到问题的时候可以查看文档：\\n${doc_url}\\n\\n\"\n}\n\ncurl -s ${lib}/download.sh | sh -s ${REPO} ${VERSION} ${TARGET} &&\ncurl -s ${lib}/install.sh | sh -s $HOME/Downloads/${TARGET} ${RENAME} && on_success\n```\n\n从中可以看到它导入了一个「库」，确切的说是一个存放可复用代码的仓库地址，具体的「下载」与「安装」脚本像独立组件一样可供外部调用。与此例不同的 `podspec.sh` 脚本就只有下载操作：\n\n```sh\ncurl -s ${lib}/download.sh | sh -s ${REPO} ${VERSION} ${TARGET} ./ &&\nchmod 777 ${TARGET} && on_success\n```\n\n## 易于扩展\n\n这么一套流程使得脚本安装变得非常有扩展性，如果需要发布一个新的脚本，只需要新建仓库，在其中写一个 `index.sh` 脚本，通过调用 `lib` 仓库里封装好的脚本，传入仓库名、版本、要下载的文件，就可以轻松实现下载安装流程。\n\n## 易于使用\n\n更重要的是，可以通过一行命令来安装：\n\n```\ncurl -s https://sh.xaox.cc/install | sh -s 我的脚本\n```\n\n这套体系类似于包管理工具一样，但目前只对创建在 [@cloud-shell-lib](https://github.com/cloud-shell-lib/) 中的仓库有效。\n\n## 总结\n\n就是一个比包管理工具更轻量级更小的「个人脚本管理」体系，不需要本地依赖，适合经常换系统、换设备执行一些轻量级任务的场景。\n\n## <del>Todo</del>\n\n暂时没有 todo 了，不打算折腾了，感兴趣的朋友可以自己研究一下，不懂的话可以留言询问。搭建方法就是：\n\n1. fork [lib](https://github.com/cloud-shell-lib/lib) 或者自己创建一个更好的公共库。\n2. 在网站某个路径下放一个 [install](https://sh.xaox.cc/install) 文件，根据传入参数把指令转发给目标脚本仓库。\n3. 在目标脚本仓库中创建一个命名固定的脚本用于接收传入的指令，然后可以根据需要执行操作或者调用公共库的下载、安装等通用流程。\n","tags":["shell"],"categories":["设计开发"]},{"title":"苹果设计开发加速器线上活动","url":"/blog/20201119/","content":"\n受疫情影响，今年设计开发加速器活动改为线上形式，本次参与的活动课题是《为 iPhone 和 iPad 搭建灵活适配的用户界面》。<!-- more -->新出的几款 iPhone 和 iPad 设备尺寸和旧设备都不同，造成适配成本增加，本次活动目的是向开发者分享高效而灵活的适配方案。\n\n## 避免屏幕分辨率硬编码\n\n常见陷阱：对硬件设备型号做特殊判断\n\n## 适配方面\n\n- 启动屏\n- 安全区和布局边框\n- 尺寸类\n- 动态字体\n\n\n### 启动屏\n\n用 Storyboard 启动屏，不建议用图片作为启动页，详见官方设计指南：\n\n{% link https://developer.apple.com/design/human-interface-guidelines/patterns/launching/ Human Interface Guidelines %}\n\n### 安全区和布局边框\n\n**安全区**\n\nUIScreen & UIWindow 获得布局尺寸进行排版不适用于 iPhone X 以及以后机型\n\n要使用安全区来进行布局（安全区是动态的，不同设备、横竖屏、子视图都不相同）\n\n```\n.safeAreaInsets\n.safeAreaLayoutGuide\n```\n\n还可以根据需要定制安全区（例如定制工具栏）\n\n```\n.additionalSafeAreaInsets\n```\n\n安全区发生变化时：\n\n```\n.viewSafeAreaInsetsDidChange()\n```\n\n\n\n**布局边框**\n\n```\n.layoutMargins\n.directionalLayoutMargins\n.layoutMarginsGuide\n.layoutMarginsDidChange()\n```\n\n与安全区配合使用\n\n子视图传递\n\n布局边框会根据设备宽度、动态字体而自动调整，能够自动适配。\n\n\n\n### 尺寸类\n\n```\nsizeClasses\n```\n\n- C 紧凑型（iPhone竖屏，iPad分屏）\n- R 常规型（iPad竖屏，12.9‘iPad等宽分屏）\n\n\n\n### 动态字体\n\n```\n.large\n.title1\n...\n\nlabel.font = UIFont.preferred...\n```\n\n**自定义字体**\n\n```\nmetrics = UIFontMetrics(...)\n```\n\n> more at WWDC2017\n\n## 后记\n\n{% timeline %}\n\n<!-- node 2021年1月4日 -->\n\n今天收到 Apple 的邮件，设计开发加速器活动现在已经开放申请啦，感兴趣的朋友们可以去 [官网](https://developer.apple.com/cn/accelerator/) 申请。\n\n<!-- node 2021年2月1日 -->\n\n今天无意中发现又关闭申请入口了。\n\n<!-- node 2021年4月9日 -->\n\n今天经同事提醒发现又开放申请了。\n\n{% endtimeline %}\n","tags":["iOS","设计开发加速器"],"categories":["技术加油站"]},{"title":"心率管家的设计与开发（下篇：信号处理）","url":"/blog/20200927/","content":"\n作为一名开发者，如何使用手机摄像头测量心率呢？在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。\n\n<!-- more -->\n\n{% frame iphone11 img:/assets/wiki/heartmate/docs/usage01.jpg video:/assets/wiki/heartmate/docs/usage01.mp4 focus:top %}\n\n## 光电容积脉搏波描记法\n\n目前市面上大部分便携心率检测设备都是基于光电容积脉搏波描记法来测量的。由于心跳引起动脉周期性变化，动脉内血液的容积发生周期性变化，因而对光线的吸收也会呈现同样的周期性变化，这个周期性变化的频率就是脉率，脉率大部分情况都和心率一致。\n\n打开相机，把手指指尖覆盖在摄像头上，观察屏幕上的取景框，就可以发现每心跳一次，屏幕中的红色都会变暗一次。对每一帧画面提取 RGB 均值，并转换到 HSV 色彩空间，把色相 H 作为特征值，得到时域信号。\n\n## 信号处理\n\n我使用简单的时域分析法计算脉率，关键点就是计算采样时间内的波峰个数。把色相信号绘制波形图如下：\n\n{% image /assets/xaoxuu/blog/2020-0927b@2x.jpg width:300px bg:#fff padding:8px %}\n\n由于覆盖力度不稳定导致色相会整体偏移因而产生低频噪声，再加原本就存在的高频噪声影响，波形显得很杂乱无章，所以使用带通递归滤波器进行滤波：\n\n{% image /assets/xaoxuu/blog/2020-0927c@1x.svg bg:#fff padding:16px %}\n\n公式展开为：\n\n{% image /assets/xaoxuu/blog/2020-0927d@1x.svg bg:#fff padding:16px %}\n\n用 Swift 语言实现这个滤波器的算法（10阶）为：\n\n```swift\nprivate struct BandpassFilter {\n    private var x = [CGFloat].init(repeating: 0, count: 11)\n    private var y = [CGFloat].init(repeating: 0, count: 11)\n    @discardableResult mutating func filted(_ value: CGFloat) -> CGFloat {\n        guard x.count > 10, y.count > 10 else {\n            return 0\n        }\n        for i in 0 ..< 10 {\n            x[i] = x[i+1]\n            y[i] = y[i+1]\n        }\n        x[10] = value / 1.894427025e+01\n        y[10] = x[10] - x[0] + 5 * (x[2] - x[8]) + 10 * (x[6] - x[4])\n        y[10] += (-0.0000000000 * y[0]) + (0.0357796363 * y[1])\n        y[10] += (-0.1476158522 * y[2]) + (0.3992561394 * y[3])\n        y[10] += (-1.1743136181 * y[4]) + (2.4692165842 * y[5])\n        y[10] += (-3.3820859632 * y[6]) + (3.9628972812 * y[7])\n        y[10] += (-4.3832594900 * y[8]) + (3.2101976096 * y[9])\n        return y[10]\n    }\n}\n```\n\n> 这个算法是从 [WuXiaoTu/HeartRate](https://github.com/WuXiaoTu/HeartRate) 这个开源库中翻译来的。\n\n经过滤波之后就能看到波形图呈现锯齿状，由于这是由摄像头捕捉到的色相的波形图，所以看起来并不会像心电图那样：\n\n{% image /assets/xaoxuu/blog/2020-0927e@2x.jpg width:300px bg:#fff padding:8px %}\n\n有了干净的波形图，就可以数出一段时间内的波峰个数，从而计算出频率。例如数5秒内有多少个波峰，然后乘以12就是每分钟脉搏跳动次数，也就是这5秒内的平均脉率。现在 GitHub 上的很多同类的开源项目也都是这种方案。由于连续测量的时间越长，发生中断的可能性就越大，测量成功率就越低，再考虑到心率本身就是变化的，时间跨度太长也会使得数据变得没有意义，测量时间太短又很容易被个别误差数据影响。\n\n网络上现有方案都是先确定测量时长，时间结束后计算结果：\n\n- 如果测量时间短：成功率高，准确性低。\n- 如果测量时间中等：成功率低，准确性高。\n- 如果测量时间长：成功率很低，准确性很高，但是数据意义不大。\n\n我想出了一种新的方案，就是每探测到一个有效脉冲，就记录下这个脉冲与上一个有效脉冲之间的间隔，两个连续的有效脉冲计算出来的频率就是100%正确的瞬时脉率。所以改进后的方案是：开始测量后，始终记录脉冲，随时可以计算瞬时脉率、最后若干秒的平均脉率。\n\n- 成功率：100%（不存在测量中断而失败的情况）\n- 准确性的情况如下：\n  - 如果脉冲计数都是由脉搏跳动引起的，测量结果就是完全准确的\n  - 如果脉搏跳动了而脉冲计数没有增加，不会影响结果，因为计算时只会把有效脉冲的周期进行累加\n  - 如果在脉搏跳动间隙额外增加了脉冲计数，那么数据就会失真\n\n如果不故意快速抖动手指，数据失真的情况就不会发生，因为手指不离开摄像头并在两次脉搏跳动中间产生一次色相饱和度明度都以假乱真的脉冲信号是很难的。\n\n\n\n### 脉冲探测器\n\n经过滤波后的数值是围绕0上下波动的，分别记录大于0的值和小于0的值，各自保存到数组中，然后求出它们的平均值：\n\n```swift\nif filted > 0 {\n    upVals.append(filted)\n    if upVals.count > 20 {\n        upVals.removeFirst(upVals.count - 20)\n    }\n} else if filted < 0 {\n    downVals.append(filted)\n    if downVals.count > 20 {\n        downVals.removeFirst(downVals.count - 20)\n    }\n}\nlet avgUp = upVals.reduce(0, +) / CGFloat(upVals.count)\nlet avgDown = downVals.reduce(0, +) / CGFloat(downVals.count)\n```\n\n如果新的值高于 `avgUp` 的一半，就标记 `flag = true` ，低于 `avgDown` 的一半且 `flag = true` 就标记 `flag = true`，触发一次脉冲，记录下这个脉冲的时间戳。如果两个脉冲之间的时间间隔符合正常心率的范围，就认为是有效脉冲。\n\n```swift\nif filted > 0.5 * avgUp  {\n    flag = true\n}\nif filted < 0.5 * avgDown && flag == true {\n    flag = false\n    let time = CACurrentMediaTime()\n    let period = time - periodStart\n    // 与上一个周期间隔时间满足正常周期范围\n    if period < MAX_PERIOD && period > MIN_PERIOD {\n        // 记录这次脉冲与上次脉冲的时间间隔\n        periods.append(period)\n        // 捕获到脉冲\n        delegate?.pulseDetector(detector: self, capture: periods)\n    }\n    periodStart = time\n}\nreturn filted\n```\n\n上文「正常心率的范围」如何界定？心率如果低到 40bpm 此时周期达到最大值，如果心率高达 255bpm 则周期达到最小值。\n\n```swift\nMAX_PERIOD = CFTimeInterval(60.0 / 40)\nMIN_PERIOD = CFTimeInterval(60.0 / 255)\n```\n\n\n\n### 计算脉率\n\n上一步记录下了每个脉冲的周期，取出最后 N 个要计算的脉冲，把它们的周期相加就是总时长，用 `个数 / 时长` 计算的值就是频率，频率乘以 `60` 就是每分钟的脉冲数，也就是脉率。\n\n```swift\nfunc calcFrequency(count: Int) -> CGFloat? {\n    guard (0 ... periods.count).contains(count) else {\n        return nil\n    }\n    let duration = periods.dropFirst(periods.count - count).reduce(0, +)\n    return CGFloat(count) / CGFloat(duration)\n}\n```\n\n{% frame iphone11 img:/assets/xaoxuu/blog/2020-0927f@2x.jpg %}\n\n## 准确性与参考价值\n\n由于心率是动态变化的，即使测量的脉搏跳动都是准确的，也就是说测量阶段实现了零误差，但是计算方式不一样也会产生不同的结果。因此直接拿结果去和小米手环或者 Apple Watch 上显示的数值去进行对比是不严谨的。正确地方法是在一个时间段内用多种方式测量的同时亲自用手测量脉搏跳动次数，可以借助本文的 demo 计算瞬时或者平均脉率，如果一段时间的脉冲计数完全正确，那么 demo 计算的结果就是完全准确的，瞬时脉率、最后 N 秒的平均脉率一般都不会相同。因此即使戴在一只手上同一时间进行测量，不同产品显示的心率不同也并不能说明它们谁更准，只能说谁的结果更具有参考价值。\n\n对此，我优化后的心率管家测量方案可以选择测量时长，也可以随时结束测量，运动后心率变化快的时候适合取短时间内例如5s平均脉率，心平气和的时候可以取适当长一点的例如10s或者20s的平均脉率。\n\n\n\n## 脉率和心率\n\n脉率是每分钟脉搏的次数，心率是每分钟心跳次数，健康情况下脉率与心率一致，但是如果出现心律失常，心脏有一些跳动不能有效将血液泵至全身，因此会出现脉搏缺失，导致脉率显著低于心率。如果用来判断心脏功能状态，误差很大。对于心动过速、低血压症和休克病人，即使是心率规则，由于脉压差很小，脉搏也会很弱，此时往往不能够准确测量脉率。\n\n另外，脉搏随肢体移动会形成伪迹波动，也会影响脉率的测量。而心率不受心律失常、心动过速、休克、肢体活动的影响，所以在临床上，医生判断心跳活动不是看脉率，而是看心率，摸脉搏只是一个辅助操作。\n\n因此，通过手环、手表、app 测量的“心率”并不是一个完全可靠的数据。\n\n## 后记\n\n非常感谢 [@JustinYang](https://lifestyle1.cn/) 大佬在滤波算法方面给予的援助。也十分感谢 [@Punmy](https://punmy.cn/)、[@WuXiaoTu](https://github.com/WuXiaoTu) 等作者的文章，使得后人能够少走很多弯路。\n\n{% link https://xaoxuu.com/blog/20190723/ desc:true %}\n","tags":["iOS","Swift","心率"],"categories":["设计开发"]},{"title":"静态博客使用 Issues API 来实现动态发布友链、书签","url":"/blog/20200823/","content":"\n由于发布 issue 的成本远远低于发布一次博客更新（即便是使用了持续集成），可以用 issue 来简化每个独立博客都必备的友链系统，也可以通过 issue 来快速发布动态资讯，弥补静态博客必须更新静态文件才能更新内容的缺点。此功能已经集成到了主题中，使用非常方便。\n\n<!-- more -->\n\n## 实现思路\n\n如标题所说，例如 Issues API 来实现，把请求到的结果进行解析，然后生成 HTML 标签，添加到页面中。为了获取到需要的信息，创建 Issue 需要遵循一定的格式，例如「网站卡片」就需要截图、网站标题、网站链接、网站描述、头像。可以设置 [Issues 模版](https://github.com/volantis-x/examples/issues/new/choose) 来简化步骤。\n\n通过 issue 方式发布内容可以支持 `script` 脚本，为了安全起见，最好设置一个限制，例如用标签来激活 `labels=active` 或者只对自己发布的有效，可以在解析数据的时候过滤掉 `script` 标签。\n\n\n## 如何在主题中使用？\n\n在 GitHub 或者 Gitee 创建仓库，仿照下面的示例，把 api 中的用户名和仓库名改成自己的。Issue 内容中需要有一段满足 JSON 格式的代码块：\n\n```json\n{\n    \"title\": \"\",\n    \"description\": \"\",\n    \"screenshot\": \"\",\n    \"url\": \"\",\n    \"avatar\": \"\",\n    \"version\": \"版本：^4.0\"\n}\n```\n\n仓库链接：\n\n{% link https://github.com/xaoxuu/friends/issues %}\n\n## 在线演示效果\n\n见本站友链\n\n{% link https://xaoxuu.com/friends/ %}\n","tags":["博客","GitHub"],"categories":["设计开发"]},{"title":"个人电脑作为办公设备时，我们如何保护隐私？","url":"/blog/20200627/","content":"\n公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区加密。\n\n<!-- more -->\n\n## 分区加密\n\n对 Mac 电脑进行磁盘分区和安装多系统非常简单，打开「磁盘工具」点击标题栏的「分区」按钮进行分区即可，分区的格式一定要选择加密的，这里推荐「APFS（加密）」格式。密码要记下来防止遗忘。这里选择加密分区主要可以防止意外挂载：在启动了工作区的系统之后，由于需要密码才能挂载生活区的数据宗卷，可以有效避免不小心点了挂载或者设置了自动挂载，导致拥有完整的磁盘访问权限的安防软件自动扫描了生活区的文件资料。同样的道理，工作分区加密也可以防止生活区的某些软件扫描到了工作资料导致数据泄露。\n\n{% image /assets/xaoxuu/blog/2020-0627d@2x.png %}\n\n{% image /assets/xaoxuu/blog/2020-0627c@2x.png %}\n\n分区完成之后，安装系统，目标宗卷选择刚刚新建的工作分区，剩下的系统安装步骤不需要赘述了。\n\n\n\n## 工作专用账号\n\n系统安装完成之后，最好登录工作专用的账号，不要使用同一个 AppleID 进行登录，否则仍然存在数据泄露的风险。同样的，浏览器账号也需要使用工作专用。AppleID 和浏览器账号基本上可以满足大部分需要记住账号密码的需求。\n\n而对于工作日志，我推荐给程序员的做法是创建本地 git 仓库，用 [Typora](https://typora.io) 编辑器 markdown 格式书写。它的缺点十分有限，就是新增文件稍微麻烦一点，要在左侧目录树上点击右键，然后选择「新建文件」，然后输入文件名，除此之外几乎没有缺点。对于支持 md 的其它笔记软件来说，它对于 md 的支持比较完整，方便更换和修改主题，导出格式丰富并且样式也比较完整。\n\n{% image /assets/xaoxuu/blog/2020-0627e@2x.png Typora 操作界面 %}\n\n\n## 用户目录权限\n\nMac 自带的一些用户文件目录例如「文稿」「桌面」等默认权限是 700 也就是仅当前用户可以读写和执行，但是自己新建的文件夹默认权限是 755 即全局用户都可以读取和执行。所以如果自己在原生的文件目录之外新建了文件夹，记得更改文件夹的权限：\n\n{% image /assets/xaoxuu/blog/2020-0627b@2x.jpg bg:#ECECEC width:500px 把权限由 755 修改为 700 %}\n\n我切换了另一个用户进入这个用户目录时就提示无权限访问了，理论上这个用户上的应用程序也没有权限访问吧。（不太肯定）\n\n\n{% note color:white 一个小坑 经测试发现，在两个独立的宗卷中如果存在用户名和密码相同的两个用户，那么即使设置了 700 权限，但实际上在另一个宗卷中登录同名同密码的用户，对这个用户的文件夹一样拥有权限，不知道这是苹果有意为之还是设计漏洞。 %}\n\n\n## 一个不便之处\n\n流程是进入系统后自动请求挂载另一个宗卷，由于开启了文件保险箱，所以弹出了密码输入框，不输入密码点击取消，则没有权限访问另一卷的磁盘内容。但是每次开机都会有这个弹窗，挺烦人的。\n\n{% image /assets/xaoxuu/blog/2020-0627f@2x.png width:400px %}\n\n网上搜索了设置开机不自动挂载的方法，都是修改 `fstab` 文件的方法：\n\n```md /etc/fstab\nUUID=427478BB-E267-4455-869A-4AAB54F792A1 none auto noauto 0 0\n```\n\n实测无效，每次登录用户还是会自动尝试挂载，可能这种方式在 APFS 分区中不再支持了。不知道在 2020 年，如何让 APFS 加密分区不自动挂载？\n","tags":["Mac"],"categories":["解决方案"]},{"title":"苹果设计开发加速器《创建卓越的 Apple Watch 体验》活动现场体验","url":"/blog/20191006/","content":"\n9月26号收到了苹果的一活动邀请邮件《创建卓越的 Apple Watch 体验》，活动地点是：Design and Development Accelerator，这是苹果今年7月份在上海设立的设计开发加速器，为开发者提供有关应用设计与开发的专业培训和资源。\n\n<!-- more -->\n\n{% folding 什么是「设计开发加速器」？ %}\n\n- 苹果官网：[设计开发加速器](https://developer.apple.com/cn/accelerator/)\n- 视频体验：[搞机零距离：中国开发者的大好事？苹果工程师一对一授课，让人开了又开？](https://www.bilibili.com/video/av58500736/?spm_id_from=333.788.videocard.7)\n- 媒体资讯：[苹果设计开发加速器正式启动，每年计划为 5000 名国内开发者提供支持](https://sspai.com/post/55613)\n\n<iframe src=\"//player.bilibili.com/player.html?aid=58500736&bvid=BV1Cx411Z71y&cid=102025595&page=1\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"400\" scrolling=\"no\" frameborder=\"0\" style=\"border-radius:8px\"></iframe>\n\n{% endfolding %}\n\n## watchOS 6\n\n构建面向 watchOS 的 app，让用户随时随地及时掌握信息并轻松完成快速操作。开放了更多种全新的 API，可以构建完全独立的 watchOS app，甚至是不带有 iOS 版的 watchOS app。现在，用户可以直接在 Apple Watch 上的 App Store 中查找并安装 app。\n\n## 独立的 App\n\n在 watchOS 6 中，可以构建完全独立的 Watch App。“Sign in with Apple” 让用户远离手机时也能在 Apple Watch 上登录 app。\n\n{% image /assets/xaoxuu/mirror/apple/documentation/watchkit/af79db6d-02b1-4df0-9f46-6c3c9db12d76.png width:500px bg:white padding:16px 选择应用模板 %}\n\n- **Watch-only app**\n  创建只有 Apple Watch 且没有相关 iOS 应用程序。\n\n- **watchOS app with an iOS app**\n  当您拥有 iOS 应用并想要提供可提供相似或相关体验的 watchOS 应用。\n\n在创建 watchOS Target 时，指定要构建的 watchOS 项目的类型。此外，如果将 watchOS 应用程序与 iOS 应用程序捆绑在一起，则必须指定 watchOS 应用程序如何与其配套的 iOS 应用互动。\n\n- **Independent Apps** （独立应用）不需要 iOS 配套应用即可正常运行。用户可以选择安装 iOS 应用、watchOS 应用或同时安装两者。\n- **Dependent Apps** （从属应用）依靠 iOS 配套应用才能正常运行；仅在 watchOS 应用需要与 iOS 应用互动时才创建从属应用。用户必须使用其 iOS 应用购买并安装从属的 watchOS 应用。\n\n> 在 watchOS 5 和更低版本中，所有 watchOS 应用程序都是从属应用。\n\n## Apple Watch 上的 App Store\n\nwatchOS 6 上提供适用于 Apple Watch 的 App Store，让用户可以直接在 Apple Watch 上轻松探索、浏览、搜索和安装 watchOS app。使用 Siri、听写或涂写进行搜索，或者通过轻点产品页面链接，直接进入产品页面。\n\n{% image /assets/xaoxuu/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png width:180px bg:white padding:16px %}\n\n系统会为独立和从属应用直接将 watchOS 应用程序下载并安装到 Apple Watch。\n\n## Apple Watch 人机界面指南\n\nApple Watch 设计为可穿戴，因此用户界面适合穿戴者使用，并为他们带来轻巧，反应灵敏且高度个性化的体验。人们经常使用 watchOS 应用程序的相关体验（例如复杂功能、通知和 Siri 交互），而不是使用应用程序本身。创造出色的 watchOS 体验意味着既要设计应用程序，又要设计快速，信息丰富的元素，使人们能够以适合自己的方式访问您的内容。最有用的应用通常：\n\n- 使用复杂功能可以在表盘上提供少量可能动态的信息，使人们可以一目了然地查看信息\n- 使用通知传递及时的高价值信息并采取重要行动\n- 帮助人们使用 Siri 获取信息并执行任务\n- 如有必要，请在应用程序体验中提供更多详细信息和功能\n\n\n{% image /assets/xaoxuu/mirror/apple/design/human-interface-guidelines/watchos/watchOS-hero.svg width:320px bg:white padding:16px %}\n\n<br>\n\n{% note color:blue 图片来源声明 本文挖了坑但是许久没有填上，直到 watchOS 7 都要发布了，最后决定放弃填坑，文章封面和文中的部分插图来源于苹果官方文档。 %}\n\n{% folding 附：议程安排 %}\n\n{% image /assets/xaoxuu/blog/2019-1006fb@2x.jpg width:400px bg:#F3F2F7 padding:16px %}\n\n苹果上海设计开发加速器地点在源深体育中心地铁站4出口处，三座非常低调没有任何招牌的建筑，绕着走了一圈才找到A座二楼入口的门。内部环境如媒体图片一样，室内禁止私自拍照，只有这张门票留作纪念喽。\n\n{% image /assets/xaoxuu/blog/2019-1006fc@2x.jpg width:400px bg:#857E74 padding:16px %}\n\n{% endfolding %}\n","tags":["iOS","设计开发加速器"],"categories":["技术加油站"]},{"title":"使用链式语法打造一个 ObjC 安全的对象类型转换库","url":"/blog/20190829/","content":"\n我就职过的公司，都出现过不止一次因为后台实际数据类型和文档不一致导致的程序线上崩溃问题。原则上即使服务器离线了，app 都不应该直接闪退，所以 app 应当具有对服务器异常情况进行处理的能力。使用 ValueX 可以有效避免后台返回数据类型异常导致的程序崩溃。\n\n<!-- more -->\n\n{% link https://github.com/xaoxuu/ValueX/ %}\n\n## 异常场景\n\n- 场景1： NSString 类型变成 NSNull\n- 场景2： nil 变成 `@\"<null>\"` 值\n- 场景3： userId 不确定是 NSString 还是 NSNumber\n- 场景4： NSDictionary 中嵌套的容器变成了 Json 字符串格式\n\n## 问题抽象\n\n- 实际类型与定义类型不符\n- 实际类型与期望类型不一致\n\n## 设计接口\n\n假如我得到一个值 `NSString *obj`，实际上可能是 NSNull ，可能是 NSNumber ，可能是空数据的 `@\"<null>\"` 或者 `@\"(null)\"` 等各种表述。那么我需要确保 `NSSafeString(obj)` 的结果一定是 NSString 类型的值，如果是空数据，就应该是 nil。如果是 `@123` 这样的数字，那么应该得到 `@\"123\"` 这样的字符串。\n\n如果是 json 数据，它可能以 NSData 类型存在，可能以 Json 字符串 NSString 类型存在，可能以 NSArray 或者 NSDictionary 对象形式存在。我需要的是我要什么类型就能直接获取。例如 `ValueX(obj).stringValue` 就得到这个数据的 Json 字符串，`ValueX(obj).dictionaryValue` 就得到这个数据的字典对象。\n\n所以这个库就分为两部份工作，一部分是将实际类型与定义类型一致化；第二部分是将已知类型转换成它能够转换的其他类型。\n\n### 类型安全\n\n针对 ObjC 中常用的 6 种数据类型 NSString、NSNumber、NSData、NSArray、NSSet、NSDictionary 一一进行判断，写出6个函数：\n\n```objc 得到安全类型：\nFOUNDATION_EXTERN NSString * __nullable NSSafeString(id obj);\nFOUNDATION_EXTERN NSNumber * __nullable NSSafeNumber(id obj);\nFOUNDATION_EXTERN NSData * __nullable NSSafeData(id obj);\nFOUNDATION_EXTERN NSArray * __nullable NSSafeArray(id obj);\nFOUNDATION_EXTERN NSSet * __nullable NSSafeSet(id obj);\nFOUNDATION_EXTERN NSDictionary * __nullable NSSafeDictionary(id obj);\n```\n\n确保从这些函数出来的值是与定义类型一致的值。\n\n\n### 类型转换\n\n即使拿到的值与定义类型一致，有时候我们要用的可能又是其他类型。\n\n```objc 数据类型转换函数：\nFOUNDATION_EXTERN VXObject *ValueX(id <VXConvertable>obj);\n```\n\n确保 VXObject 类型可以通过点语法直接得到原数据所能够转换的其他类型。VXObject 是一种中间类型，针对上述 6 种数据类型，每一种可以转换成其他哪些类型进行一一判断。\n\n其中，NSNumber 只可以转换为 NSString、NSData，遵循 VXConvertable 协议。表示数字的 NSString，可以转换成 NSNumber，表示 Json 的字符串可以转换成对应的 NSArray 或者 NSDictionary，遵守 VXConvertableData 协议。反过来 NSArray、NSSet 或者 NSDictionary 则遵守 VXConvertableObject 协议。\n\n\n```objc\n@interface NSString (VXObject) <VXConvertableData>\n@end\n@interface NSNumber (VXObject) <VXConvertable>\n@end\n@interface NSData (VXObject) <VXConvertableData>\n@end\n@interface NSArray (VXObject) <VXConvertableObject>\n@end\n@interface NSSet (VCObject) <VXConvertableObject>\n@end\n@interface NSDictionary (VXObject) <VXConvertableObject>\n@end\n```\n\n它们的协议内容是：\n```objc\n@protocol VXConvertable <NSObject>\n- (VXObject *)vx;\n@end\n\n@protocol VXConvertableObject <VXConvertable>\n- (VXObject *)vxWithOptions:(NSJSONWritingOptions)opt;\n@end\n\n@protocol VXConvertableData <VXConvertable>\n- (VXObject *)vxWithOptions:(NSJSONReadingOptions)opt;\n@end\n```\n\n就按照这个思路进行开发，实现的代码就不再赘述了。\n\n{% link https://xaoxuu.com/wiki/valuex/ %}\n","tags":["iOS","链式语法","开源库","ObjC","ValueX"],"categories":["设计开发"]},{"title":"设计一个样式和逻辑分离的 HUD 库","url":"/blog/20190827/","content":"\n在写「ProHUD」之前我已经在「AXKit」中实现了原生控件快速构造方法、为公司写了 ObjC 版的可定制化 HUD、Swift 版的开源的 NoticeBoard（通知横幅）。ProHUD 诞生的意义就在于取代这些不那么完善的 HUD。\n\n<!-- more -->\n\n**这是一个简单易用且完全可定制化的 HUD**\n\nProHUD = Toast（通知横幅） + Alert（ProgressHUD、弹窗） + ActionSheet（操作表）\n\n## 特性\n\n1. 用相似的接口调用 **Toast**、**Alert**、**Guard** 组件。\n2. 程序初始化时配置自定义 UI 样式，快速调用。\n3. 用简便的方法拿到已发布的实例，避免重复发布实例。\n4. 可对已发布的实例进行数据更新。\n5. 横竖屏和 iPad 布局优化。\n6. 易于扩展，可以很方便的添加任意控件，并处理好布局。\n7. 可对所有实例监听消失事件。\n\n### Toast - 顶部浮动通知条\n1. 多个 Toast 并存策略（平铺）。\n2. 只接收一个点击事件。\n3. 可以预先对不同的场景配置不同的默认值（图标、持续时间）。\n\n### Alert - 页面中心弹窗\n1. 多个 Alert 并存策略（具有景深效果的堆叠）。\n2. 可以预先对不同的场景配置不同的默认值（图标、持续时间）。\n3. 可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。\n4. 对已发布的实例进行文本和按钮的更新，包括新增、修改、删除文本和按钮。\n5. 强制退出按钮（防止超时导致页面卡死）。\n\n### Guard - 页面底部操作表\n1. 快速创建具有预先配置的默认样式的文本元素（标题、副标题、正文）。\n2. 可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。\n\n\n## 设计思路\n\n### UI与逻辑分离\n\n这个库采用配置 UI 和调用接口分离的设计，这种思路借鉴了和而泰公共库，我认为这是一种调用比传统 UI 库方便的同时可定制化能力也比传统 UI 库强大的设计思路。\n\n简单来说，就是你在 AppDelegate 中告诉 ProHUD，你要的横幅、弹窗、操作表分别是什么样的，如果参数是什么什么，就怎么展示 UI。然后调用的地方就不需要设置 UI 了，只需要专注于数据。\n\n```swift 例如弹出一个正在加载的提示框：\nAlert.push(scene: .loading, title: \"正在加载\", message: \"请稍等片刻\")\n```\n\n这样就发出了一个弹窗，而弹窗的样式，则在 AppDelegate 中以及预先配置好了。我使用了 `scene` 这个灵活的参数，你可以自己扩展场景。\n\n```swift 为程序的弹窗场景设置模板，实现快速调用：\nextension ProHUD.Scene {\n    static var confirm: ProHUD.Scene {\n        var scene = ProHUD.Scene(identifier: \"confirm\")\n        scene.image = UIImage(named: \"ProHUDMessage\")\n        return scene\n    }\n    static var delete: ProHUD.Scene {\n        var scene = ProHUD.Scene(identifier: \"delete\")\n        scene.image = UIImage(named: \"ProHUDTrash\")\n        scene.title = \"确认删除\"\n        scene.message = \"此操作不可撤销\"\n        return scene\n    }\n    static var buy: ProHUD.Scene {\n        var scene = ProHUD.Scene(identifier: \"buy\")\n        scene.image = UIImage(named: \"ProHUDBuy\")\n        scene.title = \"确认付款\"\n        scene.message = \"一旦购买拒不退款\"\n        return scene\n    }\n}\n```\n\n一个 scene 就可以理解成一套模板。\n\n### 动态更新\n\nProHUD 另一个优势就是动态更新，对于已经发布的实例，你可以方便的去更新内容。\n\n```swift 示例1：获取刚才弹出的Loading，把它更新为加载成功。\nAlert.find(\"loading\", last: { (a) in\n    a.update { (vm) in\n        vm.scene = .success\n        vm.title = \"同步成功\"\n        vm.message = nil\n    }\n})\n```\n\n```swift 示例2：获取刚才弹出的Loading，把它更新为加载失败，并增加重试按钮。\nAlert.find(\"loading\", last: { (a) in\n    a.update { (vm) in\n        vm.scene = .error\n        vm.title = \"同步失败\"\n        vm.message = \"请检查网络是否连接\"\n        vm.add(action: .default, title: \"重试\") {\n            // do something\n        }\n        vm.add(action: .cancel, title: \"取消\", handler: nil)\n    }\n})\n```\n\n### 极端场景\n\n很多库没有多实例管理，很容易出现简单粗暴的视图重叠现象，ProHUD 针对不同场景做了不同的优化，对于横幅来说，可以平铺显示，像系统的通知中心一样，你可以拖拽向上移除。对于弹窗来说，我给底层的弹窗做了景深效果处理，使得看起来不像是 BUG。\n\n\n{% link https://xaoxuu.com/wiki/prohud/ %}\n","tags":["iOS","开源库","Swift","ProHUD"],"categories":["设计开发"]},{"title":"心率管家的设计与开发（上篇：整体流程）","url":"/blog/20190723/","content":"\n近期开发并上架了新版心率管家 App（仅 iOS 端），专业版不定期限免，欢迎下载体验。本文将从设计、开发、上架等每个步骤和细节进行分享，也包含部分模块源码。\n\n\n<!-- more -->\n\n{% link https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1 心率管家 %}\n\n## 立项\n\n### 确定需求\n\n立项的初衷是满足随时测心率的需求（没有智能手环手表的人群），App 核心功能就是测量心率，围绕这个功能展开的是测量时更多细节的记录、对已有数据的筛选。再往深度挖掘的是数据分析、健康预测。\n\n### 市场考察\n\n虽然 AppStore 已有，但是无一例外都特别丑，要么收费要么有广告，所以不如自己做一个。\n\n### 测量原理\n\n**光电容积脉搏波描记法（PPG）**\n\n是追踪可见光（通常为绿光）在人体组织中的反射。它具备一个可见光光源来照射皮肤，再使用光电传感器采集被皮肤反射回来的光线。PPG 有两种模式，透射式和反射式，像一般的手环手表这样，光源和传感器在同一侧的，就是反射式；而医院中常见的夹在指尖上的通常是透射式的，即光源和传感器在不同侧。 皮肤本身对光线的反射能力是相对稳定的，但是心脏泵血使得血管容积周期性地变化，导致反射光也呈现出周期性的波动值，特别是在指尖这种毛细血管非常丰富的部位，这种周期性的波动很容易被观察到。\n\nWikipedia: [#Photoplethysmogram](https://en.wikipedia.org/wiki/Photoplethysmogram)\n\n对应到 App 上就是通过分析摄像头每一帧画面的色值，计算出颜色波动的频率，即为近似心率。\n\n### 定价策略\n\n- 付费版：价格波动，通过降价和限免吸引爬虫收录。\n- 免费版：限制了部分个性化功能，核心功能不受影响，没有任何广告。\n\n\n### 技术方案\n\n语言：Swift5\n设计模式：MVC\n路由方案：JLRoutes\n主题和UI管理：Inspire\n缓存方案：SQLite\n数据同步方案：暂定AppleHealth\n\n## 设计\n\n初期使用 Sketch 制作效果图，在后期直接在项目中进行调整，没有再更新到 Sketch 中。下面这是最终发布到 AppStore 的应用截图：\n\n{% swiper width:min %}\n![](/assets/wiki/heartmate/screenshot01.jpg)\n![](/assets/wiki/heartmate/screenshot02.jpg)\n![](/assets/wiki/heartmate/screenshot03.jpg)\n![](/assets/wiki/heartmate/screenshot04.jpg)\n![](/assets/wiki/heartmate/screenshot05.jpg)\n![](/assets/wiki/heartmate/screenshot06.jpg)\n{% endswiper %}\n\n## 开发\n\n### 心率测量组件\n\n心率测量功能开发为一个私有库，具体实现稍后补充。。。\n\n### 可定制UI\n\n使用 [Inspire](https://xaoxuu.com/wiki/inspire/) 作为主题管理器，目前暂未支持主题切换，后续更新会加入。\n\n### 快捷指令\n\n使用 JLRoutes 路由方案，目前支持 URLSchemes 启动并开始测量，可接受两个参数：\n\n```swift\n// 直接启动\nheartmatepro://record\n// 自定义补光灯亮度（亮度值 l 为浮点数，取值范围是0~1）\nheartmatepro://record?l=0.3\n// 自定义补光灯亮度和测量样本容器大小（样本容器大小 c 为正整数，取值范围是1~20）\nheartmatepro://record?l=0.1&c=10\n```\n\n免费版限制了自定义亮度，但是你依然可以通过这种方式来自定义。\n\n### ProHUD\n\n使用 [ProHUD](https://xaoxuu.com/wiki/prohud/) 来负责弹窗和操作表，包括隐私政策页面。\n\n{% swiper width:min %}\n![](/assets/wiki/heartmate/screenshot21.png)\n![](/assets/wiki/heartmate/screenshot22.png)\n![](/assets/wiki/heartmate/screenshot23.png)\n![](/assets/wiki/heartmate/screenshot24.png)\n![](/assets/wiki/heartmate/screenshot25.png)\n{% endswiper %}\n\n## 上架\n\n新建应用，填写名称、BundleId 等资料，然后在 App 页面填写描述、网址、隐私政策链接、上传截图、确定分级……\n\n待应用通过 testflight 测试无误后，打包上传。然后过几分钟 appstoreconnect 页面就可以选中刚才上传的包了，然后提交审核，第二天就审核通过。（现在 AppStore 新应用审核也太快了）\n\n{% link https://appstoreconnect.apple.com %}\n\n## 迭代\n\n### 数据价值\n\n后续迭代中会在测量详情页面下方的留白处加上【标签】、【备注】、【数据分析】模块，前两者利于检索数据，数据分析目前没有能力独自完成，计划使用第三方服务。\n\n\n### 细节\n\n**图标**\n这是一次彻底重做，所以也可以算是初版。很多细节还比较粗糙，例如图标没有经过打磨，设置列表连图标都没有。\n\n**占位图**\n很多页面在没有数据的时候也没有占位的图片，这个也会慢慢完善。\n\n**心率区间**\n心率卡片的颜色、心率卡片右上角以及归档页面心率的底部的彩色长条代表的是当前所处的心率区间，App 中并没有说明，后续迭代中也会完善这里。并且心率区间的划分需要年龄和性别，这个也会在后期进行完善。\n\n## 下篇：信号处理\n\n{% link https://xaoxuu.com/blog/20200927/ %}\n","tags":["iOS","Swift","心率"],"categories":["设计开发"]},{"title":"整理 iOS 老项目中混乱不堪的多语言翻译","url":"/blog/20171225/","content":"\n\nlinksmart 项目截止目前已经支持了 17 个国家的语言，从诞生到现在也已经经历了很多程序员的修改和维护，代码已经变得十分混乱。因为公司一直在接新的定制项目，所以也没有时间进行一次彻底的重构，只能在维护某方面的 BUG 的时候，对相关代码进行局部重构。\n\n\n<!-- more -->\n\n现在的情况是：\n\n- 同一个文本有些语言有翻译，有些语言没有翻译。\n- 有些需要使用缩进的地方，由于某种原因，并没有使用 `UIEdgeInsets` 进行缩进，而是在文本前后加空格。(⊙﹏⊙)b\n\n\n## 整理思路\n\n首先必须得找出一种合适的方法维护这些 Localizable.strings，在 Excel 里做一个总表，增加语言的时候，可以直接把英文的一列发给客户进行翻译。最大的优势是：随时可以用脚本把 Excel 里的所有语言导出成项目支持的 Localizable.strings 文件，极大提高效率。\n\n\n## 1. 补全\n\n使用 `genstrings` 命令将所有 `.m` 文件中的 LocalizedString 文本生成 Localizable.strings。\n打开终端，进入需要检测的文件夹，执行以下命令：\n\n```\nfind ./ -name \"*.m\" -print0 | xargs -0 genstrings -o ./\n```\n\n生成的这一份文件只包含所有 `.m` 文件中的国际化字符串，并不包含 plist 和 xib 中的字符串。接下来只要把这一份和原来的所有翻译合并起来去重，就得到一份最全的 key。\n\n如果也需要检测 xib、.h 文件，则执行以下命令：\n\n```\n find . -name '*.xib' -o -name '*.[mh]' -print0 | xargs -0 genstrings -o ./\n```\n\n生成的文件会存在当前目录。\n\n\n## 2. 合并去重\n\n我尝试过直接读取 Localizable.strings 文件，但提示编码错误，就暂时 copy 到 txt 文件中进行处理。\n\n> 合并的Demo：[https://github.com/xaoxuu/LocalizedTool-iOS](https://github.com/xaoxuu/LocalizedTool-iOS)\n\n\n\n## 3. 导入Excel\n\n接下来的步骤工作量有点大，就是重新把那些翻译导入 Excel 中，补全缺少的那些翻译。\n\n\n### 1. 下载，解压\n\n下载工具：[https://github.com/CatchZeng/Localizable.strings2Excel](https://github.com/CatchZeng/Localizable.strings2Excel) 。\n\n\n解压开之后把里面的两个zip也解压开\n\n### 2. 安装工具\n\n#### pyexcelerator\n\n打开命令行工具，cd到 `.../Localizable.strings2Excel-master/pyexcelerator-0.6.4.1` 文件夹，执行：\n```sh\nsudo python setup.py install\n```\n#### xld\n\ncd到 `.../Localizable.strings2Excel-master/xlrd-1.0.0` 文件夹，执行：\n```sh\nsudo python setup.py install\n```\n\n\n### 3. 使用脚本\n\ncd到 `.../Localizable.strings2Excel-master/python` 文件夹\n\n如需将Excel表格转换成Localizable.strings或者strings.xml文件，执行：\n```sh\npython LocalizableBack.py -f xxx/xxx.xls -t xxx/xxx\n```\n\n如需将Localizable.strings或者strings.xml文件转换成Excel表格，执行：\n```sh\npython Localizable.py -f xxx/ -t xxx/\n```\n\n\n> 工具的链接在：[GitHub/CatchZeng](https://github.com/CatchZeng/Localizable.strings2Excel) 感谢作者编写了如此方便的工具！\n> 更多详细使用脚本请阅读 [官方README文件](https://github.com/CatchZeng/Localizable.strings2Excel) 。\n\n\n## 附：检测中文字符串\n\n如果项目的默认语言是中文，而且前期没有用多语言写法，可以使用 Xcode 的替换功能，将中文字符串替换成多语言的写法：\n\n搜索：\n```\n(@\"[^\"]*[\\u4E00-\\u9FA5]+[^\"\\n]*?\")\n```\n\n替换为：\n```\nNSLocalizedStringFromTable($0, @\"Localizable\", nil)\n```\n","tags":["iOS","Code"],"categories":["解决方案"]},{"title":"在 iOS 开发中，如何实现只推迟而不会重复执行的函数","url":"/blog/20171109/","content":"\n在 iOS 开发中，如果想推迟执行一段代码，使用 `dispatch_after` 函数可以轻易实现，但有时候我们想在它推迟的期间再次推迟，直到最终不再推迟的时候，才真正的被调用一次。这就需要每次先将旧的事件取消，然后重新设置。\n\n<!-- more-->\n\n**自动消失的视图**\n\n例如当用户的某种操作点击一下屏幕就发出一条状态栏消息，消息在2秒后消失，在消失前如果用户又触发了这个条件，理应是在这次触发的2秒后消失，如果简单的使用 `dispatch_after` 函数进行延迟，结果会是在第一次点击的2秒后消失，可能你在1.5秒的时候又点击了一下，但是只过了0.5秒就消失了。\n\n**降低服务器访问次数**\n\n例如：用户修改了信息的30秒后上传至服务器。那么如果用户修改了姓名，然后30秒内又修改了头像，在修改了头像后的30秒内又修改了性别等等。我们希望的并不是每次修改就上传一次，而是在用户最后修改完所有信息之后，看起来似乎不准备继续修改了的时候，再上传至服务器。使用推迟而不重复执行的方法可以在避免多次访问服务器的同时及时地上传用户修改后的信息。\n\n## 便捷的方案：GCD\n\n实现的方法很简单，步骤如下：\n\n1. 获取到函数\n2. 取消函数\n3. 重新赋值或启动\n\n\n### 使用 Objective-C\n\n在 Objective-C 中，将要执行的代码保存成 `dispatch_block_t` 的静态类型变量，取出这个静态变量，然后使用 `dispatch_block_cancel()` 取消，然后重新设置它的值，然后调用 `dispatch_after`。\n\n```objc\n- (void)delayTest{\n    static dispatch_block_t task;\n    if (task) {\n        dispatch_block_cancel(task);\n    }\n    task = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^{\n        // 被推迟执行的代码\n    });\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC)), dispatch_get_main_queue(), task);\n}\n\n```\n\n{% border 也可以使用 AXKit 实现 %}\n\n也可以使用 [AXKit](https://github.com/xaoxuu/AXKit/) 封装好的方法，将要执行的代码保存成 `ax_dispatch_operation_t` 的静态类型变量，使用 `ax_dispatch_cancel_operation()` 取消之前的任务，然后使用 `ax_dispatch_cancellable()` 再次赋值。\n\n```objc\n- (void)delayTest2{\n    static ax_dispatch_operation_t animationToken;\n    ax_dispatch_cancel_operation(animationToken);\n    animationToken = ax_dispatch_cancellable(duration, dispatch_get_main_queue(), ^{\n        // 被推迟执行的代码\n    });\n}\n```\n\n{% endborder %}\n\n\n### 使用 Swift\n\n创建静态变量 `static var task = DispatchWorkItem.init{}`，先取消 `task.cancel()`，再赋值 `DispatchWorkItem`，然后使用 `DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task)` 延迟调用。\n\n```swift\ninternal static var task = DispatchWorkItem.init {}\n\ninternal static func hide(duration: TimeInterval) {\n    task.cancel()\n    task = DispatchWorkItem.init(block: {\n        // 被推迟执行的代码\n    })\n    DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task)\n}\n```\n\n## 更高效的方案：定时器\n\n上述方案存在一定的性能问题，在低频触发时没有问题，但是在每一秒都要触发一次或多次的时候，显然不合适。这时候可以设置一个定时器，通过定时器延迟调用，每次触发的时候只是修改定时器的 fireDate 属性，实现步骤不再赘述。\n","tags":["GCD","ObjC","Swift"],"categories":["解决方案"]},{"title":"iOS 接入 Strava 分享模块（下篇：StravaSDK）","url":"/blog/20170628/","content":"\n[StravaKit](https://github.com/StravaKit/StravaKit) 是一个比较新而且代码比较规范的第三方SDK，但是目前还没有上传功能（详见 [todo](https://github.com/StravaKit/StravaKit/blob/master/TODO.md)）。所以我不得已对 `StravaKit 0.9.5` 增加上传功能，并进行一些简单封装和改编，使之能够植入到公司项目中。由于时间有限，我只增加了上传fit文件的功能，并且使用了第三方框架 `Alamofire`，所以需要在项目中导入 `Alamofire`。\n\n\n<!-- more -->\n\n## 开始使用\n\nStravaSDK 下载：[StravaSDK.zip](https://github.com/xaoxuu/StravaSDK)\n\n\n## 配置环境\n\n需要三个参数：`ClientId`、`ClientSecret` 和app的 `URLSchemes`。其中前两个是在 [Strava平台](https://labs.strava.com/developers/) 注册一个app的时候会给出。\n示例代码：\n\n```swift\nStravaSDK.config(clientId: \"18583\", clientSecret: \"a05fde98a830effde2e0f84cc39d76b040d4d67e\", appSchemes: \"hitfit\")\n```\n\n\n\n## 授权\n\n获取授权\n```swift\nStravaSDK.authorize()\n```\n\n取消授权\n```swift\nStravaSDK.deauthorize()\n```\n\n查询是否已授权\n```swift\nStravaSDK.isAuthorized\n```\n\n\n## 上传活动数据（.fit）\n\n```swift\nStravaSDK.uploadActivity(path: \".../test.fit\", type: \"run\", name: \"Afternoon Run\") { (response, error) in\n\n}\n```\n","tags":["iOS","StravaSDK"],"categories":["解决方案"]},{"title":"iOS 接入 Strava 分享模块（上篇：FitSDK）","url":"/blog/20170622/","content":"\n[fit](https://developer.garmin.com/fit/?resources/fit/) 是一种文件协议，体积小巧，多用于可穿戴设备记录、传输运动与健康数据。官方提供了 C、C++、Java 语言的 SDK 和非常详细的使用文档。因此在 iOS 端接入 fit 就需要在 C 或 C++ 的 SDK 基础上进行一点面向对象的封装。\n\n<!-- more -->\n\n## 认识 Fit\n\n我使用的 C 语言的 SDK，官方有示例 demo，在 `fit_mgr` 文件中提供了一些示例，这些代码未必全部都要用到。创建一个最简单的 `.fit` 文件的流程是：\n\n\n### 写 fileid\n\n```c\nvoid fit_transaction_file(FIT_FILE type, FIT_MANUFACTURER manufacturer, FIT_UINT16 product, FIT_UINT32Z serial_number){\n    // Write file id message.\n    FIT_UINT8 local_mesg_number = 0;\n    FIT_FILE_ID_MESG file_id;\n    Fit_InitMesg(fit_mesg_defs[FIT_MESG_FILE_ID], &file_id);\n\n    // @xaoxuu: type FIT_FILE_ACTIVITY = 4 活动数据\n    file_id.type = type;\n    // @xaoxuu: 厂商\n    file_id.manufacturer = manufacturer;\n    // @xaoxuu: 产品\n    //        file_id.product_name\n    file_id.product = product;\n    // @xaoxuu: 序列号\n    file_id.serial_number = serial_number;\n    // @xaoxuu: 生产日期\n    //        time_t now;\n    //        time(&now);\n    //        file_id.time_created = now;\n\n    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FILE_ID], FIT_FILE_ID_MESG_DEF_SIZE, static_fp);\n    WriteMessage(local_mesg_number, &file_id, FIT_FILE_ID_MESG_SIZE, static_fp);\n}\n\nvoid fit_transaction_field_desc() {\n    // Write a Field Description\n    FIT_UINT8 local_mesg_number = 1;\n    FIT_FIELD_DESCRIPTION_MESG field_description_mesg;\n\n    Fit_InitMesg(fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], &field_description_mesg);\n    field_description_mesg.developer_data_index = 0;\n    field_description_mesg.field_definition_number = 0;\n    field_description_mesg.fit_base_type_id = FIT_BASE_TYPE_UINT16;\n    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], FIT_FIELD_DESCRIPTION_MESG_DEF_SIZE, static_fp);\n    WriteMessage(local_mesg_number, &field_description_mesg, FIT_FIELD_DESCRIPTION_MESG_SIZE, static_fp);\n}\n```\n\n### 写 record\n\n```c\n// 写入Record Defenition\nvoid fit_transaction_record_def(){\n    FIT_UINT8 local_mesg_number = 2;\n    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_RECORD], FIT_RECORD_MESG_DEF_SIZE, static_fp);\n}\n// 循环写入record数据\nvoid fit_transaction_record_msg(unsigned int timestamp, int position_lat, int position_long, unsigned int distance, unsigned short altitude, unsigned short speed, unsigned char heart_rate){\n    //Record message\n    FIT_UINT8 local_mesg_number = 2;\n    FIT_RECORD_MESG record;\n\n    Fit_InitMesg(fit_mesg_defs[FIT_MESG_RECORD], &record);\n    record.timestamp = timestamp;\n    record.position_lat = position_lat;\n    record.position_long = position_long;\n    record.distance = distance;\n    record.altitude = altitude;\n    record.speed = speed;\n    record.heart_rate = heart_rate;\n    WriteMessage(local_mesg_number,&record,FIT_RECORD_MESG_SIZE,static_fp);\n}\n```\n\n\n\n## 开始封装\n\n### 设计模型\n\nFitActivity.h\n\n```objc\n//\n//  FitAcitvity.h\n//  FitSDK\n//\n//  Created by xaoxuu on 04/07/2017.\n//  Copyright © 2017 xaoxuu. All rights reserved.\n//\n\n#import <Foundation/Foundation.h>\n\n@class FitActivityRecord;\ntypedef NS_ENUM(NSUInteger, FitActivityType) {\n    FitActivityTypeWalk = 11, // 枚举值等于FIT_SPORT值\n    FitActivityTypeRun = 1,\n    FitActivityTypeRide = 2,\n    FitActivityTypeSwim = 5,\n    FitActivityTypeHike = 17,\n};\n\n@interface FitActivity : NSObject\n\n// @xaoxuu: fit 文件路径\n@property (copy, readonly, nonatomic) NSString *path;\n\n// @xaoxuu: 活动名\n@property (copy, nonatomic) NSString *name;\n\n// @xaoxuu: 活动类型\n@property (assign, nonatomic) FitActivityType type;\n\n// @xaoxuu: 活动类型\n@property (copy, readonly, nonatomic) NSString *typeString;\n\n// @xaoxuu: records\n@property (strong, nonatomic) NSMutableArray<FitActivityRecord *> *records;\n\n/**\n 添加一条record\n\n @param record record\n */\n- (void)addRecord:(void (^)(FitActivityRecord *aRecord))record;\n\n@end\n\n@interface FitActivityRecord : NSObject\n\n// @xaoxuu: timestamp\n@property (assign, nonatomic) unsigned int timestamp;\n\n// @xaoxuu: position_lat\n@property (assign, nonatomic) int position_lat;\n\n// @xaoxuu: position_long\n@property (assign, nonatomic) int position_long;\n\n// @xaoxuu: distance\n@property (assign, nonatomic) unsigned int distance;\n\n// @xaoxuu: altitude\n@property (assign, nonatomic) unsigned short altitude;\n\n// @xaoxuu: speed\n@property (assign, nonatomic) unsigned short speed;\n\n// @xaoxuu: heart_rate\n@property (assign, nonatomic) unsigned char heart_rate;\n\n@end\n```\n\nFitActivity.m\n\n```objc\n//\n//  FitAcitvity.m\n//  FitSDK\n//\n//  Created by xaoxuu on 04/07/2017.\n//  Copyright © 2017 xaoxuu. All rights reserved.\n//\n\n#import \"FitAcitvity.h\"\n\n@implementation FitActivity\n\n- (instancetype)init {\n    if (self = [super init]) {\n        _records = [NSMutableArray array];\n        self.type = FitActivityTypeWalk;\n    }\n    return self;\n}\n\n\n- (void)setType:(FitActivityType)type{\n    _type = type;\n\n    switch (type) {\n        case FitActivityTypeWalk:\n            _typeString = @\"walk\";\n            break;\n        case FitActivityTypeRun:\n            _typeString = @\"run\";\n            break;\n        case FitActivityTypeRide:\n            _typeString = @\"ride\";\n            break;\n        case FitActivityTypeSwim:\n            _typeString = @\"swim\";\n            break;\n        case FitActivityTypeHike:\n            _typeString = @\"hike\";\n            break;\n\n    }\n}\n\n\n- (void)setName:(NSString *)name{\n    _name = name;\n    _path = [self pathWithName:name];\n}\n\n- (void)addRecord:(void (^)(FitActivityRecord *aRecord))record{\n    if (record) {\n        FitActivityRecord *rec = [FitActivityRecord new];\n        record(rec);\n        [self.records addObject:rec];\n    }\n}\n\n- (NSString *)pathWithName:(NSString *)name{\n    NSString *path = [[NSTemporaryDirectory() stringByAppendingPathComponent:@\"com.xaoxuu.fitsdk\"] stringByAppendingPathComponent:name];\n    path = [path stringByAppendingPathExtension:@\"fit\"];\n    // create dir if not exist\n    NSFileManager *fm = [NSFileManager defaultManager];\n    NSString *dir = path.stringByDeletingLastPathComponent;\n    BOOL result = [fm createDirectoryAtPath:dir withIntermediateDirectories:YES attributes:nil error:nil];\n    if (!result) {\n        NSLog(@\"can not create the directory at path %@\",dir);\n    }\n    return path;\n}\n\n@end\n\n@implementation FitActivityRecord\n\n- (instancetype)init{\n    if (self = [super init]) {\n        _timestamp = 702940946;\n        _position_lat = 0;\n        _position_long = 0;\n        _distance = 0;\n        _altitude = 0;\n        _speed = 0;\n        _heart_rate = 0;\n    }\n    return self;\n}\n\n@end\n```\n\n\n\n### 封装接口\n\nFitSDK.h\n\n```objc\n//\n//  FitSDK.h\n//  FitSDK\n//\n//  Created by xaoxuu on 04/07/2017.\n//  Copyright © 2017 xaoxuu. All rights reserved.\n//\n\n#import <Foundation/Foundation.h>\n#import \"FitAcitvity.h\"\n\n@interface FitSDK : NSObject\n\n/**\n 创建一个活动数据fit文件\n\n @param activity 活动数据\n @return 活动数据模型\n */\n+ (FitActivity *)createActivity:(void (^)(FitActivity *activity))activity;\n\n@end\n\n```\n\nFitSDK.m\n\n```objc\n//\n//  FitSDK.m\n//  FitSDK\n//\n//  Created by xaoxuu on 04/07/2017.\n//  Copyright © 2017 xaoxuu. All rights reserved.\n//\n\n#import \"FitSDK.h\"\n#import \"fit_mgr.h\"\n\n@implementation FitSDK\n\n+ (FitActivity *)createActivity:(void (^)(FitActivity *activity))activity{\n    FitActivity *act = [FitActivity new];\n    if (activity) {\n        activity(act);\n    }\n    [self createActivityWithModel:act];\n    return act;\n}\n\n\n+ (void)createActivityWithModel:(FitActivity *)activity{\n    // @xaoxuu: fit file\n    const char *fp = [activity.path cStringUsingEncoding:NSUTF8StringEncoding];\n    fit_transaction(fp, activity.type, ^{\n        [activity.records enumerateObjectsUsingBlock:^(FitActivityRecord * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n            fit_transaction_record_msg(obj.timestamp, obj.position_lat, obj.position_long, obj.distance, obj.altitude, obj.speed, obj.heart_rate);\n        }];\n    });\n}\n\n@end\n\n```\n\n\n\n## 使用\n\n```objc\nFitActivity *activity = [FitSDK createActivity:^(FitActivity *activity) {\n    activity.name = @\"test\";\n    activity.type = FitActivityTypeRun;\n    for (int i = 0; i<100; i++) {\n        [activity addRecord:^(FitActivityRecord *aRecord) {\n            aRecord.timestamp = [[NSDate date] timeIntervalSince1970] - 631065600;\n            aRecord.position_lat = 495280430+i*1000;\n            aRecord.position_long = -872696681-i*1500;\n            aRecord.distance = 2+i/100;\n            aRecord.altitude = 287.2+i;\n            aRecord.speed = 0.29+i/50;\n            aRecord.heart_rate = 68+i/4;\n        }];\n    }\n}];\n// activity.path就是生成的fit文件路径\nNSLog(@\"%@\", activity.path);\n```\n","tags":["iOS","FitSDK"],"categories":["解决方案"]},{"title":"如何封装自己的 iOS Framework 静态库","url":"/blog/20161106/","content":"\n像工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库。\n\n<!-- more -->\n\n## 步骤\n\n1. 创建工程，最好是起名为 `xxxDemo` 例如 `AXKitDemo`，然后新建一个 target 名为 `AXKit`，并把原来的工程改名为 `AXKit`。（为了方便在 demo 中调试静态库）\n2. 新建一个 target ，选择类型为 `framework`。\n3. 在 `framework` 中创建需要封装的类，写好代码。\n4. 在 `Build Setting` 里更改参数，`Math-O Type` 为 `Static Library`。\n5. 在 `Build Phases -> Headers` 里将需要暴露出来的头文件从 `Project` 移动到 `Public`。\n6. 添加一个 `Aggregate` 的 target，并添加运行脚本。目的是把编译出来的真机版和模拟器版的 `framework` 合并。\n7. 模拟器编译一下，真机编译一下，然后 `Aggregate` 编译一下，然后在项目的 `Products` 文件夹里就有了最终生成的静态库。\n\n## 自动合成脚本\n\n`Aggregate` 的 Run Script 脚本：\n\n```\nif [ \"${ACTION}\" = \"build\" ]\nthen\nINSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework\n\nDEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework\n\nSIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework\n\n\nif [ -d \"${INSTALL_DIR}\" ]\nthen\nrm -rf \"${INSTALL_DIR}\"\nfi\n\nmkdir -p \"${INSTALL_DIR}\"\n\ncp -R \"${DEVICE_DIR}/\" \"${INSTALL_DIR}/\"\n#ditto \"${DEVICE_DIR}/Headers\" \"${INSTALL_DIR}/Headers\"\n\nlipo -create \"${DEVICE_DIR}/${PROJECT_NAME}\" \"${SIMULATOR_DIR}/${PROJECT_NAME}\" -output \"${INSTALL_DIR}/${PROJECT_NAME}\"\n\n#open \"${DEVICE_DIR}\"\n#open \"${SRCROOT}/Products\"\nfi\n```\n","tags":["iOS","Framework"],"categories":["解决方案"]},{"title":"如何从 UIImageView 指定的坐标点取色？","url":"/blog/20160914/","content":"\n开发中有时候会遇到这样的需求，要给用户一个取色板，让用户从中自由地选取颜色，用来改变主题或者控制灯具的颜色等。这时候我们就需要获取一个视图的指定坐标的颜色值。\n\n<!-- more -->\n\n有时候我们可能会需要一个取色器，例如我的蓝牙灯项目，让用户从一个取色器中随意取色：\n\n```objc\n#import <CoreGraphics/CoreGraphics.h>\n\n#import \"UIImage+ColorAtPixel.h\"\n\n@implementation UIImage (ColorAtPixel)\n\n- (UIColor *)colorAtPixel:(CGPoint)point {\n    // Cancel if point is outside image coordinates\n    if (!CGRectContainsPoint(CGRectMake(0.0f, 0.0f, self.size.width, self.size.height), point)) {\n        return nil;\n    }\n\n\n    // Create a 1x1 pixel byte array and bitmap context to draw the pixel into.\n    // Reference: http://stackoverflow.com/questions/1042830/retrieving-a-pixel-alpha-value-for-a-uiimage\n    NSInteger pointX = trunc(point.x);\n    NSInteger pointY = trunc(point.y);\n    CGImageRef cgImage = self.CGImage;\n    NSUInteger width = CGImageGetWidth(cgImage);\n    NSUInteger height = CGImageGetHeight(cgImage);\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    int bytesPerPixel = 4;\n    int bytesPerRow = bytesPerPixel * 1;\n    NSUInteger bitsPerComponent = 8;\n    unsigned char pixelData[4] = { 0, 0, 0, 0 };\n    CGContextRef context = CGBitmapContextCreate(pixelData,\n                                                 1,\n                                                 1,\n                                                 bitsPerComponent,\n                                                 bytesPerRow,\n                                                 colorSpace,\n                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    CGColorSpaceRelease(colorSpace);\n    CGContextSetBlendMode(context, kCGBlendModeCopy);\n\n    // Draw the pixel we are interested in onto the bitmap context\n    CGContextTranslateCTM(context, -pointX, -pointY);\n    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, (CGFloat)width, (CGFloat)height), cgImage);\n    CGContextRelease(context);\n\n    // Convert color values [0..255] to floats [0.0..1.0]\n    CGFloat red   = (CGFloat)pixelData[0] / 255.0f;\n    CGFloat green = (CGFloat)pixelData[1] / 255.0f;\n    CGFloat blue  = (CGFloat)pixelData[2] / 255.0f;\n    CGFloat alpha = (CGFloat)pixelData[3] / 255.0f;\n    return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];\n}\n\n@end\n```\n\n## 开始优化\n\n```objc\n/**\n 从圆形范围内的指定点获取UIColor对象，并在block中执行操作\n\n @param point      指定坐标点\n @param completion 取色完成后执行的block\n */\n- (void)ax_getColorFromCircleWithPoint:(CGPoint)point completion:(void (^)(UIColor *color))completion;\n```\n\n调用起来应该是这样的：\n\n```objc\n// 已知imageView、point\n[imageView ax_getColorFromCircleWithPoint:point completion:^(UIColor *color){\n  // 在这里直接用color\n}];\n```\n\n因为取色板一般是圆形的，如果坐标点超出了圆形但依然在imageView的frame内，可能会返回一些用户不期望的结果，用block巧妙地解决了这一问题，超出范围就不再有回调。如果你认为我的封装使用起来更加方便，可以继续阅读下面详细内容。\n\n\n\n## 开始使用\n\n推荐CocoaPods方式，在podfile中添加一行：\n\n```sh\npod 'AXKit'\n```\n然后在终端中执行 `pod install` 即可完成安装。\n\nAXKit的全局头文件是：\n\n```objc\n// 通过CocoaPods或静态库方式安装\n#import <AXKit/AXKit.h>\n// 通过手动方式\n#import \"AXKit.h\"\n```\n\n\n\n## 接口声明\n\n### 从指定点获取RGBA值\n\n```objc\n- (void)ax_getRed:(nullable CGFloat *)red green:(nullable CGFloat *)green blue:(nullable CGFloat *)blue alpha:(nullable CGFloat *)alpha withPoint:(CGPoint)point;\n\n// 调用起来是这样的：\n// 已知imageView、point\nCGFloat r,g,b,a;\n[imageView ax_getRed:&r green:&g blue:&b alpha:&a withPoint:point];\n// 然后r/g/b/a就有了值\n```\n\n需要自己创建变量，然后把地址传进去，然后才能用，不推荐直接使用。\n\n### 从指定点获取RGBA值，并在block中执行操作\n\n加了一个block，调用起来就方便许多：\n\n```objc\n- (void)ax_getRGBAWithPoint:(CGPoint)point completion:(void(^)(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha))completion;\n\n// 调用起来是这样的：\n// 已知imageView、point\n[imageView ax_getRGBAWithPoint:point completion:^(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha){\n  // 在这里直接用red/green/blue/alpha\n}];\n```\n\n优点是不需要自己创建变量，直接调用方法，在block回调里直接获得red/green/blue/alpha值。\n\n\n> 但是，很多时候，我们用的取色器是圆形的，就需要再进行一点封装。\n\n\n### 从圆形范围内的指定点获取RGBA值，并在block中执行操作\n\n```objc\n- (void)ax_getRGBAFromCircleWithPoint:(CGPoint)point completion:(void (^)(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha))completion;\n\n// 调用起来是这样的：\n// 已知imageView、point\n[imageView ax_getRGBAFromCircleWithPoint:point completion:^(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha){\n  // 在这里直接用red/green/blue/alpha\n}];\n```\n\n跟第2种调用方法一模一样，但是区别是超出圆形范围之后就不再执行block回调了，这是一种**安全**的做法。如果不用block方式，那么即使超出了圆形范围，也一定会返回对应的rgba值，会造成不想要的后果。\n\n> block的回调机制巧妙地解决了这个问题。\n\n如果我想直接获得一个UIColor对象呢，跟获取RGBA一样有三种方法。\n\n### 从指定点获取UIColor对象\n\n```objc\n- (nullable UIColor *)ax_getColorWithPoint:(CGPoint)point;\n\n// 调用起来是这样的：\n// 已知imageView、point\nUIColor *color = [imageView ax_getColorWithPoint:point];\n// 获得UIColor对象\n```\n\n由声明可以看出来，返回的值是一个可空类型，因此这跟第一种方法一样是**不安全**的。\n\n### 从指定点获取UIColor对象，并在block中执行操作\n\n```objc\n- (void)ax_getColorWithPoint:(CGPoint)point completion:(void(^)(UIColor *color))completion;\n\n// 调用起来是这样的：\n// 已知imageView、point\n[imageView ax_getColorWithPoint:point completion:^(UIColor *color){\n  // 在这里直接用color\n}];\n```\n\n这种方法比第4种要方便一些，如果超出UIImageView的时候就不执行block里的代码。\n\n### 从圆形范围内的指定点获取UIColor对象，并在block中执行操作\n\n```objc\n- (void)ax_getColorFromCircleWithPoint:(CGPoint)point completion:(void (^)(UIColor *color))completion;\n\n// 调用起来是这样的：\n// 已知imageView、point\n[imageView ax_getColorFromCircleWithPoint:point completion:^(UIColor *color){\n  // 在这里直接用color\n}];\n```\n\n引言中的Demo用的就是这一种方法，在圆形取色器中取色，既方便又安全。\n\n## 附：Gist\n\n<script src=\"https://gist.github.xaox.cc/xaoxuu/27de7d2fe02530faab0147d8001a2921.js\"></script>","tags":["iOS","开源库"],"categories":["解决方案"]},{"title":"ObjC 使用链式语法更优雅地管理沙盒文件","url":"/blog/20160912/","content":"\n假如你需要把一个字典或者别的什么东西保存到沙盒里，你准备怎么做？也许你已经条件反射的想到了操作步骤……其实，你可以不必每次都那么老老实实的把每一步写出来，一行代码就可以了：【路径+保存文件】两个关键点，组成一条链式语法。\n\n<!-- more -->\n\n```objc\n@\"文件名\".cachePath.save(要保存的内容);\n```\n\n\n## 接入AXKit\n\n如果你的项目里还没有AXKit，可以在pod文件里添加一条 `pod 'AXKit'` 进行接入，也可移步至[AXKit在线文档](https://xaoxuu.com/wiki/axkit)查看详细的安装和使用方法。\n\n\n\n## 路径\n\n我封装了几个常用的沙盒路径，如下：\n\n```objc\n- (nullable NSString *)mainBundlePath; // mainBundlePath就是主工程项目里的文件路径\n- (NSString *)docPath; // 文档，iTunes会备份，适合保存重要的数据\n- (NSString *)cachePath; // 缓存，iTunes不会备份，适合保存不太重要的较大的数据\n- (NSString *)tempPath; // 临时文件，iTunes不会备份，系统空闲时会自动删除，设备重启时也会删除\n```\n\n除此之外，还提供了所有的路径，通过枚举的方式获取：\n\n```objc\n- (NSString *(^)(NSSearchPathDirectory))path; // 传入NSSearchPathDirectory枚举就可得到路径\n```\n\n### 示例\n\n在沙盒的文档路径里有个叫 `abc.plist` 的文件，它的描述就是：\n\n```objc\n@\"abc.plist\".docPath;\n```\n\n\n\n### 路径的拼接\n\n任何一个字符串都可以使用 `.append()` 进行拼接。\n\n\n\n\n\n## 保存\n\n保存的方法目前提供有四个：\n\n```objc\n- (BOOL(^)(id))savePlist;\n- (BOOL(^)(NSObject<NSCoding> *))saveArchivedPlist;\n- (BOOL(^)(NSObject<NSCoding> *))saveArchivedObject;\n- (BOOL(^)(id <NSCoding>))save;\n```\n\n### 示例\n\n1. 在doc路径下保存一个名为\"arr.plist\"的文件：\n\n  ```objc\n  NSArray *arr = [NSArray array];\n  BOOL result = @\"arr\".docPath.savePlist(arr);\n  ```\n\n2. 在cache路径下归档一个名为\"myfile.plist\"的文件：\n\n   ```objc\n   MyProfiles *myfile = [[MyProfiles alloc] init];\n   // MyProfiles类需实现NSCoding协议\n   BOOL result = @\"myfile\".cachePath.saveArchivedPlist(myfile);\n   ```\n\n   ​\n\n\n\n## 读取\n\n读取的方法目前提供了七个：\n\n```objc\n- (nullable __kindof NSArray *)readArray;\n- (nullable __kindof NSDictionary *)readDictionary;\n- (nullable id)readArchivedPlist;\n- (nullable id)readJson;\n- (nullable NSString *)readTxt;\n- (nullable id)readArchivedFile;\n- (nullable id)readArchivedObject;\n```\n\n### 示例\n\n1. 在doc路径下读取一个名为\"arr.plist\"的文件：\n\n   ```objc\n   NSArray *arr = @\"arr\".docPath.readArray;\n   ```\n\n2. 在cache路径下解档一个名为\"myfile.plist\"的文件：\n\n   ```objc\n   MyProfiles *myfile = @\"myfile\".cachePath.readArchivedPlist;\n   ```\n\n   ​\n\n## 查询\n\n遍历路径下所有文件\n\n```objc\n// 获取doc/myDir 路径下所有的扩展名为\"plist\"文件路径\nNSArray *paths = @\"myDir\".docPath.subpaths(@\"plist\");\n// 如果传入值为空，则不区分扩展名获取所有文件路径\nNSArray *paths2 = @\"myDir\".docPath.subpaths(@\"\");\n// paths里面装的是doc/myDir路径下的所有文件完整路径\n```\n\n\n\n## 删除\n\n结构：【路径+删除】\n\n```objc\n- (BOOL)removePlist;\n- (BOOL)removeJson;\n- (BOOL)removeTxt;\n- (BOOL)remove;\n```\n\n### 示例\n\n1. 在doc路径下删除一个名为\"arr.plist\"的文件：\n\n   ```objc\n   BOOL result = @\"arr.plist\".docPath.remove;\n   ```\n\n2. 在cache路径下删除一个名为\"myfile.plist\"的文件：\n\n   ```objc\n   MyProfiles *myfile = @\"myfile.plist\".cachePath.remove;\n   ```\n\n\n\n## 详细文档\n\n{% link https://xaoxuu.com/wiki/axkit/ %}\n","tags":["iOS","链式语法","沙盒","缓存"],"categories":["设计开发"]},{"title":"十万蝼蚁不如一个巨人","url":"/blog/20160522/","content":"\n{% poetry Game&nbsp;of&nbsp;Thrones footer:台词节选 %}\n混乱不是深渊。\n混乱是阶梯。\n很多人想往上爬 却失败了\n且永无机会再试。\n他们坠落而亡。\n有人本有机会攀爬，\n但他们拒绝了。\n他们守着王国不放\n守着诸神\n守着爱情\n尽皆幻想。\n唯有阶梯是真实存在。\n攀爬才是生活的全部。\n{% endpoetry %}\n\n<!-- more -->\n\n## 物竞天择\n\n世界是残酷的，强者以弱者为食。\n\n\n\n## 个体意识\n\n每个人都是一个独立的个体，群众的力量再强大，他们也不属于你，只是在某些时刻能够帮到你。与其成为一个强大群体中微不足道的一员，不如成为一个强大的个体。\n\n\n\n## 群体意识\n\n社会不需要太多巨人，需要团结在一起才能发挥威力的蚂蚁。像牧羊一样，管好头羊，其他都会乖乖跟着头羊，即使有不听话的，也不会威胁到牧羊人。但如果羊羔中有几个或更多比牧羊人掌管的头羊更加强壮的个体，牧羊人就会地位不保。这些羊羔如果足够聪明的话，是不应该过早展露实力的，冲动的结局则是变成一桌美食。\n\n\n\n## 珍惜当下\n\n活着本来就是如临深渊，如履薄冰，永远不能保证下一刻不会遭遇意外。每天早上睁开眼能够看到熟悉的世界，能够记得自己走过的人生，都值得庆幸。不做别人的棋子，更不教育自己的后代如何做好这一颗棋子，生活是你自己的。\n\n\n## 时间、效率、实力\n\n我一直把时间作为衡量价值的标准，因为只有时间是有限的、平等的。效率则是将时间转化成实力的最关键一步，是靠自己的努力获得的，谁也赠予不了，谁也偷不了。实力则是我的人生观中的价值所在，也是唯一的追求。\n\n\n## 选择\n\n你可以选择随遇而安，只需要一双发现美的眼睛和积极乐观的心态。\n\n也可以攀爬，你会发现到处都是陷阱，一步跌落，就是万丈深渊。哪怕你认为现在的处境已经跌落人生谷底，但是事实是前方依然会有更深的陷阱在等着你。\n","categories":["胡思乱想"]},{"title":"我关于未来的智能生活的畅想","url":"/blog/20160211/","content":"\n我从小就对「活着」的机械十分着迷，就是我们现在所说的人工智能，当我初次了解到这个概念的时候，~就确定了我将奉献一生的事业~。\n\n然而梦想很遥远，遥远到我这辈子无法见证[《I, Robot》](https://baike.baidu.com/item/%E6%88%91%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA/1189079)那样的时代。\n\n\n<!-- more -->\n\n## 智能家居\n\n我相信，不久的未来会有越来越多的东西要接入互联网，接入互联网就可以用手机控制。\n网络就像神经，门窗联了网，门窗就活了，扫把联了网，扫把就活了。等所有的家具家电都联网的时候，就需要一个平台来管理这些智能硬件了。\n\n所有接入互联网的传感器都成为了这个智能系统的感官，神经将这些信息传递到可以分析、处理数据的终端，经过计算后作出应答，并由这些神经传递指令到相应的智能设备上。\n\n人与人、人与物之间的联系就更加紧密了，随时的远程互动，远程协助都更加方便了。\n当然，这中间涉及到的隐私和网络安全问题也十分重要，但问题总要解决，不能因噎废食。\n\n传统硬件，将一步一步被替换为智能硬件，至少是能用手机 app 控制，用手机 app 来控制，就是一种雏形了。毕竟目前没有足够多的智能硬件，没有到需要开发一个系统的程度。\n\n\n## 平台化\n\n现在智能硬件也越来越多了，网络也十分发达了，但是它们的「语言」不同，各厂商的产品都用自己的标准，不同厂商之间的硬件是无法协同工作的。它们需要一个协议、或者一个平台，来实现合作。平台，也许就是智能家居时代来临的一个必要条件吧。\n","categories":["闲聊时间"]},{"title":"如何进行有效的团队合作","url":"/blog/20130206/","content":"\n本文只是我在大学时期关于小组决策效率与分工方面的思考，可能不适用于其它场景。\n\n在任何一个团队中，我始终都是先做一个观察者，因为在掌握足够的信息之前，我的看法可能是片面的，由此产生的观点及推论发表出来可能会误导人。\n\n<!-- more -->\n\n## 偏执\n\n我印象非常深刻的一次经历：初二的时候，物理老师提问一个思考问题，我的答案和班上其它同学的都不一样，我有点犹豫了，老师说了一句话：{% quot el:span 有时候，真理往往掌握在少数人手中 %}，而正是那一次的正确的坚持，让我受益匪浅。这件事在我的成长过程中起到了非常重要的作用，所以现在我是一个对认定事情非常偏执的人。\n\n要相信自己有理有据的判断，在追求真理的路上敢于以一敌众，后来的某些经历也表明，即使所有人都反对你，你也未必要因此放弃，因为真相总有浮出水面的时候。\n\n\n## 交流意见\n\n然而我却又是一个不爱争论的人，往往我发表完我的意见，也理解了对方的意见之后，就不会再继续谈论了。\n\n为什么不说服别人呢？我会尝试去说服别人，但是当说服的难度远远大于它所带来的意义的时候，我就放弃了。我没有当过领导者，所以说服别人对我来说也不是个必选项，尤其是考虑到这个过程所花费的时间成本跟成果的价值孰轻孰重，我会越来越谨慎行事。\n\n## 独立决策与民主决策\n\n两者并非不可兼得。为什么要兼得？为了效率。\n\n我的眼中只有效率，不在乎形式，假如一个问题有两种既定方案，如果三十个人讨论半天各执己见，有些人选择A方案，有些人选择B方案，选择A方案的人试图说服选择B方案的人，选择B方案的人也试图说服选择A方案的人，最终的结果可能是选A也可能是选B，也可能出来一种新的C方案。\n\n**不是所有人都能看见真相**，经过讨论可能会让更多人走向正确的道路，也有可能会让少部分持有最佳方案却意志不够坚定的人被说服放弃，历史上这样的例子并不少见，每时每刻，都有数不清的人会在讨论中与**成为历史**或**被历史遗忘**擦肩而过。\n\n我们更需要的是：交流意见 --> 独立思考 --> 独立决策。\n\n## 合力不等于力量的叠加\n\n力量都是有方向的，方向相同则相加。很多时候一次糟糕的合作导致若干力量相抵消，最终还不如一个人的效率高，一个聪明的团队应该在力量和方向上都作出最优选择。\n\n我自认为是一个没有大家所谓的“团队精神”的人，因为我认为即使我们做不到最好，也不要硬撑着搞形式，作出最糟糕的选择，效率才是最终目的。\n","categories":["胡思乱想"]},{"url":"/about/index.html","content":"\n{% about avatar:/assets/xaoxuu/logo/xaoxuu.navbar@3x.png height:32px back:true %}\n\n**如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。**\n\n本站是 [@xaoxuu](https://xaoxuu.com) 的个人站，博主目前主要从事于 iOS 开发行业，活跃于开源社区，热衷于设计和打磨美妙的东西。代表作有：[ProHUD](/wiki/prohud/)、[ValueX](/wiki/valuex/)、[Stellar](/wiki/stellar/)、[心率管家](/wiki/heartmate/) 等，更多的作品可以去 [项目](/wiki/) 页查看，希望大家喜欢～\n\n{% navbar active:3 [动态](/timeline/) [友链](/friends/) [关于](/about/) %}\n\n{% endabout %}\n\n\n本站使用 Stellar 主题生成，技术架构为 Hexo 静态博客框架，面向所有具有基础 `markdown` 和 `git` 技能的有个人站点需求的用户，文档链接如下：\n\n{% link https://xaoxuu.com/wiki/stellar/ desc:true %}\n\n<br>\n{% quot icon:hashtag 关于博主 %}\n\n{% tabs align:center %}\n\n<!-- tab 音乐 -->\n\n非常热爱音乐，喜欢的品类很多，尤 [Hans Zimmer](https://music.163.com/#/artist?id=34517) 和 [Two Steps From Hell](https://music.163.com/#/artist?id=102714) 的史诗音乐，夜深人静的时候喜欢听 [Ludovico Einaudi](https://music.163.com/#/artist?id=38127) 的钢琴曲，能量不足的时候会听一些电音或摇滚来充电，心灰意冷的时候会听一些十年前常听的轻音乐怀旧，那时我还特别喜欢 [班得瑞](https://music.163.com/#/artist?id=88149) 的音乐。\n\n<!-- tab 游戏 -->\n\n| 游戏            | 推荐指数 | 游玩时间 |\n| :-------------- | :------- | :------- |\n| Red Alert 2 | ★★★★        | 2005-2012     |\n| World of Warcraft | ★★★★☆        | 2006-2020     |\n| Red Alert 3 | ★★★★☆        | 2013-2021     |\n| Minecraft       | ★★★★        | 2013-2016     |\n| Bad Piggies        | ★★★★★        | 2014-2017     |\n| Terraria        | ★★★★☆        | 2014-2021     |\n| Don‘t Starve    | ★★★★☆        | 2015-2021     |\n| Ori and the Blind Forest | ★★★★★        | 2018-2020     |\n| Human Fall Flat | ★★★★★★       | 2018-2021     |\n\n<!-- tab 话题 -->\n\n此外，也热衷于欣赏和学习这方面的知识：产品设计、摄影、天文。\n\n{% endtabs %}\n\n本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎去对应的仓库点个赞，或者在对应的文章下面留言互动一下。{% emoji blobcat ablobcatattentionreverse %}"},{"url":"/bookmark/index.html","content":"\n{% about avatar:/assets/xaoxuu/logo/xaoxuu.navbar@3x.png height:32px back:true %}\n{% navbar active:2 [随记](/notes/) [收藏](/bookmark/) %}\n{% endabout %}\n\n{% quot el:h2 icon:hashtag Mac 应用下载 %}\n\n{% sites mac_app_download %}\n\n{% quot el:h2 icon:hashtag 设计灵感和素材 %}\n\n{% sites sites_design %}\n\n{% quot el:h2 icon:hashtag 开发工具 %}\n\n{% tabs %}\n<!-- tab 在线工具 -->\n{% sites online_tools %}\n<!-- tab 国内镜像站 -->\n{% sites mirrors %}\n{% endtabs %}\n\n{% quot el:h2 icon:hashtag 技术加油站 %}\n\n{% tabs %}\n<!-- tab 行业大佬 -->\n{% sites ios_developer %}\n<!-- tab 技术社区 -->\n{% sites community %}\n{% endtabs %}\n"},{"url":"/friends/index.html","content":"\n{% about avatar:/assets/xaoxuu/logo/xaoxuu.navbar@3x.png height:32px back:true %}\n\n**如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。**\n\n本站是 [@xaoxuu](https://xaoxuu.com) 的个人站，博主目前主要从事于 iOS 开发行业，活跃于开源社区，热衷于设计和打磨美妙的东西。代表作有：[ProHUD](/wiki/prohud/)、[ValueX](/wiki/valuex/)、[Stellar](/wiki/stellar/)、[心率管家](/wiki/heartmate/) 等，更多的作品可以去 [项目](/wiki/) 页查看，希望大家喜欢～\n\n{% navbar active:2 [动态](/timeline/) [友链](/friends/) [关于](/about/) %}\n\n{% endabout %}\n\n{% friends repo:xaoxuu/friends %}\n\n{% tabs %}\n\n<!-- tab 朋友的动态 -->\n\n{% folders %}\n\n<!-- folder weekdaycare -->\n{% timeline hide:footer api:https://api.github.com/repos/weekdaycare/weekdaycare.github.io/issues?per_page=3 %}\n{% endtimeline %}\n\n<!-- folder seeseeme -->\n{% timeline hide:title,footer api:https://fastly.seeseeme.eu.org/ghapi/i-abc/blog-timeline/issues?per_page=3 %}\n{% endtimeline %}\n\n<!-- folder skyreeves -->\n{% timeline hide:footer api:https://api.github.com/repos/skyreeves/blog-timeline-svsvnm/issues?per_page=3 %}\n{% endtimeline %}\n{% endfolders %}\n\n<!-- tab 朋友的文章 -->\n{% timeline type:fcircle limit:10 api:https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator %}\n{% endtimeline %}\n{% endtabs %}\n\n{% quot icon:hashtag 如何交换友链？ %}\n\n先友后链，在我们有一定了解了之后才可以交换友链，除此之外，您的网站还应满足以下全部条件：\n\n1. 合法的、非营利性、无商业广告、无木马植入。\n2. 有实质性原创内容的 `HTTPS` 站点，发布过至少 `5` 篇原创文章，内容题材不限。\n3. 有独立域名，非免费域名。\n4. 博客已运行至少半年，非刚搭建好。\n5. 与 `xaoxuu` 有至少 `5` 次有效互动（有内容的留言或者 `issue` 等）。\n\n{% folding 我已满足全部条件，快告诉我如何交换友链！<img no-lazy style=\"display:inline;height:1em\" src=\"https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatattentionreverse.png\"> %}\n\n{% timeline %}\n\n<!-- node 第一步：新建 Issue -->\n\n新建 [GitHub Issue](https://github.com/xaoxuu/friends/issues/) 按照模板格式填写并提交。\n\n为了提高图片加载速度，建议优化头像：\n1. 打开 [压缩图](https://www.yasuotu.com/) 上传自己的头像，将图片尺寸调整到 `144px` 后下载。\n2. 将压缩后的图片上传到 [去不图床](https://7bu.top/) 或者其它稳定的图床并使用此图片链接作为头像。\n\n<!-- node 第二步：添加友链并等待管理员审核 -->\n\n请添加本站到您的友链中：\n\n```yaml\ntitle: xaoxuu\nurl: https://xaoxuu.com\navatar: https://bu.dusays.com/2021/09/24/2f74810ceb3d3.png\nscreenshot: https://bu.dusays.com/2022/10/23/63542895cfd29.png\n```\n\n待管理员审核通过，添加了 `active` 标签后，回来刷新即可生效。\n\n如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客更新。\n\n{% endtimeline %}\n\n{% endfolding %}\n\n"},{"url":"/notes/index.html","content":"\n{% about avatar:/assets/xaoxuu/logo/xaoxuu.navbar@3x.png height:32px back:true %}\n{% navbar active:1 [随记](/notes/) [收藏](/bookmark/) %}\n{% endabout %}\n\n{% timeline user:xaoxuu api:https://api.github.xaox.cc/repos/xaoxuu/blog-timeline-notes/issues %}\n{% endtimeline %}\n"},{"url":"/privacy/index.html","content":"\n\n{% about back:true %}\n\n# <center>隐私政策</center>\n\n**<center><u>本站不收集和存储您的任何数据</u></center>**\n\n<br>\n\n本站非常重视所有访客的隐私和个人信息保护，未使用任何访客统计和分析工具，未追踪您的 IP 地址、运营商信息，不会请求获取定位信息，不获取访问设备和浏览器信息，仅在您使用评论时，会要求登录 GitHub 账号进行授权，相关隐私政策见 [GitHub 隐私声明](https://docs.github.com/cn/site-policy/privacy-policies/github-privacy-statement)，此第三方服务与本站无关，本站不存储任何数据。\n\n<br>\n\n{% endabout %}\n\n"},{"url":"/timeline/index.html","content":"\n{% about avatar:/assets/xaoxuu/logo/xaoxuu.navbar@3x.png height:32px back:true %}\n\n**如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。**\n\n本站是 [@xaoxuu](https://xaoxuu.com) 的个人站，博主目前主要从事于 iOS 开发行业，活跃于开源社区，热衷于设计和打磨美妙的东西。代表作有：[ProHUD](/wiki/prohud/)、[ValueX](/wiki/valuex/)、[Stellar](/wiki/stellar/)、[心率管家](/wiki/heartmate/) 等，更多的作品可以去 [项目](/wiki/) 页查看，希望大家喜欢～\n\n{% navbar active:1 [动态](/timeline/) [友链](/friends/) [关于](/about/) %}\n\n{% endabout %}\n\n{% timeline user:xaoxuu api:https://api.github.xaox.cc/repos/xaoxuu/blog-timeline/issues %}\n{% endtimeline %}\n\n开源项目无任何盈利目的，只在工作闲暇时间进行维护，有相关需求请前往对应项目提 Issue 进行反馈，通过私人邮件询问开源项目问题可能得不到答复。\n"},{"url":"/blog/hot/index.html","content":"\n{% timeline hide:title,user user:utterances-bot,beaudar-bot api:https://api.github.xaox.cc/repos/xaoxuu/blog-comments/issues?sort=comments %}\n{% endtimeline %}"},{"url":"/friends/rss/index.html","content":"\n{% timeline type:fcircle api:https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator %}\n{% endtimeline %}\n"},{"title":"Flutter 相关问题","url":"/notes/flutter/index.html","content":"\n运行时弹出「无法打开“iproxy”，因为无法验证开发者。」弹窗，手动添加信任：\n\n```\nsudo xattr -r -d com.apple.quarantine futter的SDK目录/bin/cache/artifacts/usbmuxd/iproxy\n```\n\n清除缓存，重新 build：\n\n```\nrm -rf build\nflutter clean\nflutter build ios --debug\n```\n"},{"title":"iOS 相关问题","url":"/notes/ios/index.html","content":"\n## 最新版 CocoaPods 的安装流程\n\n1. （首次安装）移除现有Ruby默认源\n{% copy gem sources --remove https://rubygems.org/ %}\n\n2. （首次安装）使用新的源\n{% copy gem sources -a https://gems.ruby-china.com %}\n\n3. （首次安装）验证新源是否替换成功\n{% copy gem sources -l %}\n\n4. （可选）更新 gem\n{% copy sudo gem update --system %}\n\n5. 安装 CocoaPods\n{% copy sudo gem install -n /usr/local/bin cocoapods && pod setup %}\n\n\n## Podfile 文件中的一些写法\n\n{% link https://guides.cocoapods.org/using/the-podfile.html %}\n\n```ruby\n# 设置镜像源\nsource 'https://cdn.cocoapods.org/'\n# 忽略警告\ninhibit_all_warnings!\n```\n\n## 如何发布开源库到 CocoaPods\n\n说实在话，类似的教程网上很多，基本可以满足大多数人零基础发布 CocoaPods，但是其中可能会遇到一些问题，只有亲自尝试过才知道。\n\n### 准备工作\n\n#### 1. clone 远程仓库到本地\n\n```sh\ngit clone 你的仓库链接\n```\n\n\n#### 2. 注册 trunk\n\n注册的命令\n\n```sh\npod trunk register 你的邮箱 你的用户名\n```\n\n记得去邮箱里验证，然后可以输入以下命令查看个人信息\n\n```sh\npod trunk me\n```\n\n\n### 步骤\n\n#### 1. 创建 `.podspec`\n\n```sh\npod spec create AXKit\n```\n\n#### 2. 修改 `.podspec` 并验证\n\n有很多类似的教程，可以参考。\n\n> 一个小技巧：你可以去GItHub搜索一些热门的第三方库，然后点击查看这些大牛的 `.podspec` 是怎么写的。\n> 传送门：[YYKit的podspec](https://github.com/ibireme/YYKit/blob/master/YYKit.podspec)、[ReactiveObjC的podspec](https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC.podspec)、[BlocksKit的podspec](https://github.com/BlocksKit/BlocksKit/blob/master/BlocksKit.podspec)\n\n\n最容易出错的地方就是资源路径\n\n```ruby\ns.source_files = \"AXKit/**/*.{h,m}\"\n```\n\n常见写法\n\n```ruby\n\"Directory1/*\"  表示匹配所有文件\n\"Directory1/Directory2/*.{h,m}\"  表示匹配所有以.h和.m结尾的文件\n\"Directory1/**/*.h\"  表示匹配所有子目录\n```\n\ns.source 常见写法\n\n```ruby\n# 推荐写法：与版本号绑定\ns.source = { :git => \"https://github.com/TeaseTian/HTQRCode.git\", :tag => \"#{s.version}\" }\n# 与commit id 绑定\ns.source = { :git => \"https://github.com/TeaseTian/HTQRCode.git\", :commit => \"68defea\" }\n```\n\ntag => s.version 表示将这个 Pod 版本与 Git 仓库中相同版本的 comit 绑定\n\n{% border %}\n\n**注意**\n\n如果仓库中对应的tag是 `“v1.0.0”\b` 这样以字母开头的，可以在 `#{s.version}` 前面加上对应的字母。commit => \"68defea\" 表示将这个 Pod 版本与 Git 仓库中某个 commit 绑定\n\n{% endborder %}\n\n\n**验证**\n\n```sh\npod spec lint AXKit.podspec\n```\n\n#### 3. 上传到远程仓库\n\n修改 `.podspec` 时指定的版本号，如 `0.0.1`。那么远程仓库中必须始终存在这个版本的 `branch` 或 `tag` 才能够下载。建议使用 tag。`s.source` 中的 tag 需要与远程仓库中的 tag 对应起来。\n\n```ruby\ns.version = \"0.0.1\"\ns.source  = { :git => \"https://github.com/xaoxuu/AXKit.git\", :tag => \"v#{s.version}\" }\n```\n\n这里指向的是 `\"v0.0.1\"` 这个分支，因为分支我们用完之后习惯把它删掉，所以这里也可以指向 tag，也就是说打一个 `\"v0.0.1\"` 的 tag 并推送到远程就可以了。\n\n```\ngit tag v0.0.1\ngit push --tags\n```\n\n这样做的好处就是删掉当前分支不影响 CocoaPods 中指向的仓库源码。\n\n\n#### 4. 发布到 CocoaPods\n\n```\npod trunk push AXKit.podspec\n```\n\n\n\n#### n. 删除一个 podspec 版本\n\n删除的命令是：\n\n```\npod trunk delete 项目名 版本号\n```\n\n官方建议使用 `deprecate` 来弃用\n\n```\npod trunk deprecate 项目名\n```\n\n这两种方法执行完有很大几率会出现一串很长很长的错误，不要着急，这实际上这是一个 html。把它保存到一个 html 文件中，打开，是个404错误页，原因众所周知。\n\n\n> 删除之后立即搜索还是能搜到的，因为有一定的延迟，可能要半个小时才能更新。\n\n\n\n#### pod trunk 命令\n\n在终端输入\n\n```\npod trunk --help\n```\n\n可以查看帮助\n\n\n\n### 使用脚本\n\n没必要每次都重复每个步骤，如果你已经发布过一个，可以省去注册的步骤，直接把已经发不过的 podspec 复制一份，改一下仓库模块名，验证通过就可以发布了。\n\n我写了一个便于发布更新的脚本，把脚本放在与 podspec 同级目录下，当你更新了项目之后，如果需要更新到 cocoapods，可以执行此脚本。流程是：\n\n```\n输入版本号 -> commit、push tag -> pod spec lint -> 询问是否发布(y/n) -> 发布(y)\n```\n\n{% link https://github.com/xaoxuu/podspec.sh %}\n\n\n## 应用上传失败\n\n原因可能有很多，有关于 Transporter 的问题可以尝试删除缓存：\n\n### 删除缓存\n\n{% copy open ~/Library/Caches/com.apple.amp.itmstransporter/ %}\n\n### 重新下载缓存\n\n{% copy /Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin/iTMSTransporter %}\n\n> 这个缓存有 60MB （2020年7月份下载实测）\n\n## 素材规格\n\n### iPhone 各代屏幕尺寸与分辨率\n\n#### 经典屏幕iPhone\n\n| iPhone | 对角线 | 缩放 | 逻辑分辨率     | 物理分辨率       | ppi |\n| :---- | :--- | :--- | :-------- | :---------- | :---------- |\n| 1、3G、3GS | 3.5  | @1x  | 320x480 | 320x480   | 163 |\n| 4、4s | 3.5  | @2x  | 320x480 | 640x960   | 326 |\n| 5、5s、SE | 4    | @2x  | 320x568 | 640x1136  | 326 |\n| 6、6s、7、8、SE2、SE3 | 4.7  | @2x  | 375x667 | 750x1334  | 326 |\n| 6 Plus、6s Plus、7 Plus、8 Plus | 5.5  | @3x  | 414x736 | 1242x2208 | 401 |\n\n#### 全面屏iPhone\n\n| iPhone | 对角线 | 缩放 | 逻辑分辨率     | 物理分辨率       | ppi |\n| :---- | :--- | :--- | :-------- | :---------- | :---------- |\n| X、XS、11 Pro | 5.8  | @3x  | 375x812 | 1125x2436 | 458 |\n| XR、11 | 6.1  | @2x  | 414x896 | 828x1792 | 326 |\n| XS Max、11 Pro Max | 6.5  | @3x  | 414x896 | 1242x2688 | 458 |\n| 12 mini、13 mini | 5.4 | @3x | 375x812 | 1080x2340 | 476 |\n| 12、12 Pro、13、13 Pro、14 | 6.1 | @3x | 390x844 | 1170x2532 | 460 |\n| 12 Pro Max、13 Pro Max、14 Plus | 6.7 | @3x | 428x926 | 1284x2778 | 458 |\n| 14 Pro | 6.1 | @3x | 393x852 | 1179x2556 | 460 |\n| 14 Pro Max | 6.7 | @3x | 430x932 | 1290x2796 | 460 |\n\n\n### iPad 各代屏幕尺寸与分辨率\n\n#### 经典屏幕iPad\n\n| iPad | 对角线 | 缩放 | 逻辑分辨率     | 物理分辨率       | ppi |\n| :---- | :--- | :--- | :-------- | :---------- | :---------- |\n| 1、2 | 9.7  | @1x  | 768x1024 | 768x1024   | 132 |\n| mini 1 | 7.9  | @1x  | 768x1024 | 768x1024   | 163 |\n| mini 2/3/4 | 7.9  | @2x  | 768x1024 | 1536x2048   | 326 |\n| Air 1/2 | 9.7  | @2x  | 768x1024 | 1536x2048   | 264 |\n| Pro (9.7) | 9.7  | @2x  | 768x1024 | 1536x2048   | 264 |\n| iPad (10.2) | 10.2  | @2x  | 810x1080 | 1620x2160   | 264 |\n| Pro (10.5) | 10.5  | @2x  | 834x1112 | 1668x2224   | 264 |\n\n#### 全面屏iPad\n\n| iPad | 对角线 | 缩放 | 逻辑分辨率     | 物理分辨率       | ppi |\n| :---- | :--- | :--- | :-------- | :---------- | :---------- |\n| mini 6 | 7.9  | @2x  | 744x1133 | 1488x2266   | 326 |\n| Air 5 | 10.9  | @2x  | 820x1180 | 1640x2360   | 264 |\n| Pro (11' 2018) | 11  | @2x  | 834x1194 | 1668x2388   | 264 |\n| Pro (12.9' 2018) | 11  | @2x  | 1024x1366 | 2048x2732   | 264 |\n\n{% link https://developer.apple.com/design/resources/ 官方设计素材下载 %}\n\n### Logo & 启动图\n\nUI 只需要提供一张 `1024*1024` 尺寸的图即可，开发使用 [IconKit](https://img.vim-cn.com/24/a42106ba9e592869dc2293da2c04b11bf7657d.zip) 工具可以直接生成开发需要的各种尺寸的图片及其 json 配置文件，直接拖进 Xcode 工程中就可以使用了。使用传统方式不同尺寸一张一张的切图不仅浪费 UI 的时间，开发也需要一张图一张图往对应位置拖，双方都很麻烦。\n\n\n如果使用 LaunchImage 方式，需要切各个尺寸的图片，参考 [iPhone 各代屏幕尺寸与分辨率](#iPhone-各代屏幕尺寸与分辨率) 表，如果需要兼容 iPhone 4、4s 机型，则需要提供一共7种尺寸的图片，如果最低兼容 iPhone5 的话，就只需要提供6种尺寸的图片。\n\n> 注意：iOS 并不需要 `1920*1080` 这种尺寸的图片。\n\n### icon 素材\n\niOS 端的切图需要同时提供 @2x 和 @3x 两种尺寸的图片，例如某个名为 “imagename” 的图片需要提供两个文件分别命名为：\n\n```\nimagename@2x.png\nimagename@3x.png\n```\n\n素材名（imagename）命名可以根据公司或团队规范而异，但是两种尺寸的文件的素材名部分要保持一致，唯一的不同就是 `@2x` 和 `@3x`。\n"},{"title":"Json在线解析工具","url":"/notes/json/index.html","content":"\n{% border child:iframe %}\n<iframe width=\"100%\" id=\"json-format\" height=\"600px\" frameborder=\"0\" src=\"https://json.xaoxuu.com\"></iframe>\n{% endborder %}\n"},{"title":"Mac 相关问题","url":"/notes/mac/index.html","content":"\n{% folders %}\n\n<!-- folder 提示 “安装包已损坏” 怎么办？ -->\n{% copy sudo spctl --master-disable %}\n\n<!-- folder 如何清理 Mac 的 DNS 缓存 -->\n```\nsudo killall -HUP mDNSResponder\nsudo killall mDNSResponderHelper\nsudo dscacheutil -flushcache\n```\n\n<!-- folder TNT 团队的应用无法使用怎么办？ -->\n\nTNT 的证书签署的软件在 2019年7月12日 后都不能运行了，临时的解决办法，就是自己签名。\n\n**1. 安装 Xcode**\n\n安装 Xcode，你可以在 App Store 中下载安装，并且至少运行一次。\n\n**2. 安装 Command Line Tools 工具**\n\n打开终端工具输入如下命令：\n\n{% copy xcode-select --install %}\n\n弹出后选择继续安装。\n\n**3. 为应用签名**\n\n打开终端工具输入并执行如下命令：\n\n```\ncodesign --force --deep --sign - /Applications/name.app\n```\n\n注意后面的文件路径，你可以打开访达找到应用程序，找到要签名的软件，直接拖入「终端」界面，即可自动生成路径。\n\n<!-- folder 如何显示隐藏文件 -->\n\n{% tabs active:1 align:left %}\n\n<!-- tab 显示 -->\n\n{% copy defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE; killall Finder %}\n\n<!-- tab 隐藏 -->\n\n{% copy defaults delete com.apple.finder _FXShowPosixPathInTitle; killall Finder %}\n\n{% endtabs %}\n\n<!-- folder 外置磁盘路径 -->\n\n```\n/volume/磁盘路径/~~~\n```\n\n例如一个名称为 \"Files\" 的磁盘里的文件夹 \"Projects\" 路径是:\n```\n/Volumes/Files/Projects/\n```\n\n<!-- folder 使用终端将 json 文件转为 plist 文件 -->\n\n```\nplutil -convert xml1 data.json -o data.plist\n```\n\n其中 `data.json`、`data.plist` 分别对应转换前后的文件路径。\n\n<!-- folder sudo 依然没有权限的解决办法 -->\n\n{% tabs align:left active:1 %}\n\n<!-- tab 查询 SIP 状态 -->\n\n{% copy csrutil status %}\n\n如果输出以下信息，说明 SIP 开启，需要暂时将 SIP 关闭。\n\n```\nSystem Integrity Protection status: enabled.\n```\n\n<!-- tab 关闭 SIP -->\n\n重启 Mac，按住 {% kbd command %} + {% kbd R %} 直到出现开机 logo，此时会进入 Recovery 模式，选择「实用工具」->「Terminal」并输入以下命令：\n\n{% copy csrutil disable %}\n\n然后重新启动电脑即可关闭 SIP。\n\n<!-- tab 开启 SIP -->\n\n重启 Mac，按住 {% kbd command %} + {% kbd R %} 直到出现开机 logo，此时会进入 Recovery 模式，选择「实用工具」->「Terminal」并输入以下命令：\n\n{% copy csrutil enable %}\n\n然后重新启动电脑即可开启 SIP。\n\n{% endtabs %}\n\n<!-- folder 搭载 Intel 芯片的 Mac 启动组合键 -->\n\n- **Command (⌘)-R**：从内建的 macOS 恢复系统启动。或者，您也可以使用 Option-Command-R 或 Shift-Option-Command-R 以通过互联网从 macOS 恢复功能启动。macOS 恢复功能可以安装不同版本的 macOS，具体取决于您在电脑启动时使用的组合键。如果您的 Mac 使用了固件密码，系统将提示您输入这个密码。\n\n- **Option (⌥) 或 Alt**：启动进入“启动管理器”，您可以从中选取其他可用的启动磁盘或宗卷。如果您的 Mac 使用了固件密码，系统将提示您输入这个密码。\n\n- **Option-Command-P-R**：重置 NVRAM 或 PRAM。如果您的 Mac 使用了固件密码，电脑会忽略这个组合键或从 macOS 恢复功能启动。\n\n- **Shift (⇧)** ：以安全模式启动。如果使用了固件密码，这个组合键将被停用。\n\n- **D**：启动进入“Apple 诊断”实用工具。也可以使用 Option-D 通过互联网启动进入这个实用工具。如果使用了固件密码，这个组合键将被停用。\n\n- **N**：从 NetBoot 服务器启动，前提是您的 Mac 支持网络启动宗卷。要使用服务器上默认的引导映像，请按住 Option-N。如果使用了固件密码，这个组合键将被停用。\n\n- **Command-S**：以单用户模式启动。如果运行的是 macOS Mojave 或更高版本，或者使用了固件密码，这个组合键会被停用。\n\n- **T**：以目标磁盘模式启动。如果使用了固件密码，这个组合键将被停用。\n\n- **Command-V**：以详细模式启动。如果使用了固件密码，这个组合键将被停用。\n\n- **推出键 (⏏)、F12**、鼠标按钮或触控板按钮：推出可移动介质，例如光盘。如果使用了固件密码，这个组合键将被停用。\n\n\n{% endfolders %}\n"},{"title":"Node.js 相关问题","url":"/notes/nodejs/index.html","content":"\n查看当前的源：\n{% copy npm config get registry %}\n\n官方源：\n{% copy npm set registry https://registry.npmjs.org/ %}\n\n淘宝源：\n{% copy npm set registry https://registry.npm.taobao.org/ %}\n"},{"title":"服务器相关问题","url":"/notes/server/index.html","content":"\n## GitHub Action + Hexo 部署到服务器\n\n### 在本地电脑生成 ssh key\n\n{% copy ssh-keygen -t rsa %}\n\n### 创建 git 用户\n\n{% copy adduser git %}\n\n### 设置 ssh\n\n把本机的 `id_isa.pub` 内容复制到这里：\n\n```\n/home/git/.ssh/authorized_keys\n```\n\n### 如果通过 ssh 登录仍需要密码的解决方法\n\n找到并修改 `/etc/ssh/sshd_config` 文件：\n\n```\n#禁用root账户登录，如果是用root用户登录请开启\nPermitRootLogin yes\n\n# 是否让 sshd 去检查用户家目录或相关档案的权限数据，\n# 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。\n# 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入\nStrictModes no\n\n# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。\n# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n\n# 有了证书登录了，就禁用密码登录。\nPasswordAuthentication no\n```\n\n然后重启 `sshd` 服务\n\n{% copy /bin/systemctl restart sshd.service %}\n\n### 网站路径\n\n创建网站，以 `/www/wwwroot/xaoxuu.github.io` 为例，`/www/wwwroot/xaoxuu.github.io` 的权限要改成 777 并且所有者为 www 才可以访问。\n\n### GitHub Action\n\n```yaml .github/workflows/auto-deploy.yml\nname: auto deploy\n\non:\n  [push] # 触发事件\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu\n    name: auto deploy\n    steps:\n    # 1. 获取源码\n    - name: Checkout\n      uses: actions/checkout@v1 # 使用 actions/checkout@v1\n      with: # 条件\n        submodules: true # Checkout private submodules(themes or something else). 当有子模块时切换分支？\n    # 2. 配置环境\n    - name: Setup Node.js 16.13.x\n      uses: actions/setup-node@master\n      with:\n        node-version: \"16.13.x\"\n    # 3. 生成静态文件\n    - name: Generate Public Files\n      run: |\n        npm i\n        npm install hexo-cli -g\n        hexo clean && hexo generate\n    # 4. 部署到 GitHub 仓库\n    - name: Deploy to GitHub Pages\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        deploy_key: ${{ secrets.DEPLOY_KEY }}\n        external_repository: xaoxuu/xaoxuu.github.io\n        publish_branch: gh-pages\n        publish_dir: ./public\n        commit_message: ${{ github.event.head_commit.message }}\n        user_name: 'github-actions[bot]'\n        user_email: 'github-actions[bot]@users.noreply.github.com'\n    # 5. 部署到服务器\n    - name: Deploy to Server\n      uses: easingthemes/ssh-deploy@v2\n      env:\n        SSH_PRIVATE_KEY: ${{ secrets.SERVER_SSH_KEY }}\n        ARGS: \"-rltgoDzvO --delete\"\n        EXCLUDE: \".well-known\"\n        SOURCE: public/\n        REMOTE_HOST: ${{ secrets.REMOTE_HOST }}\n        REMOTE_PORT: ${{ secrets.REMOTE_PORT }}\n        REMOTE_USER: ${{ secrets.REMOTE_USER }}\n        TARGET: ${{ secrets.TARGET }}\n```\n\n在 Settings -> Secrets 中填写对应的值：\n\n```yaml\nSERVER_SSH_KEY: 第一步本机生成的 id_isa 文件内容\nREMOTE_HOST: 服务器地址\nREMOTE_PORT: 服务器SSH端口\nREMOTE_USER: 用户名，例如 \"git\"\nTARGET: 生成的文件路径，例如 \"/www/wwwroot/xaoxuu.github.io/\"\n```\n\n## 设置 webhook\n\n```sh post-receive\n#!/bin/sh\nWEBROOT=/www/wwwroot/xaoxuu.github.io\ngit --work-tree=$WEBROOT checkout -f master\n```\n\n把上述的 post-receive 文件放在这里：\n\n```\n/home/git/xxx.git/hooks/post-receive\n```\n\n> `/www/wwwroot/xaoxuu.github.io` 的权限要改成 777 才行\n\n\n{% link https://zhuanlan.zhihu.com/p/58654392 %}\n\n## GitLab\n\n{% link http://42.192.89.158:8099 GitLab %}\n\n把上述的 post-receive 文件放在这里：\n\n```\n/var/opt/gitlab/git-data/repositories/root/xxx.git/custom_hooks/post-receive\n```\n\nGitLab 的 ssh 能记住密钥， hook 也正常，缺点就是每个月多花10块钱满足 GitLab 最低配置要求。\n\n## 404\n\n打开 nginx 配置文件，拉到最后，看到：\n```\ninclude /www/server/panel/vhost/nginx/*.conf;\n```\n\n然后根据这个路径找到自定义的配置文件：\n```\n/www/server/panel/vhost/nginx/xaoxuu.com.conf\n```\n\n在其中添加如下代码就可以了：\n```\nserver\n{\n    ...\n    fastcgi_intercept_errors on;\n    error_page 404 /404.html;\n    location = /404.html {\n        root /www/wwwroot/xaoxuu.github.io;\n    }\n    ...\n}\n```\n"},{"title":"综合型ObjC开发工具包","url":"/wiki/axkit/index.html","content":"\n<!-- more -->\n\n## 特性\n\n### 沙盒文件\n\n- 使用链式语法快速存取沙盒文件\n\n### .toJson()\n\n- `.toJson()` 快速将字典、数组与 json 进行转换以及非空判断\n\n### Blocks\n\n* 构造方法的 block 支持\n* EventTarget 的 block 支持\n* 给视图添加手势的 block 支持（Runtime）\n\n### Cooldown\n\n* 代码冷却机制（基于 GCD 实现）\n\n### Date+\n\n* NSDate 的链式封装（日期的格式化和操作）\n\n\n## 开始使用\n\n```ruby 在 Podfile 中添加：\npod 'AXKit'\n```\n\n```sh 然后执行：\npod install\n```\n\n## 示例\n\n### 沙盒文件与ToJson\n\n保存\n\n```ObjC\nNSDictionary *dict = @{@\"name\": @\"Alex\"};\n@\"File.json\".docPath.saveJson(dict);\n```\n\n读取和转换\n\n```ObjC\nid read = @\"File.json\".docPath.readJson();\nNSDictionary *readDict = NSDictionary.safe(read);\nNSArray *readArr = NSArray.safe(read);\n```\n转换\n```ObjC\nNSUserDefaults.setObjectForKey(@23, @\"age\");\nNSUserDefaults.numberForKey(@\"age\");\nNSUserDefaults.setObjectForKey(@\"23\", @\"age\");\nNSUserDefaults.numberForKey(@\"age\");\n// 以上两种情况都可以正常读取到值，因为内部做了自动转换\n```\n\n### Cooldown\n\n```ObjC\n// 10秒内即使多次调用也不会重复执行\nax_dispatch_cooldown(0, 10, \"cool\", dispatch_get_main_queue(), ^{\n    // do something\n}, ^{\n    NSLog(@\"正在冷却，请稍后\")\n});\n```\n\n### Date+\n\n```ObjC\nNSDate *date = NSDate.initWithFormat(@\"yyyyMMdd\", @\"20160802\");\ndate = date.addDays(1).addhours(-1).addWeeks(-2).addMinutes(20);\nNSString *str = date.stringWithFormat(@\"yyyyMMdd\");\n```\n\n### Blocks\n\n手势\n\n```ObjC\n[view ax_addTapGestureHandler:^(UITapGestureRecognizer * sender) {\n    // 点击事件\n}];\n[view ax_addPanGesture:nil handler:^(UIPanGestureRecognizer * sender) {\n    // 拖拽\n}];\n[view ax_addLongPressGesture:^(UILongPressGestureRecognizer * sender) {\n    sender.minimumPressDuration = 5;\n} handler:^(UILongPressGestureRecognizer * sender) {\n    // 长按\n}];\n...\n```\n\n事件\n\n```ObjC\nUIButton *button;\n[button ax_addTouchUpInsideHandler:^(UIButton * sender) {\n    // 点击\n}];\n\nUISlider *slider;\n[slider ax_addEventHandler:^(UISlider * sender) {\n    // 事件\n} forControlEvents:UIControlEventValueChanged];\n...\n```\n"},{"url":"/wiki/cloud-shell/index.html","content":"\n{% quot el:h2 icon:hashtag 什么是 cloud-shell %}\n\n一个轻量级云端脚本库，里面的脚本不依赖任何包管理工具，一行代码即可使用。\n\n在终端中输入以下指令可以安装对应脚本：\n\n```sh\ncurl -s https://sh.xaox.cc/install | sh 脚本名\n```\n\n也可以指定分支或版本号：\n\n```sh\ncurl -s https://sh.xaox.cc/install | sh 脚本名 分支或版本号\n```\n\n快来试一试吧～\n\n{% copy curl -s https://sh.xaox.cc/install | sh %}\n\n"},{"title":"认识 Git","url":"/wiki/git/index.html","content":"\n<!-- more -->\n\n## 什么是 Git ？\n\nGit 是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n\n### Git 与 SVN 区别点\n\n1. Git 是分布式的，SVN 不是。这是 Git 和其它非分布式的版本控制系统如 SVN，CVS 等最核心的区别。\n2. Git 把内容按元数据方式存储，而 SVN 是按文件。\n3. Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。\n4. Git 没有一个全局的版本号，而 SVN 有。目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。\n5. Git 的内容完整性要优于 SVN。Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n\n{% image /assets/wiki/git/svn-git.jpg width:400px 图片来源于 RUNOOB  %}\n\n## Git 工作区、暂存区和版本库\n\n- 工作区：就是你在电脑里能看到的目录。\n- 暂存区：英文叫stage, 或index。一般存放在 \".git目录下\" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n- 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\n"},{"title":"心率管家","url":"/wiki/heartmate/index.html","content":"\n专为那些没有智能手环或手表却需要测量心率的用户而设计，可以方便快捷的测量和记录心率。 使用Heart Mate心率助手，你可以在没有智能手环等心率监测设备的情况下随时检测并记录自己的心率。 通过设置tag标签，快速记录当前状态，如饭后、运动后等，方便以后检索具有同样标签的心率数据，从而分析这些情景下的心率数据，发现健康问题。\n\n<!-- more -->\n\n{% swiper width:min %}\n![](/assets/wiki/heartmate/screenshot01.jpg)\n![](/assets/wiki/heartmate/screenshot02.jpg)\n![](/assets/wiki/heartmate/screenshot03.jpg)\n![](/assets/wiki/heartmate/screenshot04.jpg)\n![](/assets/wiki/heartmate/screenshot05.jpg)\n![](/assets/wiki/heartmate/screenshot06.jpg)\n{% endswiper %}\n\n<br>\n\n心率管家App（仅iOS端），专业版不定期限免，欢迎下载体验。\n\n如果您看到的时候已经过了限免期，可以先下载免费版使用。为了吸引app推荐类网站的爬虫进行推荐，专业版的价格通常在1元到68元之间浮动变化的。\n\n## 下载安装\n\n{% link https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1 心率管家（免费版） %}\n\n{% link https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1463348922?ls=1 心率管家（专业版） %}\n\n## 如何测量\n\n{% frame iphone11 img:/assets/wiki/heartmate/docs/usage01.jpg video:/assets/wiki/heartmate/docs/usage01.mp4 focus:top %}\n\n### 第一步，调整位置\n\n请用一只手指同时按住手机后方的摄像头和闪光灯，调整遮挡的位置使上方的取景器看起来是红色的。\n\n### 第二步，保持不动\n\n太好了，现在手指尽量不要动，请等待数据稳定，这大概需要10秒钟。\n\n### 第三步，继续保持不动\n\n正在采集数据，马上就要成功了，手指请继续保持不动。\n\n### 第四步，请松开手\n\n恭喜您，测量已经完成，您可以松开手指结束此次测量，也可以保持不动继续测量更长时间以提高准确性。\n\n> App内部有详细的使用帮助。\n\n\n## 近期限免日程\n\n![](https://bu.dusays.com/2021/02/26/24622fa8268f1.jpg)\n\n付费真不是为了赚钱，是为了骗应用推荐类网站的爬虫给我做推广，同时这样也减少了免费时的莫名其妙的大量差评。已经高价购买的用户实在是抱歉，我的其它 App 也会采用类似的定价策略，所以请多多关注我的博客，能省下不少钱呢。\n\n\n## 安装测试版\n\n安装地址：https://testflight.apple.com/join/rqNjAxg1\n"},{"title":"基于主题的Swift开发工具包","url":"/wiki/inspire/index.html","content":"\n\n## 特性\n\n### 可缓存的\n\n- App 的样式参数（颜色、字体、布局）存储于 json 文件中。\n\n### 可配置的\n\n- 可由用户修改主题参数并保存或者分享。\n\n### 提供便利\n\n- 便捷的方式获取屏幕布局参数、如各边安全区域尺寸，便于机型适配。\n\n\n## 开始使用\n\n```ruby 在 Podfile 中添加：\npod 'Inspire'\n```\n\n```sh 然后执行：\npod install\n```\n\n## 用法示例\n\n\n\n### 颜色\n\n```swift\nview.backgroundColor = .background\nview.tintColor = .accent\n```\n\n### 字体\n\n```swift\nlet lb = UILabel()\nlb.font = .regular(15)\nlb.font = .bold(20, for: .title)\nlb.font = .regular(14, for: .code)\n```\n\n### 边距\n\n\n```swift\nlet topMargin = layout.topBarHeight(for: self)\nlet bottomMargin = layout.bottomBarHeight(for: self)\nlet safeArea = layout.safeAreaInsets(for: self)\nlet safeArea2 = Inspire.shared.screen.safeAreaInsets\n```\n\n```swift\nlet layout = Inspire.shared.layout\nview.frame.size.height = layout.rowHeight\nview.layer.cornerRadius = layout.cornerRadius.large\n```\n\n### 缓存\n\n```swift\n// 保存\nInspire.shared.cache()\nInspire.shared.cache(named: \"myTheme\")\n// 读取\nlet ipr = Inspire.init(\"myTheme\")\n```\n"},{"title":"NEXUS","url":"/wiki/nexus/index.html","content":"\n\n点击屏幕左上角，即可呼出搜索栏，此搜索栏对于一些常用的网站如[优酷]、[淘宝]等等可以直达官网，省去了搜索引擎检索的步骤。左上角热键是透明的，不影响视觉，只有在允许后台运行时才会生效。\n\n{% image /assets/wiki/nexus/IMG_0355.PNG %}\n\n{% swiper %}\n![](/assets/wiki/nexus/IMG_0356.PNG)\n![](/assets/wiki/nexus/IMG_0357.PNG)\n![](/assets/wiki/nexus/IMG_0358.PNG)\n![](/assets/wiki/nexus/IMG_0359.PNG)\n{% endswiper %}\n\n\n<!-- more -->\n\n## 适用平台\n\nWindows 7~10\n\n## 下载\n\n{% link https://github.com/xaoxuu/NEXUS-Windows/releases/ %}\n\n## 已归档\n\n这是一个已经归档的项目，最后一次更新时间是在2017年1月。\n"},{"title":"易于上手又完全可定制化的专业HUD库","url":"/wiki/prohud/index.html","content":"\n**易于上手**\n\n- 用极少的参数就可以创建并显示一个实例。\n- 用相似的接口调用**Toast**、**Alert**、**Sheet**。\n\n**功能丰富**\n\n- 具有完善的实例管理（多实例共存方案、查找与更新方案）。\n- 可对已发布的实例进行数据更新。\n- 横竖屏和iPad布局优化。\n\n**完全可定制化**\n\n- 支持只使用ProHUD的容器，而容器内容可完全自定义。\n- 程序初始化时配置自定义UI样式，调用的时候只需要关注数据。\n- 易于扩展，可以很方便的添加任意控件。\n\n\n## Toast（顶部通知横幅）\n\n通知条控件，用于非阻塞性事件通知。显示效果如同原生通知，默认会自动消失，可以支持手势移除，有多条通知可以平铺并列显示。\n\n{% frame iphone11 img:/assets/wiki/prohud/toast/demo-loading.png video:/assets/wiki/prohud/toast/demo-loading.mp4 focus:top %}\n\n### 方式一：传入ViewModel生成实例\n\n这种方式创建的实例在调用`push()`之后才会显示出来，结构为： \n\n```swift\nlet 实例 = Toast(视图模型)\n实例.push()\n```\n\n也可以连在一起写，例如：\n\n```swift\nToast(.message(\"要显示的消息内容\")).push()\n```\n\n#### 如何创建ViewModel\n\nViewModel有多种创建方式，也可以自行扩展更多常用场景，例如：\n\n```swift\n// 纯文本\nlet vm = .message(\"要显示的消息内容\")\n// 持续2s的文本\nlet vm = .message(\"要显示的消息内容\").duration(2)\n// 标题 + 正文\nlet vm = .title(\"标题\").message(\"正文\")\n```\n\n内置了几种常见的场景扩展，例如正在加载的场景：\n```swift\nstatic var loading: ViewModel {\n    let obj = ViewModel(icon: UIImage(inProHUD: \"prohud.windmill\"))\n    obj.rotation = .init(repeatCount: .infinity)\n    return obj\n}\nstatic func loading(_ seconds: TimeInterval) -> ViewModel {\n    let obj = ViewModel(icon: UIImage(inProHUD: \"prohud.windmill\"), duration: seconds)\n    obj.rotation = .init(repeatCount: .infinity)\n    return obj\n}\n```\n\n使用的时候可以：\n```swift\n// 无限持续时间\nlet vm = .loading\n// 无限持续时间, 带有文字\nlet vm = .loading.message(\"正在加载\")\n// 持续10s\nlet vm = .loading(10)\n// 持续10s, 带有文字\nlet vm = .loading(10).message(\"正在加载\")\n```\n\n### 方式二：以闭包形式创建并显示实例\n\n对于复杂实例，建议以这种方式使用，例如给实例增加事件响应：\n\n```swift\nlet title = \"您收到了一条消息\"\nlet message = \"点击通知横幅任意处即可回复\"\nToast { toast in\n    toast.vm = .msg.title(title).message(message)\n    toast.onTapped { toast in\n        toast.pop()\n        Alert(.success(1).message(\"操作成功\")).push()\n    }\n}\n```\n\n也可以增加多个按钮，横向平铺，在这个例子中，左侧图标位置自定义为头像：\n```swift\nlet title = \"您收到了一条好友申请\"\nlet message = \"丹妮莉丝·坦格利安申请添加您为好友，是否同意？\"\nToast(.title(title).message(message)) { toast in\n    toast.isRemovable = false\n    toast.vm.icon = UIImage(named: \"avatar\")\n    toast.imageView.layer.masksToBounds = true\n    toast.imageView.layer.cornerRadius = toast.config.iconSize.width / 2\n    toast.add(action: \"拒绝\", style: .destructive) { toast in\n        // 按钮点击事件回调\n        ...\n    }\n    toast.add(action: \"同意\") { toast in\n        // 按钮点击事件回调\n        toast.pop()\n        Alert(.success(1).message(\"Good choice!\")).push()\n    }\n}\n```\n\n{% frame iphone11 img:/assets/wiki/prohud/toast/buttons.jpg focus:top %}\n\n\n### 如果存在就更新，不存在就创建新的实例\n\n例如弹出一个loading，有多个地方需要更新这个loading，为了避免重复弹出多个实例，可以使用 `lazyPush` 方法：\n\n```swift\nToast.lazyPush(identifier: \"loading\") { toast in\n    toast.vm = .loading.title(\"正在加载\\(i)\").message(\"这条消息不会重复显示多条\")\n}\n```\n\n### 如果存在就更新，不存在就忽略指令\n\n如果要对一个已经存在的实例进行更新，假如实例已经结束显示了，那就不进行任何操作，这时候可以使用 `find` 方法：\n\n```swift\nToast.find(identifier: \"loading\") { toast in\n    toast.vm = .success(2).message(\"加载成功\")\n}\n```\n\n\n{% frame iphone11 img:/assets/wiki/prohud/toast/demo-update.png video:/assets/wiki/prohud/toast/demo-update.mp4 focus:top %}\n\n## Alert（页面中心弹窗）\n\n弹窗控件，用于强阻塞性交互，用户必须做出选择或者等待结果才能进入下一步，当多个实例出现时，会以堆叠的形式显示，新的实例会在覆盖旧的实例上层。\n\nAlert和Toast一样有两种创建方法，不再赘述。\n\n{% frame iphone11 img:/assets/wiki/prohud/alert/demo-stack.png video:/assets/wiki/prohud/alert/demo-stack.mp4 %}\n\n### 修改实例内容\n\n在实例弹出后仍然可以修改实例内容：\n\n```swift\n// 持有实例的情况下：\nAlert(.note) { alert in\n    alert.vm.message = \"可以动态增加、删除、更新文字\"\n    alert.add(action: \"增加标题\") { alert in\n        alert.vm.title = \"这是标题\"\n        alert.reloadTextStack()\n    }\n    alert.add(action: \"增加正文\") { alert in\n        alert.vm.message = \"可以动态增加、删除、更新文字\"\n        alert.reloadTextStack()\n    }\n    alert.add(action: \"删除标题\", style: .destructive) { alert in\n        alert.vm.title = nil\n        alert.reloadTextStack()\n    }\n    alert.add(action: \"删除正文\", style: .destructive) { alert in\n        alert.vm.message = nil\n        alert.reloadTextStack()\n    }\n    alert.add(action: \"取消\", style: .gray)\n}\n// 未持有实例时，可通过 identifier 查找并更新：\nAlert.find(identifier: \"my-alert\") { alert in\n    alert.vm.title = \"这是标题\"\n    alert.reloadTextStack()\n}\n```\n\n{% frame iphone11 img:/assets/wiki/prohud/alert/demo-update.png video:/assets/wiki/prohud/alert/demo-update.mp4 %}\n\n### 按钮的增删改查\n\n```swift\nAlert(.note) { alert in\n    alert.vm.message = \"可以动态增加、删除按钮\"\n    alert.add(action: \"在底部增加按钮\", style: .filled(color: .systemGreen)) { alert in\n        alert.add(action: \"哈哈1\", identifier: \"haha1\")\n    }\n    alert.add(action: \"在当前按钮下方增加\", style: .filled(color: .systemIndigo), identifier: \"add\") { alert in\n        alert.insert(action: .init(identifier: \"haha2\", style: .light(color: .systemOrange), title: \"哈哈2\", handler: nil), after: \"add\")\n    }\n    alert.add(action: \"修改当前按钮文字\", identifier: \"edit\") { alert in\n        alert.update(action: \"已修改\", for: \"edit\")\n    }\n    alert.add(action: \"删除「哈哈1」\", style: .destructive) { alert in\n        alert.remove(actions: .identifiers(\"haha1\"))\n    }\n    alert.add(action: \"删除「哈哈1」和「哈哈2」\", style: .destructive) { alert in\n        alert.remove(actions: .identifiers(\"haha1\", \"haha2\"))\n    }\n    alert.add(action: \"删除全部按钮\", style: .destructive) { alert in\n        alert.remove(actions: .all)\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n            alert.pop()\n        }\n    }\n    alert.add(action: \"取消\", style: .gray)\n}\n```\n\n### 添加自定义控件\n\n```swift\nAlert { alert in\n    alert.vm.title = \"自定义控件\"\n    // 图片\n    let imgv = UIImageView(image: UIImage(named: \"landscape\"))\n    imgv.contentMode = .scaleAspectFill\n    imgv.clipsToBounds = true\n    imgv.layer.cornerRadiusWithContinuous = 12\n    alert.add(subview: imgv).snp.makeConstraints { make in\n        make.height.equalTo(120)\n    }\n    // seg\n    let seg = UISegmentedControl(items: [\"开发\", \"测试\", \"预发\", \"生产\"])\n    seg.selectedSegmentIndex = 0\n    alert.add(subview: seg).snp.makeConstraints { make in\n        make.height.equalTo(40)\n        make.width.equalTo(400)\n    }\n    // slider\n    let slider = UISlider()\n    slider.minimumValue = 0\n    slider.maximumValue = 100\n    slider.value = 50\n    alert.add(subview: slider)\n    alert.add(spacing: 24)\n    alert.add(action: \"取消\", style: .gray)\n}\n```\n\n{% frame iphone11 img:/assets/wiki/prohud/alert/custom.png %}\n\n## Sheet（底部操作表）\n\n操作表控件，用于弱阻塞性交互。显示区域为从屏幕底部向上弹出的新图层，可以放置丰富的内容，自由度较高。\n\n{% frame iphone11 img:/assets/wiki/prohud/sheet/regular.jpg focus:bottom %}\n\n### 布局\n\n操作表控件空间较大，可以放置更多的文字、按钮和其它任何控件。\n\n```swift\nSheet { sheet in\n    sheet.add(title: \"ProHUD\")\n    sheet.add(subTitle: \"什么是操作表控件\")\n    sheet.add(message: \"操作表控件，用于弱阻塞性交互。显示区域为从屏幕底部向上弹出的新图层，可以放置丰富的内容，自由度较高。\")\n    sheet.add(spacing: 24)\n    sheet.add(action: \"确认\", style: .destructive) { sheet in\n        Alert(.confirm) { alert in\n            alert.vm.title = \"处理点击事件\"\n            alert.add(action: \"我知道了\")\n        }\n    }\n    sheet.add(action: \"取消\", style: .gray)\n}\n```\n\n同样支持添加任意其它视图：\n\n```swift\nSheet { sheet in\n    sheet.add(title: \"ProHUD\")\n    // 图片\n    let imgv = UIImageView(image: UIImage(named: \"landscape\"))\n    imgv.contentMode = .scaleAspectFill\n    imgv.clipsToBounds = true\n    imgv.layer.cornerRadiusWithContinuous = 16\n    sheet.add(subview: imgv).snp.makeConstraints { make in\n        make.height.equalTo(200)\n    }\n    // seg\n    let seg = UISegmentedControl(items: [\"开发\", \"测试\", \"预发\", \"生产\"])\n    seg.selectedSegmentIndex = 0\n    sheet.add(subview: seg).snp.makeConstraints { make in\n        make.height.equalTo(40)\n        make.width.equalTo(400)\n    }\n    // slider\n    let slider = UISlider()\n    slider.minimumValue = 0\n    slider.maximumValue = 100\n    slider.value = 50\n    sheet.add(subview: slider).snp.makeConstraints { make in\n        make.height.equalTo(50)\n    }\n}\n```\n\n{% frame iphone11 img:/assets/wiki/prohud/sheet/custom.jpg focus:bottom %}\n\n### 拦截背景点击事件\n\n有时候如果不希望点击背景直接`pop`掉，可以实现 `onTappedBackground` 以拦截背景点击事件\n\n```swift\nSheet { sheet in\n    sheet.add(title: \"ProHUD\")\n    sheet.add(message: \"点击背景将不会dismiss，必须在下方做出选择才能关掉\")\n    sheet.add(spacing: 24)\n    sheet.add(action: \"确认\")\n    sheet.add(action: \"取消\", style: .gray)\n} onTappedBackground: { sheet in\n    print(\"点击了背景\")\n    Toast.lazyPush(identifier: \"alert\") { toast in\n        toast.vm = .error\n        toast.vm.title = \"点击了背景\"\n        toast.vm.message = \"点击背景将不会dismiss，必须在下方做出选择才能关掉\"\n        toast.vm.duration = 2\n    }\n}\n```\n\n## 定制属于自己的UI\n\n### 个性化配置\n\nProHUD内置的布局也支持丰富的个性化参数，例如：\n\n- 标题、正文、按钮字体字号\n- 背景颜色、模糊效果\n- 文字颜色\n- 图标大小\n- 卡片圆角\n- Sheet组件卡片距离屏幕的边距\n\n具体请探索 `ProHUD.Configuration` 类代码。\n\n### 完全自定义布局\n\nProHUD支持完全自定义布局，即将整个容器交给使用者来布局，在 `Alert.Configuration.shared` 中配置了 `reloadData` 规则之后，实例在显示前以及更新内容时都会进入此函数，执行自定义的 `reloadData` 代码。也可以指定部分 `identifier` 走自定义布局代码，其余走内置布局代码，例如：\n\n```swift\nAlert.Configuration.shared { config in\n    config.reloadData { vc in\n        if vc.identifier == \"custom\" {\n            return true\n        }\n        return false\n    }\n}\nAlert { alert in\n    alert.identifier = \"custom\"\n    alert.contentView.backgroundColor = .systemYellow\n    alert.view.addSubview(alert.contentView)\n    alert.contentView.layer.cornerRadiusWithContinuous = 32\n    alert.contentView.snp.makeConstraints { make in\n        make.width.equalTo(UIScreen.main.bounds.width - 100)\n        make.height.equalTo(UIScreen.main.bounds.height - 200)\n        make.center.equalToSuperview()\n    }\n    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n        alert.pop()\n    }\n}\n```\n\n{% frame iphone11 img:/assets/wiki/prohud/sheet/background.jpg focus:bottom %}\n\n## 横屏和iPad适配\n\n{% swiper width:max %}\n![](/assets/wiki/prohud/toast/landscape.png)\n![](/assets/wiki/prohud/sheet/landscape.png)\n{% endswiper %}\n"},{"title":"一个简约的在线简历主题","url":"/wiki/resume/index.html","content":"\n{% link https://resume.js.org/zh-cn/ 在线演示 %}\n{% link https://github.com/xaoxuu/hexo-theme-resume 主题源码 %}\n\n<!-- more -->\n\n## 如何使用\n\n### 方式一\n\n1. 下载 [示例源码](https://github.com/xaoxuu/resume-docs) 的整个仓库代码。\n```sh\ngit clone https://github.com/xaoxuu/resume-docs\n```\n\n2. 然后安装必要的依赖包\n```sh\nnpm i\n```\n\n\n### 方式二\n\n创建全新的博客，通过 `npm` 命令安装：\n\n```sh\nnpm i hexo-theme-resume\n```\n\n然后删除多余的依赖包（重要），打开 `package.json` 复制并全部替换为以下内容：\n\n```json\n{\n  \"name\": \"hexo-site\",\n  \"private\": true,\n  \"hexo\": {\n    \"version\": \"5.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hexo server\",\n    \"build\": \"node pre-deploy.js && hexo clean && hexo generate\",\n    \"deploy\": \"npm run build && hexo deploy\"\n  },\n  \"engines\": {\n    \"node\": \">=8.9.0\"\n  },\n  \"dependencies\": {\n    \"hexo\": \"^5.0.0\",\n    \"hexo-all-minifier\": \"^0.5.3\",\n    \"hexo-autonofollow\": \"^1.0.1\",\n    \"hexo-deployer-git\": \"^2.1.0\",\n    \"hexo-fs\": \"^3.1.0\",\n    \"hexo-lazyload-image\": \"^1.0.9\",\n    \"hexo-offline\": \"^1.0.0\",\n    \"hexo-renderer-ejs\": \"^1.0.0\",\n    \"hexo-renderer-marked\": \"^3.0.0\",\n    \"hexo-renderer-stylus\": \"^1.1.0\",\n    \"hexo-server\": \"^1.0.0\"\n  }\n}\n```\n\n然后输入 `npm i` 安装依赖包。\n\n\n## 编写简历\n\n打开 `index.md` 文件：\n```\nresume-docs/src/index.md\n```\n\n按照示例中的提示语将信息修改为自己的。\n\n## 部署\n\n打开站点配置文件：\n```yaml resume-docs/_config.yaml\ndeploy:\n  - type: git\n    repo: # 项目路径\n    branch: master\n    message: update pages\n```\n\nHexo官方教程：https://hexo.io/zh-cn/docs/one-command-deployment\n\n{% border 小提示 %}\n\n图标从这里找：https://fontawesome.com/\n如果需要更多DIY，请自行修改源码。\n简历主题不支持评论，如果需要，请自行集成。\n\n{% endborder %}\n"},{"title":"蓝牙智能灯毕业设计项目","url":"/wiki/smartlamp/index.html","content":"\n{% swiper %}\n![](/assets/wiki/smartlamp/screenshot01.png)\n![](/assets/wiki/smartlamp/screenshot02.png)\n![](/assets/wiki/smartlamp/screenshot03.png)\n![](/assets/wiki/smartlamp/screenshot04.png)\n![](/assets/wiki/smartlamp/screenshot05.png)\n![](/assets/wiki/smartlamp/screenshot06.png)\n{% endswiper %}\n\n<!-- more -->\n\n## 特性\n\n**调节亮度、颜色、定时关闭**\n\n主页是核心功能，实现一键连接蓝牙灯、自由调节颜色、亮度、设置定时关灯等功能。\n情景页是保存用户设置的情景模式，可以根据使用场景不同快速切换至对应的工作模式。\n设备页可以管理多台蓝牙灯。\n发现页提供一些智能家居相关资讯。\n\n\n##   技术点\n\n### ATTitleBar\n\n- 支持横向滑动切换tab，并具有点击涟漪效果。\n- titlebar是在app中广泛应用的一种tab设计。我写的这个小框架模仿Google的Material Design设计，涟漪效果代码由MaterialControls框架改写。\n- 页面较多时采用类似tableview的懒加载模式，只加载需要显示的几页，减少内存占用，提高流畅度。\n\n### ReactiveCocoa\n\n- 本项目大量使用了ReactiveCocoa框架进行响应式编程，大幅简化代码、提高可读性。\n- RAC的订阅机制使得一对多传值有了新的选择，如蓝牙中心设备。\n- RAC的信号监听机制使得我更容易根据需要定制个性化控件。如带翻转、旋转效果的tabbar、带缩放和回弹效果的slider等，使app的界面栩栩如生。\n\n### CBCentralManager\n\n- CBCentralManager是蓝牙类app的核心，本项目在编写这部分代码时使用了链式语法进行封装，外界调用起来十分方便。\n\n### ATCarouselView\n\n- 轮播图也是在app中广泛存在的一种自定义控件，我将这部分代码封装至ATKit中，以Pods导入方式使用，便于维护和扩展，同时也使得本项目代码更加简洁。\n- 部分app的轮播图可以根据下方列表的滑动而改变高度或者添加蒙版效果，我目前实现了改变高度的功能。\n"},{"title":"安装与更新","url":"/wiki/stellar/index.html","content":"\nStellar 是一个内置文档系统的简约商务风 Hexo 主题，支持丰富的标签和动态数据组件，帮助您简单从容地应对各种表达需求，十分推荐内容创作者使用 Stellar 开始您全新的博客之旅。\n\n{% folding 了解 Stellar 的设计理念 %}\n\n**“真正的简约远不止删繁就简，而是在纷繁中建立秩序。”**\n\n人的注意力是有限的，要提高有效信息的醒目程度，就必须降低不重要信息醒目程度，删除所有无效信息。\n\n**降低视觉密度**\n\n- 增加留白，增加间距。\n- 减少颜色丰富度，大面积出现的是中性色，彩色必须有其特殊意义，意义相同的元素使用同一种颜色。\n\n**提高有效信息优先级**\n\n- 文章标题永远是最大的，对比度最高的\n- 不可交互的不重要的小标题（如侧边栏某个插件的标题）降低对比度\n- 与文章相关的不重要的小标题，使用小号字体\n\n**删掉无效信息**\n\n- 文章标签、字数、阅读量、评论数\n- 网站访问量、字数、搭建时间\n- 全局播放器（除了特殊文章）\n\n{% endfolding %}\n\n## 开始前的准备工作\n\n尽管我们致力于降低使用门槛，但是自建独立博客仍然需要一定的相关知识，[markdown](https://www.runoob.com/markdown/md-tutorial.html) 常用语法是必须要掌握的，除此之外，您还需要知道 `yaml` 文件格式、简单的 `git` 知识，最最重要的是，遇到问题知道该如何高效地寻找答案：\n\n{% checkbox checked:true 翻阅和搜索文档 %}\n{% checkbox checked:true 搜索 issues 中是否已经有解决办法 %}\n{% checkbox checked:true 如果没有，新建 issue 并按照要求进行操作，详尽地描述您遇到的问题 %}\n\n**如果您没有使用过 Hexo 也不要着急，我十分建议您去通读一遍 [Hexo](https://hexo.io/zh-cn/docs/) 中文文档**。\n\n{% link https://hexo.io/zh-cn/docs/ %}\n\n此外，如果您从旧版本更新或者其它主题迁移，请确保环境版本不要太低，否则会产生兼容性问题：\n\n```yaml 建议的版本\nHexo: 5.4.0 ~ 6.3.0\nhexo-cli: 4.3.0 ~ latest\nnode.js: 14.17.3 ～ 18.12.0 # 建议选择 LTS 版本，过高的版本 hexo 还没有进行兼容。\nnpm: 6.14.13 ~ 8.19.2\n```\n\n## 安装与更新\n\n{% border %}\n{% tabs %}\n\n<!-- tab 稳定版 -->\n\n**安装方法**\n\n1. 在终端中输入：\n{% copy npm i hexo-theme-stellar %}\n\n2. 在 `blog/_config.yml` 文件中找到并修改：\n{% copy theme: stellar %}\n\n**更新方法**\n\n1. 在 package.json 中修改 stellar 的版本号，然后执行：\n{% copy npm i %}\n\n2. 阅读 [更新日志](https://github.com/xaoxuu/hexo-theme-stellar/releases) 进行迁移操作。\n\n{% note color:green 适用范围 稳定版适用于以内容创作为主，不需要自定义主题，追求稳定和可靠性的用户。 %}\n\n<!-- tab 最新版 -->\n\n**安装方法**\n\n1. 把 Stellar 主题仓库添加为博客仓库的子模块\n{% copy git submodule add https://github.com/xaoxuu/hexo-theme-stellar.git themes/stellar %}\n\n2. 在 `blog/_config.yml` 文件中找到并修改：\n{% copy theme: stellar %}\n\n**更新方法**\n\n1. 打开终端并进入主题文件夹，执行：\n{% copy git pull %}\n\n2. 阅读 [更新日志](https://github.com/xaoxuu/hexo-theme-stellar/releases) 进行迁移操作。\n\n{% note color:blue 适用范围 最新版适用于以内容创作为主，不需要自定义主题，追求新特性的用户。 %}\n\n<!-- tab 自定义 -->\n\n**安装方法**\n\n1. 把 Stellar 主题仓库 [fork](https://github.com/xaoxuu/hexo-theme-stellar) 到您的 GitHub 账号下\n\n2. 把您 fork 的 Stellar 主题仓库添加为博客仓库的子模块\n{% copy git submodule add https://github.com/#yourname#/hexo-theme-stellar.git themes/stellar %}\n\n3. 在 `blog/_config.yml` 文件中找到并修改：\n{% copy theme: stellar %}\n\n**更新方法**\n\n1. 在您 fork 的 Stellar 主题仓库打开终端，执行：\n{% copy git pull %}\n\n2. 阅读 [更新日志](https://github.com/xaoxuu/hexo-theme-stellar/releases) 进行迁移操作。\n\n{% note color:yellow 适用范围 自定义版适用于对主题有自定义需求，且掌握了一定的前端知识和动手能力的用户。 %}\n\n**自动更新💡**\n\n安装并授权 [pull](https://github.com/apps/pull) 这个机器人，当源仓库发生更新时，机器人会自动提 `PR` 到自己 `fork` 的仓库中。\n\n<!-- tab 引用源码 -->\n\n**安装方法**\n\n下载源码放到 `themes/` 文件夹下面试用。\n\n{% note color:red 适用范围 仅试用，无法获得更新。 %}\n\n{% endtabs %}\n{% endborder %}\n\n\n## 开源许可协议\n\n{% quot 项目中的许可声明文件应包含在所有副本中 %}\n\n本主题是由 [@xaoxuu](https://github.com/xaoxuu) 设计和开发，使用 [MIT License](https://fastly.jsdelivr.net/gh/xaoxuu/hexo-theme-stellar/LICENSE) 开源许可协议进行授权，拷贝、分享或基于此进行创作时请遵守协议内容：\n\n```license\nMIT License\n\nCopyright (c) 2021 xaoxuu\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n"},{"title":"实用的ObjC安全对象类型转换库","url":"/wiki/valuex/index.html","content":"\n## 特性\n\n- 有效避免后台返回数据类型异常导致程序崩溃\n- 快速由已知对象得到期望的对象类型\n\n## 开始使用\n\n```ruby 在 Podfile 中添加：\npod 'ValueX'\n```\n\n```sh 然后执行：\npod install\n```\n\n### 确保类型正确\n\n以字符串为例，通过 `NSSafeString(obj)` 拿到的值如果不为空，则其类型一定是 `NSString`，不会是 `NSNumber` 或者 `NSNull`。\n\n\n{% folding child:codeblock open:true 测试代码 %}\n```ObjC\n- (void)test01 {\n    NSDictionary *d1 = @{@\"name\": @\"Mr. Xu\", @\"info\": @\"{\\n    \\\"age\\\" : \\\"23\\\",\\n    \\\"userId\\\" : \\\"123123123\\\",\\n    \\\"deviceId\\\" : \\\"<null>\\\"\\n}\"};\n    NSLog(@\"\\nd1: %@\", d1);\n    NSDictionary *d11 = NSSafeDictionary([d1 dictionaryForKey:@\"name\"]);\n    NSDictionary *d12 = NSSafeDictionary([d1 dictionaryForKey:@\"info\"]);\n    NSLog(@\"\\n d11: %@,\\n d12: %@\", d11, d12);\n\n    NSDictionary *d2 = @{@\"age\": @23, @\"userId\": @\"123123123\", @\"deviceId\": @\"<null>\"};\n    NSLog(@\"\\nd2: %@\", d2);\n    NSNumber *d21 = [d2 numberForKey:@\"userId\"];\n    NSString *d22 = [d2 stringForKey:@\"userId\"];\n    NSNumber *d23 = [d2 numberForKey:@\"age\"];\n    NSString *d24 = [d2 stringForKey:@\"age\"];\n    NSNumber *d25 = [d2 numberForKey:@\"deviceId\"];\n    NSString *d26 = [d2 stringForKey:@\"deviceId\"];\n    NSLog(@\"\\n d21: %@,\\n d22: %@,\\n d23: %@,\\n d24: %@,\\n d25: %@,\\n d26: %@\", d21, d22, d23, d24, d25, d26);\n}\n```\n{% endfolding %}\n\n\n### 安全地获取字典值\n\n字典中的值存在很多不确定性，例如 `age` 可能是 `NSNumber`，也可能是 `NSNull` 的实例对象。\n\n通过 `[dict numberForKey:@\"age\"]` 得到的值，如果不为空，则一定是 `NSNumber` 的实例对象。\n\n{% folding child:codeblock open:true 测试代码 %}\n```ObjC\n/**\n 测试: 从后台接收到字典\n\n @param value 后台返回的字典数据\n */\n- (void)test1:(NSDictionary *)value {\n    NSLog(@\"value: %@\", value);\n    // 真实类型并不一定是NSDictionary，要确保拿来用的时候一定是NSDictionary\n    VXObject *vx = ValueX(value);\n    NSDictionary *dict = ValueX(value).dictionaryValue;\n    NSLog(@\"ValueX(value).dictionaryValue: %@\", dict);\n    // 获取其中的某个值\n    NSNumber *deviceId = [dict numberForKey:@\"deviceId\"];\n    NSString *userId = [dict stringForKey:@\"userId\"];\n    NSNumber *age = [dict numberForKey:@\"age\"];\n    NSLog(@\"deviceId: %@, userId: %@, age: %@\", deviceId, userId, age);\n    NSString *str = vx.stringValue;\n    NSLog(@\"ValueX(value).stringValue: %@\", str);\n}\n```\n{% endfolding %}\n\n### 数据类型转换\n\n如果我们已知一个字典，想要得到它的Json字符串，只需要通过 `ValueX(dict).stringValue` 获取。\n\n同理，只要是能互相转换的值均能通过类似的格式一行代码获取，如果不能转换，得到的值是 `nil`。\n\n{% folding child:codeblock open:true 测试代码 %}\n```ObjC\n- (void)test2:(NSDictionary *)value {\n    NSLog(@\"value: %@\", value);\n    // 真实类型并不一定是NSDictionary，要确保拿来用的时候一定是NSDictionary\n    NSDictionary *dict = ValueX(value).dictionaryValue;\n    NSLog(@\"ValueX(value).dictionaryValue: %@\", dict);\n    // 获取其中的某个值\n    NSDictionary *info = [dict dictionaryForKey:@\"info\"];\n    NSLog(@\"info: %@\", info);\n}\n```\n{% endfolding %}\n"},{"title":"Volantis for Hexo","url":"/wiki/volantis/index.html","content":"\nVolantis 是一个高度模块化的 Hexo 主题，拥有丰富的内置标签和第三方插件支持，拥有庞大的开发者团队和年轻活跃的社区文化。得益于其强大的模块化特性，您可以轻松搭建一个极简风格的轻博客，也可以仿照社区主页搭建一个多人协作的、包含 wiki 的综合型站点。\n\nVolantis {% mark X %} 是 Volantis 社区文化的符号。在过去的{% mark 五 %}年里，{% mark 40+ %} 开发者为其贡献了 {% mark 2200+ %} commits，数以千计的用户为瓦兰提斯点亮了星星，{% mark 60+ %} 来自各行各业的热情的小伙伴们参与了社区建设，因为大家的参与，Volantis 变得越来越强大和富有生命力。\n\n{% link https://volantis.js.org %}\n\n## 开始之前\n\n尽管我们致力于降低使用门槛，但是自建独立博客仍然需要一定的相关知识，[markdown](https://www.runoob.com/markdown/md-tutorial.html) 常用语法是必须要掌握的，除此之外，您还需要知道 `yaml` 文件格式、简单的 `git` 知识，最最重要的是，遇到问题知道该如何高效地寻找答案：\n\n1. 翻阅和搜索文档\n2. 搜索 issues 中是否已经有解决办法\n3. 如果没有，新建 issue 并按照要求进行操作，详尽地描述您遇到的问题\n\n如果您没有使用过 Hexo 也不要着急，可以先通读一遍 [Hexo](https://hexo.io/zh-cn/docs/) 中文文档，要想使用地得心应手，最好参照团队提供的开源项目的源码进行搭建：\n\n[Demo 源码](https://github.com/volantis-x/demo)｜[官网源码](https://github.com/volantis-x/community)\n\n如果您从旧版本更新或者其它主题迁移，请确保环境版本不要太低，否则会产生兼容性问题。\n\n```yaml\nHexo: 5.3.0\nhexo-cli: 4.2.0\nnode.js: 14.15.4 LTS # 选 LTS 就行，过高的版本 hexo 还没有进行兼容。\nnpm: 6.14.10 LTS\n```\n\n## 快速体验\n\n如果您已经具备环境配置条件，可以在终端中输入下面这行代码，稍等片刻就可以看到示例站点已经运行起来了：\n\n{% copy git clone https://github.com/volantis-x/demo.git && cd demo && npm i && hexo s %}\n\n## 下载与安装\n\n- 如果您是 Mac 用户，可以在博客路径打开终端，下载安装并应用主题：\n{% copy curl -s https://volantis.js.org/start | sh %}\n\n- 如果您是内容创作者，推荐使用 npm 稳定版本：\n{% copy npm i hexo-theme-volantis %}\n\n- 如果您需要定制主题，请 [fork](https://github.com/volantis-x/hexo-theme-volantis/) 主题，然后添加为子模块，详细教程如下：\n{% link https://github.com/volantis-x/hexo-theme-volantis/issues/459#issuecomment-679465906 如何正确地更新主题（Fork篇） %}\n{% note color:orange 温馨提示 请一定不要直接下载源码并进行修改使用，因为这样会导致**失去版本管理系统**且**无法获得更新**。 %}\n\n## 配置与使用\n\n完整而详细的文档请移步 Volantis 社区查看：\n\n{% link https://volantis.js.org/v4/site-settings/ %}\n\n{% image https://api.star-history.com/svg?repos=volantis-x/hexo-theme-volantis&type=Date %}"},{"title":"[blog] 管理与发布博客的脚本","url":"/wiki/cloud-shell/blog/index.html","content":"\nMac 用户可以在终端体验一下：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s blog && blog init %}\n\n这条指令可以自动检测并安装必要环境和依赖，并初始化一个博客。\n\n## 下载并安装脚本\n\n> 如果您已经执行过上面那条命令，就已经安装过了，可以跳过此步骤。\n\n打开终端，输入这行命令：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s blog %}\n\n如需安装指定分支或版本，在后面加上分支名或版本号即可，例如：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s blog main %}\n\n## 使用方法\n\n> 在忘记功能的时候可以输入 `blog help` 以打开此页面查看脚本所有支持的指令。\n\n### 快速搭建环境\n\n如果您重装了系统或者更换了电脑，可以 copy 这条命令迅速完成环境的搭建：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s blog check %}\n\n\n### 新用户快速搭建博客\n\n如果您从未使用过 hexo 博客，那么可以执行这条命令完成初始化并看到效果：\n\n{% tabs align:center %}\n<!-- tab 已安装blog脚本 -->\n{% copy blog init %}\n<!-- tab 未安装blog脚本 -->\n{% copy curl -s https://sh.xaox.cc/install | sh -s blog && blog init %}\n{% endtabs %}\n\n脚本会依次执行以下这些操作：\n1. 检测 node.js 环境，如果没有就安装。\n2. 检测 hexo 环境，如果没有就安装。\n3. 输入自定义博客名，在当前目录执行初始化。\n4. 安装 Stellar 主题。\n5. 安装所有依赖包。\n6. 执行 hexo s 运行博客。\n7. 打开 localhost:4000 预览博客。\n\n{% note color:yellow 注意 安装 node.js 或者 hexo 的时候需要输入一次**本机密码**，别忘了哦。搭建博客的时候你需要输入**博客名**，其他时间就可以坐和放宽了。 %}\n\n### 使用脚本快速更新博客\n\n有时候如果修改了 `_config.yml` 是需要重新启动博客的，有些参数甚至需要 `clean` 之后重启才能生效，这时候你只需要输入：\n\n{% copy width:max blog cs %}\n\n就执行 `hexo clean && hexo server` 了。\n\n如果你已经修改完毕，需要发布更新，可以输入：\n\n{% copy width:max blog cgd %}\n\n脚本就会执行 `hexo clean`、`hexo generate`、`hexo deploy`，然后执行一系列的 git 命令把源码的更新提交至远程仓库。\n\n\n## 所有支持的命令\n\n| 命令 | 功能 |\n| :-- | :-- |\n| `blog init` | 检查并安装环境，然后创建并运行博客 |\n| `blog test` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog test stellar` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog test vlts` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog test 主题名` | 检查并安装环境，然后创建并运行单元测试博客（用于查看未经修改的主题效果） |\n| `blog i node` | 安装 node.js  |\n| `blog i hexo` | 安装 hexo  |\n| `blog i stellar` | 安装 stellar 主题，同理换成其它主题名字都可以 |\n| `blog i 主题名` | 安装任意主题 |\n| `blog c` | 同 `hexo clean` 然后打开 `localhost:4000` |\n| `blog cs` | 同 `hexo clean && hexo g` 然后打开 `localhost:4000` |\n| `blog cgd` | 同 `hexo clean && hexo g && hexo d && git add --all && git commit && git push origin` |\n| `blog help` | 打开文档页面 |\n\n> 其中，上述的「主题名」需要是发布到 [npmjs.org](https://www.npmjs.com/) 的主题，匹配到 `hexo-theme-主题名` 的部分。"},{"title":"[podspec] 快速发布 podspec 版本的脚本","url":"/wiki/cloud-shell/podspec/index.html","content":"\n\n## 开始使用\n\nlet `path` = 你的项目的 `podspec` 所在的路径\n\n打开终端，cd 到 `path` ，输入下面这条命令下载脚本到当前文件夹：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s podspec %}\n\n如需安装指定版本，在后面加上版本号即可，例如：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s podspec 1.2.1 %}\n\n需要发布 podspec 到时候，在终端中输入：\n\n{% copy width:max . podspec.sh %}\n\n就会自动开始执行发布流程。\n\n## 发布流程\n\n- 如果目录下有一个 podspec 文件，直接询问版本号，然后打包验证、询问是否发布。\n- 如果目录下有多个 podspec 文件，遍历每一个 podspec 文件，询问版本号，然后打包验证、询问是否发布。\n\n## 脚本运行权限\n\n如果提示没有权限，就输入以下命令修改 `podspec.sh` 的权限\n\n{% copy width:max chmod 777 podspec.sh %}\n"},{"title":"[tag] 快速发布 git 版本的脚本","url":"/wiki/cloud-shell/tag/index.html","content":"\n\n## 安装脚本\n\n打开终端，输入并执行这一行命令即可：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s tag %}\n\n## 发布版本\n\n当您需要进行版本发布时，在 git 仓库中打开终端，输入：\n\n```sh\ntag 版本号 描述\n```\n\n然后稍等片刻即可完成发布。\n\n\n## 删除版本\n\n```sh\ntag del 版本号\n```\n"},{"title":"[vimcn] 快速批量上传图片的脚本","url":"/wiki/cloud-shell/vimcn/index.html","content":"\n<!-- more -->\n\n## 直接使用\n\n打开终端，`cd` 到存放图片的文件夹，输入这行命令就开始上传图片：\n\n{% copy width:max curl -s https://sh.xaox.cc/run/vimcn/main/upload.sh | sh %}\n\n{% note color:cyan 为了简化指令，建议下载安装后使用。 %}\n\n## 安装脚本\n\n打开终端，输入这行命令：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s vimcn %}\n\n如需安装指定版本，在后面加上版本号即可，例如：\n\n{% copy width:max curl -s https://sh.xaox.cc/install | sh -s vimcn 2.1.0 %}\n\n然后就会开始下载脚本并安装到 `usr/local/bin` 路径，可能需要输入电脑密码以授权。\n\n## 上传文件\n\n需要上传图片到时候，打开终端，`cd` 到存放图片的文件夹，输入 `upload` 就可以了。当然，还可以传递参数：\n\n```sh\nupload [扩展名] [操作]\n```\n\n| 扩展名                             | 含义               |\n| :---------------------------------- | :------------------ |\n| `all` 或者不传任何参数  | 上传所有格式的文件   |\n| `png`、`jpg`、`ico` 等具体的某个扩展名 | 上传指定格式的文件 |\n\n| 操作            | 含义               |\n| :--------------- | :------------------ |\n| `open` | 上传成功后打开链接 |\n\n\n{% folding 常见的用法示例 %}\n\n上传当前文件夹中的所有文件\n\n```sh\nupload\n```\n\n上传当前文件夹中的所有文件，并打开链接\n\n```sh\nupload all open\n```\n\n上传当前文件夹中的所有png格式的图片\n\n```sh\nupload png\n```\n{% endfolding %}\n\n\n## 支持的文件格式\n\n\n经测试，可以上传的格式有：png、jpg、ico、gif、svg、tiff、webp、pdf、mp3、mp4、zip等。\n\n支持的文件大小大概在 50MB 以内。\n\n## 请勿滥用\n\n{% note color:yellow 注意 为了大家都能愉快使用，请不要上传一些奇奇怪怪的图片。 %}\n"},{"title":"搭建 Git 服务器","url":"/wiki/git/git-server/index.html","content":"\n网上相关教程挺多，但是步骤略繁琐，本文将借助 Gitblit 开源工具使用最简单的方式搭建和维护 Git 服务器，支持 Linux、Windows、Mac 平台。\n\n<!-- more -->\n\n## 服务器搭建\n\n### 安装 JDK\n\n下载并安装 JDK：https://www.oracle.com/java/technologies/javase-downloads.html\n\n### 安装并配置 Gitblit\n\n- 下载 Gitblit：https://github.com/gitblit/gitblit\n- 解压 Gitblit，进入目录 `~/gitblit-1.8.0/data/defaults.properties`\n- 用编辑器打开 `defaults.properties`\n```\ngit.repositoriesFolder = /Users/用户名/gitserver/gitRepository\nserver.httpPort = 7070\n```\n\n\n### 启动服务\n\n在终端中执行 `gitblit.sh` 脚本即可启动服务：\n```sh\n./gitblit.sh\n```\n\n{% folding 建议设置开机自启动 %}\n通过 Mac 的自动化工具，将启动指令写成脚本，系统启动后自动运行脚本即可。\nWindows 平台可以添加到启动计划任务中。\n{% endfolding %}\n\n## 客户端访问\n\n用服务器 IP + 端口号来访问。例如我的电脑的 IP 是 `10.8.12.200`，那么在局域网内另外一台电脑访问 `http://10.8.12.200:7070` 就可以看到管理页面了：\n\n{% image /assets/wiki/git/gitblit01.jpg width:500px %}\n\n网页操作和使用 GitHub、Coding 等平台相似，非常简单。\n"},{"title":"使用 GitHub","url":"/wiki/git/github/index.html","content":"\n## fork & pull request\n\n- fork 操作相当于把别人的 git 仓库克隆到自己账号中。\n- pull request 则可以将自己 fork 过来的仓库中的修改合并到原仓库中，实现团队协作。\n\n## 静态页面持续集成\n\n### 1. 生成 SSH Key\n\n打开 terminal 输入下面的命令生成 `id_rsa` 和 `id_rsa.pub` 文件：\n\n```sh\nssh-keygen -t rsa -C me@xxx.com\n```\n\n其中 `me@xxx.com` 就是 GitHub 账号的邮箱。\n\n### 2. 填写 Deploy Keys 和 Secrets\n\n{% timeline %}\n\n<!-- node 打开源码仓库，在设置中找到「Secrets」 -->\n\n第 1/3 步：添加 `DEPLOY_KEY` 内容是 `id_rsa` 文件的全部内容。\n第 2/3 步：添加 `EMAIL` 内容是 GitHub 邮箱。\n第 3/3 步：添加 `NAME` 内容是 GitHub 账号名。\n\n<!-- node 打开 deploy 目标仓库，在设置中找到「Deploy Keys」 -->\n\n第 1/1 步：添加 `deploy_key.pub` 内容是 `id_rsa.pub` 文件的全部内容。\n\n{% endtimeline %}\n\n### 3. 在 GitHub 上添加 Actions\n\n在 GitHub 上添加 Actions 内容为：\n\n```yaml .github/workflows/auto-deploy.yml\nname: auto deploy # workflow name\n\non:\n  [push] # 触发事件\n\njobs:\n  build: # job1 id\n    runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu\n    name: A job to deploy blog.\n    steps:\n    - name: Checkout # step1 获取源码\n      uses: actions/checkout@v1 # 使用 actions/checkout@v1\n      with: # 条件\n        submodules: true # Checkout private submodules(themes or something else). 当有子模块时切换分支？\n\n    # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) 缓存压缩 node_modules，不用每次下载，使用时解压，可以加快工作流的执行过程，超过 7 天没有使用将删除压缩包。\n    - name: Cache node modules # step2\n      uses: actions/cache@v1\n      id: cache\n      with:\n        path: node_modules\n        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-node-\n    - name: Install Dependencies # step3 name\n      if: steps.cache.outputs.cache-hit != 'true' # 如果变量 cache-hit 不等于 true\n      run: npm install # 安装 node modules 相关依赖\n\n    # Deploy hexo blog website.\n    - name: Deploy # step4\n      id: deploy\n      uses: sma11black/hexo-action@v1.0.0\n      with:\n        deploy_key: ${{ secrets.DEPLOY_KEY }}\n        user_name: ${{ secrets.NAME }}\n        user_email: ${{ secrets.EMAIL }}\n```\n\n### 4. 大功告成\n\n您可以尝试修改一下源码库，看是否能够成功运行 Actions 。\n\n\n## GitHub API\n\nhttps://docs.github.com/en/graphql\n\n{% note 未完待续 %}\n"},{"title":"安装与配置","url":"/wiki/git/install-and-config/index.html","content":"\n## 安装\n\n{% tabs %}\n\n<!-- tab Linux -->\n{% link https://git-scm.com/download/linux 下载地址 %}\n\n安装指定系统的依赖包：\n\n```centos Centos/RedHat\n$ yum install curl-devel expat-devel gettext-devel \\\n  openssl-devel zlib-devel\n```\n\n```deb Debian/Ubuntu\n$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n  libz-dev libssl-dev\n```\n\n解压安装下载的源码包：\n\n```\n$ tar -zxf git-1.7.2.2.tar.gz\n$ cd git-1.7.2.2\n$ make prefix=/usr/local all\n$ sudo make prefix=/usr/local install\n```\n\n{% folding 使用终端指令安装 %}\n\n**Debian/Ubuntu**\n\n```\n$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n  libz-dev libssl-dev\n\n$ apt-get install git\n\n$ git --version\ngit version 1.8.1.2\n```\n\n**CentOS/RedHat**\n\n```\n$ yum install curl-devel expat-devel gettext-devel \\\n  openssl-devel zlib-devel\n\n$ yum -y install git-core\n\n$ git --version\ngit version 1.7.1\n```\n\n{% endfolding %}\n\n<!-- tab Windows -->\n{% link https://gitforwindows.org/ 下载地址 %}\n\n完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。\n\n在开始菜单里找到 <kbd>Git</kbd> -> <kbd>Git Bash</kbd>，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。\n\n<!-- tab Mac -->\n{% link https://git-scm.com/download/mac 下载地址 %}\n\nMac 自带 git 并且随着系统版本的更新，自带的 git 也会升级到最新，一般无需手动安装。\n\n{% endtabs %}\n\n## 配置\n\nGit 提供了一个叫做 `git config` 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：\n\n- `/etc/gitconfig` 文件：系统中对所有用户都普遍适用的配置。若使用 `git config` 时用 `--system` 选项，读写的就是这个文件。\n- `~/.gitconfig` 文件：用户目录下的配置文件只适用于该用户。若使用 `git config` 时用 `--global` 选项，读写的就是这个文件。\n- 当前项目的 Git 目录中的配置文件（也就是工作目录中的 `.git/config` 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 `.git/config` 里的配置会覆盖 `/etc/gitconfig` 中的同名变量。\n\n### 用户信息\n\n```sh\n$ git config --global user.name xaoxuu\n$ git config --global user.email git@xaoxuu.com\n```\n\n- 如果用了 `--global` 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。\n- 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 `--global` 选项重新配置即可，新的设定保存在当前项目的 `.git/config` 文件里。\n\n### 查看配置信息\n\n```sh\n$ git config --list\nhttp.postbuffer=2M\nuser.name=xaoxuu\nuser.email=git@xaoxuu.com\n```\n\n\n## git-ssh\n\n```\nssh-keygen -t rsa -C user@example.com\n```\n\n其中 `user@example.com` 对应的是你的 Git 邮箱。\n\n{% image /assets/wiki/git/ssh-keys1.png width:400px %}\n\n\nssh-agent 是一种控制用来保存公钥身份验证所使用的私钥的程序，其实 ssh-agent 就是一个密钥管理器，运行 ssh-agent 以后，使用 ssh-add 将私钥交给 ssh-agent 保管，其他程序需要身份验证的时候可以将验证申请交给 ssh-agent 来完成整个认证过程。\n\n```\neval \"$(ssh-agent -s)\"\n```\n\n添加生成的 SSH key 到 ssh-agent：\n```\nssh-add ~/.ssh/id_rsa\n```\n\n{% image /assets/wiki/git/ssh-keys2.jpg width:400px %}\n\n登陆 Github，添加 ssh：\n\n{% image /assets/wiki/git/ssh-keys3.jpg width:400px %}\n\n\n把 id_rsa.pub 文件里的内容复制到这里：\n\n{% image /assets/wiki/git/ssh-keys4.jpg width:400px %}\n"},{"title":"基本操作入门","url":"/wiki/git/usage/index.html","content":"\n## 基本操作流程\n\n1. 在对代码进行了一些修改之后，使用：`git add --all` 将本地所有新增文件和修改内容添加到暂存区。\n2. 使用：`git commit -m 备注` 将代码提交到本地版本库。（备注内容没有空格的话不需要加引号）\n3. 使用：`git pull origin` 从服务器拉取代码，更新本地版本库。\n4. 使用：`git push origin` 将本地版本库推送到服务器。\n\n\n<!-- more -->\n\n\n## 克隆与配置\n\n### 克隆版本库\n\n```\ngit clone https://github.com/xaoxuu/AXKit.git\n# 或者\ngit clone https://github.com/xaoxuu/AXKit.git AXKit\n```\n\n### 配置版本库\n\n要忽略某些文件的改动需要配置 `.gitignore` 文件：\n\n```\n# 这是macOS文件夹属性的隐藏文件，不需要同步到git\n.DS_Store\n\n# 某个文件夹不想要同步到git\n/public\n/node_modules\n\n# 某个文件不想要同步到git\ntest.txt\n\n# 通配符\n._*\n```\n\n\n## 基本操作指令\n\n### 创建与切换分支\n\n```sh 创建并切换 branch\ngit checkout -b 分支名\n```\n\n```sh 仅仅切换 branch\ngit checkout 分支名\n```\n\n```sh 创建 tag\ngit tag 标签名\n```\n\n```sh 创建 tag 并备注\ngit tag -a 标签名 -m 备注信息\n```\n\n```sh 创建 PGP tag 并备注\ngit tag -s 标签名 -m 备注信息\n```\n\n\n### 查看分支和标签\n\n\n```sh 查看本地 tag\ngit tag\n```\n\n```sh 查看某个本地 tag 详情\ngit show 标签名\n```\n\n```sh 查看本地 branch list\ngit branch 分支名\n```\n\n```sh 查看远程 branch list\ngit branch -r 分支名\n```\n\n```sh 查看所有 branch list\ngit branch -a 分支名\n```\n\n\n### 删除分支和标签\n\n```sh 删除本地 branch / tag\ngit branch -d 分支名或标签名\n```\n\n```sh 删除所有未推送的本地 branch\ngit fetch -p\n```\n\n```sh 仅仅删除某个远程 branch / tag\ngit push origin :分支名或标签名\n# 或者\ngit push origin --delete 分支名或标签名\n```\n\n### 推送分支和标签\n\n```sh 推送某个 branch / tag\ngit push origin 分支名或标签名\n```\n\n```sh 推送所有 branch\ngit push --all origin\n```\n\n```sh 推送所有 tag\ngit push --tags\n```\n\n\n\n### 重命名分支\n\n重命名本地分支：\n\n```sh\ngit branch -m 旧分支名 新分支名\n```\n\n重命名远程分支：\n\n1. 删除远程分支\n2. 重命名本地分支\n3. 推送本地分支\n\n\n\n\n## 拉取、合并分支\n\n### 拉取某个远程标签\n\n```sh\ngit fetch origin tag 远程标签名\n```\n\n### 合并某本地分支到当前分支\n\n```sh\ngit merge 分支名\n```\n\n### 合并某远程分支到当前分支\n\n```sh\ngit pull origin 远程分支名\n```\n\n## 代码冲突\n\n我一般使用 Tower 客户端操作，pull 之后有冲突的文件会列出来。建议使用一个比较好的编辑器如 [Atom](https://atom.io)，有冲突的部分会用两种颜色高亮。\n\n{% note 未完待续 %}\n\n\n## 代码回退\n\n如果冲突文件没有妥善解决就提交到版本库导致严重后果，这是需要查看某个历史时刻的代码，使用：\n\n```\ngit log\n# 查看提交记录\n```\n\n然后 copy 某个 commit id 进行回退，回退的类型有两种：\n\n### soft\n\n这是默认的回退方式，版本库的 HEAD 回滚到某个 commit 但本地代码不变，处于未 commit 的状态。\n\n```sh\ngit reset [commit id]\n# 或者\ngit reset --soft [commit id]\n```\n\n### hard\n\nHEAD 和本地代码都回到某个 commit，后面的更改将会被丢弃。（如同时光穿梭）\n\n```sh\ngit reset --hard [commit id]\n```\n\n\n## 版本迭代\n\n查看本地所有标签\n\n```\ngit tag\n```\n\n把当前 HEAD 打个标签（名为：1.0）\n\n```\ngit tag 1.0\n# 也可以添加备注信息，如同commit\ngit tag 1.0 -m 'message'\n```\n\n切换到某个标签（1.0）\n\n```\ngit checkout 1.0\n```\n\n把标签 push 到远程\n\n```sh push指定的tag\ngit push origin 1.0\n```\n```sh push所有未push的tag\ngit push --tags\n```\n\n删除标签（1.0）\n\n```\n# 删除本地tag\ngit tag -d 1.0\n\n# 删除远程tag\n# 方法一：将空白tag覆盖到远程tag\ngit push origin :1.0\n# 方法二：执行删除命令\ngit push origin --delete 1.0\n```\n\n\n## 客户端操作\n\n### Stash\n\n- save：将当前未 commit 的代码保存到 stash，并且回到上次 commit 的状态。\n- apply：应用某个 stash 的代码。\n\n### Git-Flow\n\n自动化管理功能，例如：\n\n- 准备开发新版本的时候：点击 Start Release，客户端会自动新建一个 release 分支。\n- 准备增加一个新特性的时候：点击 Start Feature，客户端会新建一个 feature 分支。\n- 需要修复 bug 的时候：点击 Start Hotfix，客户端会新建一个 fix 分支。\n- 当修复完 bug，点击 Finish Hotfix 的时候，客户端会自动把 fix 分支合并到创建它的分支，并且创建一个 tag。\n- 当一个新特性开发完成，点击 Finish Feature 的时候，客户端会自动把 feature 分支合并到创建它的分支，并且创建一个 tag。\n- 当一个新版本开发完成，点击 Finish Release 的时候，客户端会自动把 release 分支合并到创建它的分支，并且创建一个 tag。\n"},{"title":"探索个性化选项","url":"/wiki/stellar/advanced-settings/index.html","content":"\n## 自定义主页文章检索栏\n\n这个功能在 {% mark 1.13.0 color:dark %} 版本后开始支持。\n\n```yaml blog/_config.stellar.yml\n######## Index ########\npost-index: # 近期发布 分类 标签 归档 and ...\n  '朋友文章': /friends/rss/ # 这里填写的链接要与对应页面一致，否则可能无法正确高亮\n```\n \n## 文章模板\n\n我一看这文档，每次写一篇新文章都要重新写一遍 `cover`,`desciption`,`categories` 多麻烦，直接让 hexo 替我写了它不香吗\n\n根目录下 `scaffolds` 文件夹中编辑 `post.md` 的 `font-matter`：\n\n```yaml blog/scaffolds/post.md\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags: []\ncategories: []\ndescription: \ncover: \nbanner: \nposter: # 海报（可选，全图封面卡片）\n  topic: 标题上方的小字 # 可选\n  headline: 大标题 # 必选\n  caption: 标题下方的小字 # 可选\n  color: 标题颜色 # 可选\n---\n```\n\n## 主题色\n\n```yaml blog/_config.stellar.yml\nstyle:\n  ...\n  color:\n    common:\n      theme: '#1BCDFC' # 主题色\n      accent: '#ff5722' # 强调色\n      link: '#2196f3' # 超链接颜色\n      button: '#1BCDFC' # 按钮颜色\n      hover: '#ff5722' # 按钮高亮颜色\n    light:\n      background: '#f8f8f8' # 浅色背景颜色\n      block: '#f2f2f2' # 块背景颜色\n      card: white # 卡片背景颜色\n      title: '#000' # 标题文本颜色\n      text: '#333' # 正文文本颜色\n      code: '#111' # 行内代码颜色\n    dark:\n      background: '#313438' # 深色背景颜色\n      background-mobile: black # 移动端深色背景（OLED调成纯黑可以省电）\n      block: '#2B2F33' # 块背景颜色\n      card: '#464D57' # 卡片背景颜色\n      title: '#fff' # 标题文本颜色\n      text: '#eee' # 正文文本颜色\n      code: '#ff7043' # 行内代码颜色\n```\n\n## 字体\n\n### 系统字体\n\n```yaml blog/_config.stellar.yml\nstyle:\n  font-size: 16px\n  font-family:\n    logo: 'system-ui, \"Microsoft Yahei\", \"Segoe UI\", -apple-system, Roboto, Ubuntu, \"Helvetica Neue\", Arial, \"WenQuanYi Micro Hei\", sans-serif'\n    body: 'system-ui, \"Microsoft Yahei\", \"Segoe UI\", -apple-system, Roboto, Ubuntu, \"Helvetica Neue\", Arial, \"WenQuanYi Micro Hei\", sans-serif'\n    code: 'Menlo, Monaco, Consolas, system-ui, \"Courier New\", monospace, sans-serif'\n```\n\n### 外部字体\n\n要想引用外部字体，你需要先在 `_config.yml` 中 `inject` 引入\n\n举例，引用 [Noto Serif SC](https://fonts.google.com/noto/specimen/Noto+Serif+SC?query=noto+&subset=chinese-simplified) 在 `_config.yml` 中写入\n\n```yaml blog/_config.yml\ninject:\n  head:\n    - <link href=\"https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap\" rel=\"stylesheet\">\n  script:\n```\n\n并在 `_config.stellar.yml` 中填写你引入的字体名称\n\n```yaml blog/_config.stellar.yml\nstyle:\n  font-family:\n    body: '\"Noto Serif SC\", \"Microsoft Yahei\",..., sans-serif'\n```\n\n选择在线字体：\n\n{% link https://www.googlefonts.cn/ %}\n\n### 本地字体\n\n若您想引用本地字体，举例，引用得意黑（`SmileySans-Oblique.ttf`）这个字体，先将字体放置于 `blog/source/font/` 目录下，然后改动一下主题文件\n\n```styl Blog/themes/stellar/source/css/_custom.styl\n@font-face\n   font-family: 'Smiley Sans'\n   src: url('/font/SmileySans-Oblique.ttf')\n   font-weight: normal\n   font-style: normal\n```\n\n`font-family` 是你引入的字体家族名，`src` 中填写字体文件相对于 `source` 文件夹的路径\n\n同样，你需要在 `_config.stellar.yml` 中填写你引入的字体名称（`font-family`）\n\n```yaml blog/_config.stellar.yml\nstyle:\n  font-family:\n    body: '\"Smiley Sans\", \"Microsoft Yahei\",..., sans-serif'\n```\n\n但是我个人并不推荐引用本地字体，相比于英文字体，中文字体囊括了众多的字符，这也无法避免地导致字体文件体积的增加，拿 `Noto Serif SC` 来说，单个ttf文件就有9mb之大，这对于您的站点而言加载速度可想而知。\n\n## 文本对齐方向\n\n```yaml blog/_config.stellar.yml\nstyle:\n  text-align: left # justify/left/center/right\n```\n\n## 页面缓入效果\n\n```yaml blog/_config.stellar.yml\n# 默认关闭，目前已知scrollreveal与lazyload同时打开时会有footer不显示的bug\nscrollreveal:\n  enable: false\n  js: https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js\n  distance: 4px # 执行距离\n  duration: 400 # ms # 执行时长\n  interval: 100 # ms # 执行间隔（时间）\n  scale: 0.1 # 0.1~1 # 执行方式（缩放）\n```\n\n{% note color:warning 此效果会和图片懒加载插件冲突，导致部分卡片可能加载不出来 %}\n\n## 图片懒加载\n\n```yaml blog/_config.stellar.yml\n# 默认打开\nlazyload:\n  enable: true # [hexo clean && hexo s] is required after changing this value.\n  js: https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js\n  transition: blur # blur, fade\n```\n\n## 加载提示\n\n加载动态时间线、动态友链等显示提示\n\n```yaml blog/_config.stellar.yml\n# 默认打开\nloading:\n  loading: 正在加载\n  error: 加载失败，请稍后重试。\n```\n\n## 评论的灵活用法\n\n### 共用评论数据\n\n如果您有多个页面需要共用评论数据，可以在 `front-matter` 中覆盖评论参数，例如：\n\n```yaml blog/source/about/index.md\ntitle: 关于\nbeaudar:\n  'issue-term': '留言板'\n```\n\n```yaml blog/source/friends/index.md\ntitle: 友链\nbeaudar:\n  'issue-term': '留言板'\n```\n\n### 使用其它评论数据\n\n如果您有多个页面需要另外一个数据库的评论数据，以 Beaudar 为例，您可以这样：\n\n```yaml blog/source/wiki/stellar/index.md\ntitle: 快速开始您的博客之旅\nbeaudar:\n  repo: xaoxuu/hexo-theme-stellar\n  'issue-term': 'Q & A'\n```\n\n\n## 文章自定义\n\n### 是否自动生成封面\n\n根据 `tags` 作为关键词为每一篇文章在线搜索封面：\n\n```yaml blog/_config.stellar.yml\narticle:\n  auto_cover: true\n```\n\n### 是否自动生成摘要\n\n建议您通过 `description` 或者 `excerpt` 方式生成摘要，但如果您希望自动从文章内容截取一定字数的文字作为摘要，可以这样设置：\n\n```yaml blog/_config.stellar.yml\narticle:\n  auto_excerpt: 200\n```\n\n### 相关文章推荐\n\n要实现相关文章推荐功能，您需要安装插件：\n\n{% copy npm i hexo-related-popular-posts %}\n\n然后在主题配置文件中开启：\n\n```yaml blog/_config.stellar.yml\narticle:\n  # npm i hexo-related-popular-posts\n  related_posts:\n    enable: true\n    title: 您可能感兴趣的文章\n```\n\n## 自定义样式\n\n如果要修改样式，您需要删掉主题的样式文件的 CDN 链接，使用本地文件，然后在 `themes/stellar/source/css/_custom.styl` 中进行修改。\n\n### 使用其它 highlight.js 代码高亮主题\n\nHexo 官方有文档：https://hexo.io/docs/syntax-highlight.html#hljs\n\n> Tip: When line_number is set to false, wrap is set to false and hljs is set to true, you can then use highlight.js theme directly in your site.\n\n以 `atom-one-dark` 主题为例，翻译过来就是 `_config.yml` 找到 `highlight` 并修改为：\n```yaml\nhighlight:\n  enable: true\n  line_number: false\n  auto_detect: false\n  tab_replace: '    '\n  wrap: false\n  hljs: true\n```\n然后再找到 `inject` 新增一个 css 链接：\n```yaml\ninject:\n  head:\n    - <link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.5.0/build/styles/atom-one-dark.min.css\">\n```\n\n## 外部文件注入\n\n在站点根目录下的配置文件中进行修改 `inject.head` 以在 `<head>` 标签末尾处注入代码，修改 `inject.script` 以在 `<body>` 标签末尾处注入代码。\n\n```yaml blog/_config.yml\ninject:\n  head:\n    - <meta name=\"msapplication-TileColor\" content=\"#2d89ef\">\n    - <meta name=\"msapplication-config\" content=\"/assets/favicon/browserconfig.xml\">\n    - <meta name=\"theme-color\" content=\"#ffffff\">\n  script:\n    - https://fastly.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js\n```\n\n## 实现「笔记」页面\n\n创建一个项目，设置为不索引：\n\n```yaml blog/source/_data/widgets.yml\nNotes:\n  name: 笔记\n  title: 笔记\n  description: 一个隐藏项目：笔记\n  index: false\n  # sidebar: [toc]\n  tags: 知识库\n  sections:\n    '日常问题解决方案': [100, 199]\n    '移动端开发笔记': [200, 299]\n    '前端学习笔记': [300, 399]\n    '在线工具': [400, 499]\n```\n\n然后笔记页面的 `front-matter` 中指定要高亮的 `menu_id`：\n\n```yaml blog/source/notes/index.md\n---\nlayout: wiki\nwiki: Notes\nmenu_id: notes\n---\n```\n\n这样就可以啦～\n"},{"title":"Stellar 探索号（教程分享）","url":"/wiki/stellar/articles/index.html","content":"\n{% timeline hide:title,footer api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&labels=分享 %}\n{% endtimeline %}\n\n{% note 小提示 如果您也有与 Stellar 相关的文章并希望显示在这里，可以直接在 [hexo-theme-stellar](https://github.com/xaoxuu/hexo-theme-stellar/issues) 中选择【文章分享】模板按照格式提交即可，立即生效。 %}\n"},{"title":"评论插件配置","url":"/wiki/stellar/comments/index.html","content":"\n## Beaudar\n\nBeaudar 是 Utterances 的中文版本，相比 Utterances 有更多的体验优化，可以按时间倒序排序。\n\n```yaml blog/_config.stellar.yml\ncomments:\n  service: beaudar\n  beaudar:\n    repo: xaoxuu/blog-comments\n```\n\n[Beaudar](https://beaudar.lipk.org) 的配置方法很简单，创建一个仓库，在仓库中创建一个 [域名白名单文件](https://github.com/xaoxuu/blog-comments/blob/main/beaudar.json)，然后在 [此处](https://github.com/apps/beaudar) 授权安装即可。\n\n## utterances\n\nA lightweight comments widget built on GitHub issues. Use GitHub issues for blog comments, wiki pages and more!\n\n```yaml blog/_config.stellar.yml\ncomments:\n  service: utterances\n  utterances:\n    repo: xaoxuu/blog-comments\n```\n\n[utterances](https://utteranc.es) 的配置方法很简单，创建一个仓库，在仓库中创建一个 [域名白名单文件](https://github.com/xaoxuu/blog-comments/blob/main/utterances.json)，然后在 [此处](https://github.com/apps/utterances) 授权安装即可。\n\n## giscus\n\n\n[giscus](https://giscus.app/zh-CN) 是由 GitHub Discussions 驱动的评论系统。让访客借助 GitHub 在你的网站上留下评论和反应吧！本项目受 utterances 强烈启发。\n\n```yaml blog/_config.stellar.yml\ncomments:\n  service: giscus\n  # giscus\n  # https://giscus.app/zh-CN\n  giscus:\n    data-repo: xxx/xxx # [在此输入仓库]\n    data-repo-id: # [在此输入仓库 ID]\n    data-category: # [在此输入分类名]\n    data-category-id:\n    data-mapping: pathname\n    data-strict: 0\n    data-reactions-enabled: 1\n    data-emit-metadata: 0\n    data-input-position: top # top, bottom\n    data-theme: preferred_color_scheme\n    data-lang: zh-CN\n    data-loading: lazy\n    crossorigin: anonymous\n```\n\n\n## Twikoo\n\n```yaml blog/_config.stellar.yml\ncomments:\n  service: twikoo\n  twikoo:\n    envId: https://xxx # vercel函数\n```\n\n## waline\n\n```yaml blog/_config.stellar.yml\ncomments:\n  service: waline\n  waline:\n    js: https://unpkg.com/@waline/client@v2/dist/waline.js\n    css: https://unpkg.com/@waline/client@v2/dist/waline.css\n    # Waline server address url, you should set this to your own link\n    serverURL: https://xxx # waline 地址\n    # If false, comment count will only be displayed in post page, not in home page\n    commentCount: true\n    # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`.\n    pageview: false\n\n    # Custom locales\n    locale:\n      placeholder: # 输入框内提示文字\n\n    # Custom emoji\n    emoji: \n        - https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs\n    #   - https://unpkg.com/@waline/emojis@1.1.0/weibo\n    #   - https://unpkg.com/@waline/emojis@1.1.0/alus\n    #   - https://unpkg.com/@waline/emojis@1.1.0/bilibili\n    #   - https://unpkg.com/@waline/emojis@1.1.0/qq\n    #   - https://unpkg.com/@waline/emojis@1.1.0/tieba\n    #   - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji\n    #   - https://unpkg.com/@waline/emojis@1.1.0/bmoji\n\n    # Comment infomation, valid meta are nick, mail and link\n    # meta:\n    #   - 昵称\n    #   - 邮箱\n    #   - 链接\n\n    # Set required meta field, e.g.: [nick] | [nick, mail]\n    # requiredMeta:\n    #   - nick\n\n    # Language, available values: en-US, zh-CN, zh-TW, pt-BR, ru-RU, jp-JP\n    lang: zh-CN\n\n    wordLimit: 0 # 字数限制，0为不限制字数\n\n    # Whether enable login, can choose from 'enable', 'disable' and 'force'\n    # login: enable\n\n    # comment per page\n    pageSize: 5 # 每页显示评论数\n```\n\n## valine\n\nStellar 1.13.0 已移除对 Valine 评论的支持。"},{"title":"开发者和社区支持","url":"/wiki/stellar/contributors/index.html","content":"\n{% tabs align:left %}\n\n<!-- tab 开发者 -->\n{% users api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/contributors?per_page=100&direction=asc %}\n\n<!-- tab 点赞的用户 -->\n{% quot icon:hashtag 1-100 %}\n{% users api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/stargazers?per_page=100&page=1 %}\n{% quot icon:hashtag 101-200 %}\n{% users api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/stargazers?per_page=100&page=2 %}\n{% quot icon:hashtag 201-300 %}\n{% users api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/stargazers?per_page=100&page=3 %}\n\n{% endtabs %}\n\n{% image https://api.star-history.com/svg?repos=xaoxuu/hexo-theme-stellar&type=Date %}\n\n{% quot icon:hashtag 如何加入社区 %}\n\n社区建设主要包括以下几个方面：\n\n- [Issues](https://github.com/xaoxuu/hexo-theme-stellar/issues) 技术问题答疑、BUG反馈\n- [Discussions](https://github.com/xaoxuu/hexo-theme-stellar/discussions) 论坛、相关话题讨论\n- [文档](https://github.com/xaoxuu/hexo-theme-stellar-docs) 维护\n- [探索号](https://xaoxuu.com/wiki/stellar/articles/) 文章收录\n- QQ群：1146399464，验证码：{% psw vlts-2021 %}（以聊天为主，技术问题未必跟进。）\n\n> 无论在什么渠道，学习并掌握 [提问的智慧(23k Stars)](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md) 可以方便大家更高效地帮你解决问题。\n\n{% split %}\n<!-- cell left -->\n{% border color:red %}\n**错误的提问**\n<hr>\n\n- XXX 功能怎么用？（文档有详细描述）\n- 这个功能怎么用不了啊（不说明自己操作了什么，也不展示实际效果）\n- 我怎么跑不起来，能帮我看看吗？（什么也不尝试，直接丢项目代码）\n- 怎么报错了呢？（不贴或只贴极少部分的出错提示）\n- 这个代码怎么改（扔过来一大段代码）\n- XXX 什么意思？（没有经过任何搜索）\n\n{% endborder %}\n<!-- cell right -->\n{% border color:green %}\n**正确的提问**\n<hr>\n\n- 我这里遇到了一个问题：【问题描述】，我经过了以下尝试：【思路细节】，不能得到解决，报错如下：【报错截图/线上预览地址/仓库源代码地址】，请问该怎么解决？\n- 我不太理解【某处】里的【某处】，我的理解是这样的：【思路细节】，对吗？\n- 我查看了文档的【某处】，并尝试【做法】，但是没有得到【预想效果】，正确的做法应该是什么？\n\n{% endborder %}\n{% endsplit %}\n"},{"title":"使用 Stellar 主题的博客","url":"/wiki/stellar/examples/index.html","content":"\n{% sites api:https://api.vlts.cc/output_data/v2/xaoxuu/hexo-theme-stellar-examples %}\n\n{% note 小提示 如果您也使用了 Stellar 并希望显示在这里，可以在 [hexo-theme-stellar-examples](https://github.com/xaoxuu/hexo-theme-stellar-examples/issues) 中提交 issue 告知您的站点信息，在您提交后的大约 3 分钟内生效。 %}\n"},{"title":"使用「友链朋友圈」极简版","url":"/wiki/stellar/fcircle/index.html","content":"\n{% border 特别感谢 color:light %}\n主题内置版本数据服务由 [友链朋友圈](https://github.com/Rock-Candy-Tea/hexo-circle-of-friends) 极简版提供。\n这个功能在 1.13.0 版本后开始支持。\n{% endborder %}\n\n{% timeline %}\n\n<!-- node 第一步：fork repo -->\n\nfork [@Rock-Candy-Tea/hexo-circle-of-friends](https://github.com/Rock-Candy-Tea/hexo-circle-of-friends)\n\n<!-- node 第二步：设置自己的友链页面地址和主题类型 -->\n\n修改 `hexo_circle_of_friends/fc_settings.yaml` 文件：\n\n```yaml\n- {link: \"https://xaoxuu.com/friends/\", theme: \"stellar\"}  # 友链页地址1，修改为你的友链页地址\n```\n\n<!-- node 第三步：打开 Issues 友链抓取功能 -->\n\n修改 `hexo_circle_of_friends/fc_settings.yaml` 文件：\n\n```yaml\nGITHUB_FRIENDS_LINKS: {\n    enable: true, # true 开启github issue兼容\n    type: \"volantis\",  # volantis/stellar用户请在这里填写volantis\n    owner: \"xaoxuu\",  # 填写你的github用户名\n    repo: \"friends\",  # 填写你的github仓库名\n    state: \"open\",  # 填写抓取的issue状态(open/closed)\n}\n```\n\n<!-- node 第四步：打开 Actions 运行权限 -->\n\n见官方教程 [#simplemode](https://fcircle-doc.yyyzyyyz.cn/#/simplemode)\n\n<!-- node 第五步：放置在博客中 -->\n\n支持首页文章导航栏、文章任意位置，创建一个文件，以本站 `friends/rss/index.md` 为例：\n```yaml\n---\nseo_title: 朋友文章\nrobots: noindex,nofollow\nmenu_id: post\ncomments: false\npost_list: true # 这就意味着页面会显示首页文章导航栏\nsidebar: [welcome, recent]\n---\n{% timeline type:fcircle api:https://raw.githubusercontent.com/xaoxuu/friends-rss-generator/output/data.json %}\n{% endtimeline %}\n```\n\n其中，`api` 部分替换为自己仓库地址及其对应的 `data.json` 文件真实路径。\n\n其中，`post_list: true` 意味着页面会显示首页文章导航栏，搭配主题配置文件中的：\n```yaml\npost-index:\n  '朋友文章': /friends/rss/\n```\n\n即可实现在首页增加一个「朋友文章」栏目的效果。\n\n{% endtimeline %}\n\n> - 你依然可以按照官方教程使用完整版。\n> - 本站示例仓库：[@xaoxuu/friends-rss-generator](https://github.com/xaoxuu/friends-rss-generator)\n\n如果把 `data.json` 输出到 [output](https://github.com/xaoxuu/friends-rss-generator/blob/a97f385398928d2c0b5c7988cff34505eb3ae8fd/.github/workflows/main.yml#L115) 分支，可以直接使用下面的 API 来访问文件：\n\n```\nhttps://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator\n```"},{"title":"编写文章以及独立页面","url":"/wiki/stellar/pages/index.html","content":"\n## 文章摘要卡片\n\n### 封面图片\n\n在文章列表页面或者其他位置显示的文章摘要卡片上面的图片称之为「文章封面」\n\n在文章的 `front-matter` 中写上 `cover: xxx` 即可。例如：\n\n```yaml blog/source/_posts/xxx.md\n---\n# 本地图片路径为 blog/source/assets/xaoxuu/blog/2020-0927a@1x.svg\n# 也可以直接引用图片直链 https://xxx.jpg\ncover: /assets/xaoxuu/blog/2020-0927a@1x.svg\n---\n```\n\n{% folding 显示效果 open:false %}\n{% image https://pic1.imgdb.cn/item/6354e0a216f2c2beb100617c.jpg width:600px %}\n{% endfolding %}\n\n上面这种方式会显示title与description或者摘要，若你想要图片全显示，可以加入如下参数：\n\n```yaml blog/source/_posts/xxx.md\n---\ncover: /assets/xaoxuu/blog/2020-0927a@1x.svg # 必选\nposter: # 海报（可选，全图封面卡片）\n  topic: 标题上方的小字 # 可选\n  headline: 大标题 # 必选\n  caption: 标题下方的小字 # 可选\n  color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red...\n---\n```\n\n{% border Stellar color:red %}\nv1.14.0 更换 `cover-title` `cover-cat` `cover-subtitle` `cover-text-color` 为 `poster`\n{% endborder %}\n\n> 为了显示美观，建议 `topic` 和 `caption` 选择其一与 `headline` 搭配使用。\n\n{% folding 显示效果 open:false %}\n\n填写 `topic` 与 `headline` 时大标题位于上方\n\n{% image https://pic1.imgdb.cn/item/635aa9d016f2c2beb1fe4f53.jpg width:600px %}\n\n只填写 `headline` 或填写 `headline` 与 `caption` 时大标题位于下方\n\n{% image https://pic1.imgdb.cn/item/635aaa8116f2c2beb1ffdd19.jpg width:600px %}\n\n{% endfolding %}\n\n如果您想使用 Unsplash 搜索图片作为封面，可以在 `cover` 设置搜索关键词（用英文逗号隔开）：\n\n```yaml blog/source/_posts/xxx.md\n---\ncover: workout,strava\n---\n```\n\n### 内容摘要\n\n一篇文章开头一段文字描述就是摘要，摘要和正文用 `<!-- more -->` 隔开，前后一定要有空行。例如：\n\n```yaml blog/source/_posts/xxx.md\n---\ncover: /assets/xaoxuu/blog/2020-0927a@1x.svg\n---\n\n在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。\n\n<!-- more -->\n\n后面是正文部分，在主页看不到。\n```\n\n\n## 文章页\n\n### 横幅图片\n\n文章页面顶部区域可以显示长长的横幅图片，设置方法如下：\n\n```yaml blog/source/_posts/xxx.md\nbanner: /assets/xaoxuu/blog/2020-0927a@1x.svg\n```\n\n如果您想使用 Unsplash 搜索图片作为横幅，可以在 `banner` 中设置搜索关键词（用英文逗号隔开）：\n\n```yaml blog/source/_posts/xxx.md\n---\nbanner: workout,strava\n---\n```\n\n### 指定一级标题\n\n默认的一级标题是文章的 `title`，如果希望使用别的文字作为一级标题，可以指定 `h1`，例如：\n\n```yaml blog/source/_posts/xxx.md\n---\nh1: 快速开始\n---\n```\n\n## 文章索引与推荐\n\n文章如果有分类和标签就会自动在主页出现「分类」、「标签」选项卡实现分类浏览，不需要手动添加页面。\n\n### 文章分类\n\n在文章列表页面会显示文章所属的第一级分类，例如：\n\n```yaml blog/source/_posts/xxx.md\n---\ncategories: [设计开发, iOS开发]\n---\n```\n\n这样写就只会显示「设计开发」一级分类，而在文章页面顶部则会显示完整的面包屑导航。\n\n### 文章标签\n\n文章标签目前不可见，用于关键词、搜索、按标签检索、相关文章推荐等功能，例如：\n\n```yaml blog/source/_posts/xxx.md\n---\ntags: [iOS, 心率]\n---\n```\n\n## 参考资料\n\n填写引用文章的标题和链接：\n\n```yaml\n---\nreferences:\n  - title: '心跳之旅—💗—iOS用手机摄像头检测心率(PPG)'\n    url: https://punmy.cn/2016/07/28/15231176397746.html\n  - title: 'PPG光电容积脉搏波描记法技术概况'\n    url: https://www.jianshu.com/p/695c131abfa5\n  ...\n---\n```\n\n效果见这篇文章：\n\n{% link https://xaoxuu.com/blog/20200927/#references %}\n\n## 更多的独立页面\n\nStellar 同时具有博客和 Wiki 两个大模块，为了能够正确进行导航栏高亮，引入了 `menu_id` 来进行区分，通常情况下，`layout: post` 和 `layout: wiki` 两种布局模板可以自动为 `sidebar.menu.post` 和 `sidebar.menu.wiki` 的导航栏按钮高亮。自己创建的独立页面也可以在 `front-matter` 中指定 `menu_id` 来使某个按钮处于选中状态。\n\n例如您有关于、友链两个页面，都希望高亮「更多」按钮：\n\n```yaml blog/source/about/index.md\n---\nmenu_id: more\ntitle: 关于\n---\n```\n\n```yaml blog/source/friends/index.md\n---\nmenu_id: more\ntitle: 友链\n---\n```\n\n在主题配置文件中设置导航栏：\n\n```yaml blog/_config.stellar.yml\nsidebar:\n  menu:\n    ...\n    more: '[更多](/more/)'\n```\n\n## 友链页面\n\n友链被设计成标签，您可以在任何页面任何位置插入友链，详见：\n\n{% link https://xaoxuu.com/wiki/stellar/tag-plugins/#友链标签 #友链标签 %}\n\n## 关于页面\n\n没有单独的关于页面布局，您可以自由组合丰富的标签来实现个性化的关于页面，例如：`about`、`tabs`、`navbar`、`quot`、`timeline` 标签。\n\n"},{"title":"更新日志和近期计划","url":"/wiki/stellar/releases/index.html","content":"\n版本命名规范：【大版本.小版本.修复版本】\n\n- 大版本：较大范围改动和设计调整、重构\n- 小版本：较小范围改动、增加删除功能，也可能包含部分修复\n- 修复版本：仅包含修复，可放心无缝升级\n\n{% border 如何关注主题更新 color:green %}\n例如，您可以在自己博客任意位置用时间线标签显示主题最近一个版本更新内容：\n```\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/releases?per_page=1 %}\n{% endtimeline %}\n```\n\n{% endborder %}\n\n{% tabs align:left %}\n\n<!-- tab 更新日志 -->\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/releases?per_page=10 %}\n{% endtimeline %}\n\n<!-- tab Todo -->\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=todo&per_page=20 %}\n{% endtimeline %}\n\n{% endtabs %}\n\n\n\n"},{"title":"侧边栏配置","url":"/wiki/stellar/sidebar/index.html","content":"\n## Logo\n\n左上角的 logo 和标题取自站点根目录的配置文件：\n\n```yaml blog/_config.yml\ntitle: 网站名称\navatar: 头像\n```\n\n设置鼠标指上 `subtitle` 后翻转另一行字（您可以将鼠标移至左上角的Stellar查看效果）\n\n```yaml blog/_config.yml\nsubtitle:  标题1 | 标题2\n```\n\n如果您想用一个图片作为 logo，可以直接在主题配置文件 sidebar.logo.title 中设置：\n\n```yaml blog/_config.stellar.yml\nsidebar:\n  logo:\n    title: '[<img no-lazy height=\"32px\" src=\"xxx\"/>](/)'\n```\n\n## Navbar（主导航栏）\n\n```yaml blog/_config.stellar.yml\nsidebar:\n  menu:\n    post: '[btn.blog](/)'\n    wiki: '[btn.wiki](/wiki/)'\n    notes: '[笔记](/notes/)'\n    more: '[更多](/more/)'\n```\n\n侧边栏宽度有限，如何在不影响观感的情况下设置更多的主导航栏按钮呢？建议设置一个「更多」按钮，然后在「更多」页面的侧边栏放上列表组件。\n\n## Search（搜索）\n\n{% tabs align:left %}\n\n<!-- tab local_search -->\n\n{% border %}\n在 {% mark 1.17.1 color:dark %} 版本后开始支持，无需安装插件，可直接开启。\n{% endborder %}\n\n```yaml\nsearch:\n  service: local_search # local_search, todo...\n  local_search:\n    field: all # post, page, all\n    path: /search.json\n    content: true\n```\n\n<!-- tab others -->\n\n请提交PR...\n\n{% endtabs %}\n\n在 `_config.stellar.yml` 中设置搜索选项并配置你想在侧边栏中显示的位置。\n\n```yaml blog/_config.stellar.yml\n# Sidebar widgets\nwidgets:\n  index: welcome, search, recent, timeline \n  page: welcome, toc \n  post: toc, ghrepo, search, ghissues \n  wiki: search, ghrepo, toc, ghissues, related \n```\n\n然后在 `widgets.yml` 文件中配置侧边栏搜索组件\n\n```yaml blog/source/_data/widgets.yml\nsearch:\n  layout: search\n  filter: auto # auto or '/path'\n```\n\n您可以设置 `filter` 按地址过滤搜索结果，默认 `auto` 是智能选择，规则如下：\n- `layout: wiki`：只在 `/wiki/当前项目` 中搜索\n- 其它：站内搜索\n\n你可以在某些页面中通过覆盖 search 组件的 filter 参数来定制化搜索范围，例如:\n\n```yaml\nsidebar:\n  - toc\n  - layout: search\n    override: search\n    filter: /path/to/some\n```\n\n如果想始终进行不加过滤的站内搜索，那么设置为 `filter: ''` 即可。\n\n\n## Footer（页脚）\n\n```yaml blog/_config.stellar.yml\nfooter:\n  social:\n    github:\n      icon: '<img src=\"/assets/placeholder/social/08a41b181ce68.svg\"/>'\n      url: https://\n    music:\n      icon: '<img src=\"/assets/placeholder/social/3845874.svg\"/>'\n      url: https://\n    unsplash:\n      icon: '<img src=\"/assets/placeholder/social/3616429.svg\"/>'\n      url: https://\n    comments:\n      icon: '<img src=\"/assets/placeholder/social/942ebbf1a4b91.svg\"/>'\n      url: https://\n```\n\n## 自定义组件\n\nStellar 支持丰富的自定义小组件，详见这篇文档：\n\n{% link https://xaoxuu.com/wiki/stellar/widgets/ desc:true %}"},{"title":"使用标签插件增强阅读体验","url":"/wiki/stellar/tag-plugins/index.html","content":"\n新版标签插件和 Hexo 官方的标签插件统一使用空格分隔，所以如果参数内容中需要出现的空格被意外分隔开了的时候，请使用 `&nbsp;` 代替。为了方便理解，本文档语法格式中的可选参数用方括号括起来，键值对参数用冒号分隔开，例如：\n\n```\n{% image src description [download:bool/string] %}\n```\n就表明第一个参数是图片链接，第二个参数是图片描述，而 `download` 是可选参数，并且值是布尔或字符串类型。\n\n\n{% folding 了解参数解析规则 %}\n\n以图片标签为例，使用空格分隔开之后得到一个数组，如果图片描述文字中有空格，多分出来的这些「参数」被合并到最后一个「非键值对参数」中，什么是「非键值对参数」呢？举个例子您就明白了：\n\n```\n{% image /assets/wiki/stellar/photos/183e71e0ad995.jpg 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone-rohit_vohra_12172020.zip %}\n```\n\n这个例子中，`download:https://xxxx` 是有冒号分隔开的，`download` 为键，后面的网址为值，所以叫做「键值对参数」；与此相对的，没有冒号分隔的就叫做「非键值对参数」。键值对参数可以放在任何位置，我可以通过匹配键来解析，而非键值对参数则只能通过顺序解析，所以它们必须和文档中要求的前后顺序一致。\n\n一般核心的、重要的参数会设置成非键值对参数，而可选参数设置成键值对参数。\n\n{% endfolding %}\n\n## 文本修饰标签集\n\n- 支持多彩标记标签，包括：{% mark 默认 %} {% mark 红 color:red %} {% mark 橙 color:orange %} {% mark 黄 color:yellow %} {% mark 绿 color:green %} {% mark 青 color:cyan %} {% mark 蓝 color:blue %} {% mark 紫 color:purple %} {% mark 浅 color:light %} {% mark 深 color:dark %} {% mark 警告 color:warning %} {% mark 错误 color:error %} 一共 12 种颜色。\n- 这是 {% psw 密码 %} 标签\n- 这是 {% u 下划线 %} 标签\n- 这是 {% emp 着重号 %} 标签\n- 这是 {% wavy 波浪线 %} 标签\n- 这是 {% del 删除线 %} 标签\n- 这是 {% sup 上角标 color:red %} 标签\n- 这是 {% sub 下角标 %} 标签\n- 这是 {% kbd 键盘样式 %} 标签，试一试：{% kbd ⌘ %} + {% kbd D %}\n\n```md 写法如下\n- 支持多彩标记标签，包括：{% mark 默认 %} {% mark 红 color:red %} {% mark 橙 color:orange %} {% mark 黄 color:yellow %} {% mark 绿 color:green %} {% mark 青 color:cyan %} {% mark 蓝 color:blue %} {% mark 紫 color:purple %} {% mark 浅 color:light %} {% mark 深 color:dark %} {% mark 警告 color:warning %} {% mark 错误 color:error %} 一共 12 种颜色。\n- 这是 {% psw 密码 %} 标签\n- 这是 {% u 下划线 %} 标签\n- 这是 {% emp 着重号 %} 标签\n- 这是 {% wavy 波浪线 %} 标签\n- 这是 {% del 删除线 %} 标签\n- 这是 {% sup 上角标 color:red %} 标签\n- 这是 {% sub 下角标 %} 标签\n- 这是 {% kbd 键盘样式 %} 标签，试一试：{% kbd ⌘ %} + {% kbd D %}\n```\n\n## Emoji（表情标签）\n\n内置了可配置的表情标签{% emoji 爱你 %}使用方法如下：\n\n```\n{% emoji 爱你 %}\n```\n\n语法格式：\n\n```\n{% emoji [source] name [height:1.75em] %}\n```\n\n其中 `source` 可省略，默认为配置中的第一个 `source`：\n\n```yaml blog/_config.stellar.yml\ntag_plugins:\n  ...\n  emoji:\n    default: https://fastly.jsdelivr.net/gh/cdn-x/emoji/qq/%s.gif\n    twemoji: https://fastly.jsdelivr.net/gh/twitter/twemoji/assets/svg/%s.svg\n    qq: https://fastly.jsdelivr.net/gh/cdn-x/emoji/qq/%s.gif\n    aru: https://fastly.jsdelivr.net/gh/cdn-x/emoji/aru-l/%s.gif\n    tieba: https://fastly.jsdelivr.net/gh/cdn-x/emoji/tieba/%s.png\n```\n\n{% border %}\n在配置文件中，文件名用 `%s` 代替。这种集成方式虽然不那么优雅，但也能用，主要是配置起来比较灵活。 {% emoji aru 0180 %}\n如果对高度有特别要求，可以指定高度，例如：{% emoji aru 5150 height:3em %}\n```\n{% emoji aru 5150 height:3em %}\n```\n{% endborder %}\n\n> 表情速查表：[stellar表情标签索引](https://www.hermitlsr.top/2021-08-02/stellar%E8%A1%A8%E6%83%85%E6%8F%92%E4%BB%B6%E7%B4%A2%E5%BC%95/)\n\n## Image（图片标签）\n\n图片标签是一个精心设计的应对各种尺寸插图的标签，对于大图，可以放置一个「下载」按钮，语法格式如下：\n\n```\n{% image src [description] [download:bool/string] [width:px] [padding:px] [bg:hex] %}\n```\n\n```yaml 参数说明\nsrc: 图片地址\ndescription: 图片描述\ndownload: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 true\nwidth: 200px # 图片宽度\npadding: 16px # 图片四周填充宽度\nbg: '#ffffff' # 图片区域背景颜色，16进制\n```\n\n### 大尺寸图片\n\n无论在什么宽度的设备上都希望横向铺满的图片，一般不需要额外操作。可以在链接后面写上图片描述，如有必要，可以通过设置 `download:true` 使其显示一个「下载」按钮链接指向图片地址，如果下载链接与显示的图片地址不同，可以 `download:下载链接` 来使其能够下载原图。\n\n{% image /assets/wiki/stellar/photos/183e71e0ad995.jpg 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone-rohit_vohra_12172020.zip %}\n{% image /assets/wiki/stellar/photos/bc7bda18328da.jpg 来自澳大利亚的 Pieter de Vries 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone_pieter_de_vries_011221.zip %}\n\n```md 写法如下\n{% image /assets/wiki/stellar/photos/183e71e0ad995.jpg 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone-rohit_vohra_12172020.zip %}\n{% image /assets/wiki/stellar/photos/bc7bda18328da.jpg 来自澳大利亚的 Pieter de Vries 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone_pieter_de_vries_011221.zip %}\n```\n\n### 小尺寸图片优化\n\n宽度较小而高度较大的图片，可以设置宽、高、填充间距、背景色等对其布局进行优化，使得它在不同宽度的屏幕下都能获得不错的视觉体验：\n\n{% tabs %}\n\n<!-- tab 有底色的图片 -->\n\n有底色的图片，可以填充图片底色：\n\n{% image /assets/xaoxuu/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png width:200px padding:16px bg:white %}\n\n```\n{% image /assets/xaoxuu/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png width:200px padding:16px bg:white %}\n```\n\n{% note 提示 鼠标拖拽一下图片可以看看原图 %}\n\n{% folding 如果不进行约束，在宽屏设备上阅读体验很糟糕（为不影响阅读体验，已为您折叠过长的内容） %}\n{% image /assets/xaoxuu/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png %}\n{% endfolding %}\n\n<!-- tab 没有底色的图片 -->\n\n没有底色的图片，可以填充 `bg:var(--card)` 动态颜色，能够适配暗黑模式：\n\n{% image /assets/wiki/stellar/icon.svg bg:var(--card) padding:16px width:100px %}\n\n```\n{% image /assets/wiki/stellar/icon.svg bg:var(--card) padding:16px %}\n```\n\n{% endtabs %}\n\n### 支持 Fancybox 插件点击放大\n\n由于 Stellar 主题的插件具有按需加载的特性，所以 Fancybox 插件默认也是已经配置好了的，在任意 `image` 标签中增加 `fancybox:true` 参数即可为特定图片开启缩放功能。如果一个页面没有任何地方使用，则不会加载 Fancybox 插件。\n\n{% image fancybox:true https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/2022/Apple_Shot-on-iphone-macro-challenge_Cat_big.jpg.large_2x.jpg download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/2022/Images-of-Shot-on-iphone-macro-challenge.zip 图片来自 Apple 官网 %}\n\n如果您希望全站所有的 `image` 标签都开启此功能，可在主题配置文件中修改以下参数：\n\n```yaml\n######## Tag Plugins ########\ntag_plugins:\n  # {% image %}\n  image:\n    fancybox: true\n```\n\n## Quot（引用标签）\n\n适合居中且醒目的引用：{% quot Stellar 是最好用的主题 %}\n\n支持自定义引号：{% quot 热门话题 icon:hashtag %}\n\n其中自定义引号素材在主题配置文件的 `tag_plugins.quot` 中配置。\n\n{% folding child:codeblock 写法如下 open:true %}\n```\n适合居中且醒目的引用：{% quot Stellar 是最好用的主题 %}\n支持自定义引号：{% quot 热门话题 icon:hashtag %}\n```\n{% endfolding %}\n\n{% quot 特别引用 icon:default %}\n\n> 此外，加上 `el:h2/h3/h4/h5/h6` 可以作为标题使用\n\n## Poetry（诗词标签）\n\n{% poetry 游山西村 author:陆游 footer:诗词节选 %}\n莫笑农家腊酒浑，丰年留客足鸡豚。\n**山重水复疑无路，柳暗花明又一村。**\n箫鼓追随春社近，衣冠简朴古风存。\n从今若许闲乘月，拄杖无时夜叩门。\n{% endpoetry %}\n\n{% folding child:codeblock 写法如下 open:true %}\n```\n{% poetry 游山西村 author:陆游 footer:诗词节选 %}\n莫笑农家腊酒浑，丰年留客足鸡豚。\n**山重水复疑无路，柳暗花明又一村。**\n箫鼓追随春社近，衣冠简朴古风存。\n从今若许闲乘月，拄杖无时夜叩门。\n{% endpoetry %}\n```\n{% endfolding %}\n\n## Note（备注标签）\n\n```md 语法格式\n{% note [title] content [color:color] %}\n```\n\n```yaml 参数说明\ntitle: 标题（可选）\ncontent: 内容\ncolor: red/orange/yellow/green/cyan/blue/purple/light/dark/warning/error\n```\n\n### 具有标题的备注标签\n\n直接写备注内容，默认是和代码块一样的样式，第一个空格前面的是标题，后面的是正文，如果标题中需要显示空格，请使用 `&nbsp;` 代替。\n\n{% note 这&nbsp;是标题 这是正文 哈哈。 %}\n\n```md 写法如下\n{% note 这&nbsp;是标题 这是正文 哈哈。 %}\n```\n\n### 彩色备注标签\n\n{% note 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n\n{% note color:red 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:orange 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:yellow 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:green 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:cyan 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:blue 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:purple 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:light 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:dark 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:warning 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:error 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n\n```md 写法如下\n{% note 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n{% note color:cyan 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %}\n```\n\n## Border（边框标签）\n\nborder 标签和 note 标签样式相同：\n\n{% border Stellar v1.12.0 color:warning %}\n因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：\nnoteblock -> grid -> border\n详情见：[#172](https://github.com/volantis-x/hexo-theme-volantis/issues/712)\n{% endborder %}\n\n```md 语法格式\n{% border [title] [color:color] [child:codeblock/tabs] %}\n...\n{% endborder %}\n```\n\n```md 写法如下\n{% border Stellar v1.12.0 color:warning %}\n因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：\nnoteblock -> grid -> border\n详情见：[#172](https://github.com/volantis-x/hexo-theme-volantis/issues/712)\n{% endborder %}\n```\n\n### 彩色代码块\n\n设置 `child:codeblock` 并设置 `color:颜色枚举` 可以实现 10 种不同颜色的代码块，彩色代码块一般可以用在代码正确与错误的示范对比场景。\n\n推荐的写法：\n\n{% border child:codeblock color:green %}\n```swift\nfunc test() {\n    // ...\n}\n```\n{% endborder %}\n\n不推荐的写法：\n\n{% border child:codeblock color:red %}\n```swift\nfunc test() -> Void {\n    // ...\n}\n// 或者\nfunc test() -> () {\n    // ...\n}\n```\n{% endborder %}\n\n### 嵌套其它标签\n\n{% border child:tabs %}\n{% tabs %}\n<!-- tab 图文混排 -->\n{% image /assets/xaoxuu/blog/2020-0627a@2x.webp 个人电脑作为办公设备时，我们该如何保护隐私？ download:true %}\n公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区进行加密。\n<!-- tab 示例代码 -->\n<script src=\"https://gist.github.xaox.cc/xaoxuu/c983c958ef0deab819376c231e977ba7.js\"></script>\n{% endtabs %}\n{% endborder %}\n\n## Split（两列分区标签）\n\n这个功能在 {% mark 1.12.0 color:dark %} 版本后开始支持，只支持显示两列，且手机端会恢复为单列显示。\n\n{% split %}\n<!-- cell left -->\n{% image https://images.unsplash.com/photo-1653979731557-530f259e0c2c?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 download:https://unsplash.com/photos/bcql6CtuNv0/download?ixid=MnwxMjA3fDB8MXx0b3BpY3x8NnNNVmpUTFNrZVF8fHx8fDJ8fDE2Njg4NDAxMDI&force=true %}\n<!-- cell right -->\n**[Unsplash Photo](https://unsplash.com/photos/bcql6CtuNv0)**\n\nThe Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Its mass is equal to four million suns. The center is located 25,800 light years away from Earth.\n\n> Ōwhiro Bay, Wellington, New Zealand\n> Published on May 31, 2022\n> SONY, ILCE-6000\n> Free to use under the Unsplash License\n\n{% endsplit %}\n\n块样式：\n\n{% split bg:block %}\n<!-- cell left -->\n<center>左侧内容</center>\n<!-- cell right -->\n<center>右侧内容</center>\n{% endsplit %}\n\n卡片样式：\n\n{% split bg:card %}\n<!-- cell left -->\n<center>左侧内容</center>\n<!-- cell right -->\n<center>右侧内容</center>\n{% endsplit %}\n\n示例代码：\n\n```\n{% split bg:block %}\n<!-- cell left -->\n<center>左侧内容</center>\n<!-- cell right -->\n<center>右侧内容</center>\n{% endsplit %}\n```\n\n> `bg` 为可选参数，默认没有背景，可设置为 `block/card` 两种样式\n\n## Folding（折叠块标签）\n\n折叠块标签的语法格式为：\n\n```\n{% folding title [codeblock:bool] [open:bool] [color:color] %}\ncontent\n{% endfolding %}\n```\n\n```yaml 参数说明\ncodeblock: true/false\nopen: true/false\ncolor: red/orange/yellow/green/cyan/blue/purple/light/dark\n```\n\n### 彩色可折叠代码块\n\n备注标签相较于旧版进行了增强，可以实现更多种颜色，还可以通过设置 `child:codeblock` 来实现可折叠的代码块。以下是一个默认打开的代码折叠框：\n\n{% folding child:codeblock open:true color:yellow 默认打开的代码折叠框 %}\n```swift\nfunc test() {\n  print(\"hello world\")\n}\n```\n{% endfolding %}\n\n代码如下：\n\n```\n{% folding child:codeblock open:true color:yellow 默认打开的代码折叠框 %}\n代码块\n{% endfolding %}\n```\n\n{% folding color:yellow 危险，请不要打开这个 %}\n通过设置颜色，以实现更醒目的作用，但不要滥用色彩哦～\n{% folding color:orange 警告，真的很危险 %}\n通过设置颜色，以实现更醒目的作用，但不要滥用色彩哦～\n{% folding color:red 最后一次警告，千万不要打开这个 %}\n不要说我们没有警告过你，Windows 10 不是為所有人設計，而是為每個人設計。\n{% endfolding %}\n{% endfolding %}\n{% endfolding %}\n\n## Folders（一组折叠标签）\n\n样式相比 `folding` 简单一些，适用于多个折叠标签平铺显示的场景，例如题目列表：\n\n{% folders %}\n<!-- folder 题目1 -->\n这是答案1\n<!-- folder 题目2 -->\n这是答案2\n<!-- folder 题目3 -->\n这是答案3\n{% endfolders %}\n\n代码如下：\n\n```\n{% folders %}\n<!-- folder 题目1 -->\n这是答案1\n<!-- folder 题目2 -->\n这是答案2\n<!-- folder 题目3 -->\n这是答案3\n{% endfolders %}\n```\n\n\n\n## Link（链接卡片标签）\n\n外链卡片标签的语法格式为：\n\n```\n{% link href [title] [icon:src] [desc:true/false] %}\n```\n\n```yaml 参数说明\nhref: 链接\ntitle: 可选，手动设置标题（为空时会自动抓取页面标题）\nicon: 可选，手动设置图标（为空时会自动抓取页面图标）\ndesc: 可选，是否显示摘要描述，为true时将会显示页面描述\n```\n\n不带摘要的样式：\n{% link https://xaoxuu.com/blog/20221029/ %}\n\n带摘要的样式：\n{% link https://xaoxuu.com/blog/20221029/ desc:true %}\n\n\n```md 写法如下\n不带摘要的样式：\n{% link https://xaoxuu.com/blog/20221029/ %}\n带摘要的样式：\n{% link https://xaoxuu.com/blog/20221029/ desc:true %}\n```\n\n## Copy（复制标签）\n\n对于单行内容，可以使用 `copy` 标签来实现复制功能：\n\n{% copy curl -s https://sh.xaox.cc/install | sh %}\n\n您可以设置 `git:https` 或者 `git:ssh` 或者 `git:gh` 来快速放置一个 git 仓库链接：\n{% copy git:https xaoxuu.com/hexo-theme-stellar %}\n\n\n```md 写法如下\n{% copy curl -s https://sh.xaox.cc/install | sh %}\n{% copy width:max curl -s https://sh.xaox.cc/install | sh %}\n{% copy git:https xaoxuu.com/hexo-theme-stellar %}\n{% copy git:ssh xaoxuu.com/hexo-theme-stellar %}\n{% copy git:gh xaoxuu.com/hexo-theme-stellar %}\n```\n\n## Radio（单选样式标签）\n\n{% radio 没有勾选的单选框 %}\n{% radio checked:true 已勾选的单选框 %}\n\n```md 写法如下\n{% radio 没有勾选的单选框 %}\n{% radio checked:true 已勾选的单选框 %}\n```\n\n```yaml 支持的参数\nchecked: true/false\ncolor: red/orange/yellow/green/cyan/blue/purple\n```\n\n## Checkbox（复选样式标签）\n\n{% checkbox 普通的没有勾选的复选框 %}\n{% checkbox checked:true 普通的已勾选的复选框 %}\n{% checkbox symbol:plus color:green checked:true 显示为加号的绿色的已勾选的复选框 %}\n{% checkbox symbol:minus color:yellow checked:true 显示为减号的黄色的已勾选的复选框 %}\n{% checkbox symbol:times color:red checked:true 显示为乘号的红色的已勾选的复选框 %}\n\n```md 写法如下\n{% checkbox 普通的没有勾选的复选框 %}\n{% checkbox checked:true 普通的已勾选的复选框 %}\n{% checkbox symbol:plus color:green checked:true 显示为加号的绿色的已勾选的复选框 %}\n{% checkbox symbol:minus color:yellow checked:true 显示为减号的黄色的已勾选的复选框 %}\n{% checkbox symbol:times color:red checked:true 显示为乘号的红色的已勾选的复选框 %}\n```\n\n```yaml 支持的参数\nchecked: true/false\ncolor: red/orange/yellow/green/cyan/blue/purple\nsymbol: plus/minus/times\n```\n\n{% note color:yellow 由于没有提交表单的需要，所以这个标签只是样式标签，不具有真实的单选/复选功能。 %}\n\n## Timeline（时间线标签）\n\n支持静态和动态时间线数据源。\n\n### 纯静态时间线\n\n静态数据是写死在 `md` 源文件中的，在 `deploy` 时就已经确定了。\n\n{% timeline %}\n<!-- node 2021 年 2 月 16 日 -->\n主要部分功能已经开发的差不多了。\n{% image /assets/wiki/stellar/photos/hello@1x.png width:300px %}\n<!-- node 2021 年 2 月 11 日 -->\n今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。\n{% endtimeline %}\n\n```md 写法如下\n{% timeline %}\n<!-- node 2021 年 2 月 16 日 -->\n主要部分功能已经开发的差不多了。\n{% image /assets/wiki/stellar/photos/hello@1x.png width:300px %}\n<!-- node 2021 年 2 月 11 日 -->\n今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。\n{% endtimeline %}\n```\n\n### 纯动态时间线\n\n动态数据是从 GitHub Issues 中拉取的，使用方法为：\n\n1. 建一个仓库\n2. 创建一个 `issue` 并添加一个 `label` 进行测试\n3. 写 `timeline` 标签时加上 `api:https://api.github.com/repos/your-name/your-repo/issues`\n\n例如：\n```\n{% timeline api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?direction=asc&per_page=3 %}{% endtimeline %}\n```\n\n效果如下：\n{% timeline api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?direction=asc&per_page=3 %}{% endtimeline %}\n\n### 静态 + 动态\n\n用法同静态和动态单独使用时一样，例如：\n\n```\n{% timeline reversed:true api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=2 %}\n<!-- node 这条内容为静态数据 -->\n这条内容为静态数据，静态数据在 `deploy` 时就已经确定了。\n{% endtimeline %}\n```\n\n### 数据筛选\n\n{% folders %}\n<!-- folder 只显示某个人的数据 -->\n{% timeline user:xaoxuu api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues %}{% endtimeline %}\n<!-- folder 筛选最近3条todo -->\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=todo&per_page=3 %}{% endtimeline %}\n<!-- folder 筛选评论最多的3条建议 -->\n{% timeline api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues?labels=feature-request&per_page=3&sort=comments %}{% endtimeline %}\n{% endfolders %}\n\n上述示例代码如下：\n\n```\n{% folders %}\n<!-- 只显示某个人的数据 -->\n{% timeline user:xaoxuu api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues %}{% endtimeline %}\n<!-- 筛选最近3条todo -->\n{% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=todo&per_page=3 %}{% endtimeline %}\n<!-- 筛选评论最多的3条建议 -->\n{% timeline api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues?labels=feature-request&per_page=3&sort=comments %}{% endtimeline %}\n{% endfolders %}\n```\n\n更多用法详见：\n\n{% link https://docs.github.com/en/rest/issues/issues#list-issues-assigned-to-the-authenticated-user GitHub&nbsp;REST&nbsp;API %}\n\n\n## Friends（友链组标签）\n\n{% friends 开源大佬 %}\n\n您可以在任何位置插入友链组，支持静态数据和动态数据，静态数据需要写在数据文件中：\n\n```yaml blog/source/_data/links.yml\n'开源大佬':\n    - title: 某某某\n      url: https://\n      screenshot:\n      avatar:\n      description:\n```\n\n在需要的位置这样写：\n\n```md 示例写法\n{% friends 开源大佬 %}\n```\n\n### 实现动态友链\n\n从 [xaoxuu/issues-json-generator](https://github.com/xaoxuu/issues-json-generator) 作为模板克隆或者 fork 仓库\n\n修改 `config.yml` 并打开 github action 的运行权限\n\n```yaml config.yml\n# 要抓取的 issues 配置\nissues:\n  repo: xaoxuu/friends # 仓库持有者/仓库名（改成自己的）\n  label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue\n  sort: # updated-desc # 排序，按最近更新，取消此项则按创建时间排序\n```\n\n不出意外的话，仓库中已经配置好了 issue 模板，只需要在模板中指定的位置填写信息就可以了。然后在自己的仓库里提交一个 issue 并将 `Label` 设置为 `active` 进行测试。\n\n提交完 issue 一分钟左右，如果仓库中出现了 `output` 分支提交，可以点击查看一下文件内容是否已经包含了刚刚提交的 issue 中的数据，如果包含，那么前端页面就可以使用友链数据了：\n\n```\n{% friends api:https://raw.githubusercontent.com/xaoxuu/friends/output/v2/data.json %}\n```\n\n### 数据托管\n\n{% border 特别感谢 color:light %}\n特别感谢小冰博客的加速访问方案，解决了直接请求 GitHub API 速度过慢的问题，详见 [小冰博客](https://zfe.space/post/python-issues-api.html) 的教程。\n{% endborder %}\n\n支持把数据托管到任何其他地方来使用，例如：\n\n```\n{% friends api:https://api.vlts.cc/output_data/v2/xaoxuu/friends %}\n```\n\n{% border Stellar 1.13.0 color:warning %}\n动态数据 API 升级至 v2 版本，原使用 issue-api 仓库的需要将友链仓库同步更新。\nv1 版本已经停止维护。\n{% endborder %}\n\n> 你可以有 N 种办法加速访问 GitHub 仓库里的文件。\n\n## Sites（网站卡片组标签）\n\n{% sites mac_app_download %}\n\n您可以在任何位置插入网站卡片组，支持静态数据和动态数据，静态数据需要写在数据文件中：\n\n```yaml blog/source/_data/links.yml\n'分组名':\n    - title: 某某某\n      url: https://\n      screenshot:\n      avatar:\n      description:\n```\n\n在需要的位置这样写：\n\n```md 示例写法\n{% sites 分组名 %}\n```\n\n{% border Stellar v1.13.0 color:warning %}\n原 friends 和 sites 标签数据合并至 `links.yml` 文件，动态数据使用方法同友链，数据源格式相同，与友链共享数据，仅样式不同，也可以用 `sites` 标签做友链。\n{% endborder %}\n\n## GitHub Card（GitHub卡片标签）\n\n{% ghcard xaoxuu %}\n\n{% ghcard xaoxuu/hexo-theme-stellar theme:dark %}\n\n```md 写法如下\n{% ghcard xaoxuu %}\n{% ghcard xaoxuu/hexo-theme-stellar theme:dark %}\n```\n\n{% link https://github.com/anuraghazra/github-readme-stats GitHub&nbsp;Card&nbsp;API %}\n\n## Navbar（导航栏标签）\n\n文章内也可以插入一个导航栏：\n\n```md\n{% navbar [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) %}\n```\n\n{% navbar [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) %}\n\n\n## About（关于标签）\n\n方便在关于页面显示一段图文信息：\n\n```\n{% about avatar:/assets/xaoxuu/avatar/rect-256@2x.png height:80px %}\n\n<img height=\"32px\" alt=\"XAOXUU\" src=\"/assets/xaoxuu/logo/180x30@2x.png\">\n\n**如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。**\n\nXAOXUU 目前是一个 iOS 开发者，代表作品有：ProHUD、ValueX 等。在业余时间也开发了 Stellar 博客主题，更多的作品可以去项目主页查看，希望大家喜欢～\n\n{% navbar [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) %}\n\n{% endabout %}\n```\n\n## Frame（设备框架标签）\n\n{% frame iphone11 img:/assets/wiki/prohud/toast/demo-loading.png video:/assets/wiki/prohud/toast/demo-loading.mp4 focus:top %}\n\n```md 示例写法\n{% frame iphone11 img:/assets/wiki/prohud/toast/demo-loading.png video:/assets/wiki/prohud/toast/demo-loading.mp4 focus:top %}\n```\n\n目前仅支持 iphone11 如果您有 iPhone12、iPad、Mac 等设备模型的 svg 图片，可以发给我进行适配。\n\n## Tabs（分栏标签）\n\n这个标签移植自 [NexT](https://theme-next.js.org/docs/tag-plugins/tabs.html) 主题，但做了以下修改：\n\n- 支持设置 `align:center` 来使内容居中\n- 设置默认激活的标签方式为 `active:1` 而非 `, 1`（使用默认格式降低学习成本，且显式声明可读性更强）\n- 不需要 `<!-- endtab -->` 来作为结束标识（因为 Stellar 会自动判断）\n- 不需要 `tabs id` 来保证唯一性（因为 Stellar 会设置唯一标识）\n- 不支持 `@icon` 方式设置图标（因为 Stellar 不再内置 `fontawesome` 图标库）\n- 轮廓样式简化，可以搭配其它容器类标签嵌套使用。\n\n{% tabs active:1 align:center %}\n\n<!-- tab 演示效果 -->\n\n{% tabs active:2 align:center %}\n\n<!-- tab 图片 -->\n{% image /assets/wiki/stellar/photos/hello@1x.png width:300px %}\n\n<!-- tab 代码块 -->\n```swift\nlet x = 123\nprint(\"hello world\")\n```\n\n<!-- tab 表格 -->\n| a | b | c |\n| --- | --- | --- |\n| a1 | b1 | c1 |\n| a2 | b2 | c2 |\n\n{% endtabs %}\n\n<!-- tab 示例代码 -->\n<script src=\"https://gist.github.xaox.cc/xaoxuu/cfd4e9645047115c6aa9b19cd9b28e97.js\"></script>\n\n{% endtabs %}\n\n## Swiper（轮播标签）\n\n默认一张图片是 50% 宽度，通过设置 `width:min` 设置为 25% 宽度，`width:max` 设置为 100% 宽度。\n\n### 最大图片宽度\n\n{% swiper width:max %}\n![](https://images.unsplash.com/photo-1483728642387-6c3bdd6c93e5?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2076&q=80)\n![](https://images.unsplash.com/photo-1502790671504-542ad42d5189?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1770&q=80)\n![](https://images.unsplash.com/photo-1494253188410-ff0cdea5499e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1770&q=80)\n{% endswiper %}\n\n```md 写法如下\n{% swiper width:max %}\n![](https://images.unsplash.com/photo-1483728642387-6c3bdd6c93e5?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2076&q=80)\n![](https://images.unsplash.com/photo-1502790671504-542ad42d5189?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1770&q=80)\n![](https://images.unsplash.com/photo-1494253188410-ff0cdea5499e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1770&q=80)\n{% endswiper %}\n```\n\n### 最小图片宽度\n\n{% swiper width:min %}\n![](https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n![](https://images.unsplash.com/photo-1528283648649-33347faa5d9e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n![](https://images.unsplash.com/photo-1542272201-b1ca555f8505?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n![](https://images.unsplash.com/photo-1524797905120-92940d3a18d6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n{% endswiper %}\n\n```md 写法如下\n{% swiper width:min %}\n![](https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n![](https://images.unsplash.com/photo-1528283648649-33347faa5d9e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n![](https://images.unsplash.com/photo-1542272201-b1ca555f8505?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n![](https://images.unsplash.com/photo-1524797905120-92940d3a18d6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80)\n{% endswiper %}\n```\n"},{"title":"基本信息配置","url":"/wiki/stellar/theme-settings/index.html","content":"\n## 站点信息\n\nStellar 会读取站点根目录下的 `_config.yml` 文件中的一些信息来生成您的网站，所以您需要修改以下值：\n\n```yaml blog/_config.yml\ntitle: 您的网站名称\navatar: 您的头像链接\nfavicon: 您的网站icon\n# 多语言\nlanguage:\n  - zh-CN\n  - en\n```\n\n### 多语言设置\n\n主题中的默认文案都支持多语言，以简体中文为例，您可以在 `themes/stellar/languages/zh-CN.yml` 中修改文案。\n\n更改网站优先语言，需要在站点根目录下的配置文件中进行修改：\n\n```yaml blog/_config.yml\nlanguage:\n  - zh-CN\n  - en\n  - zh-TW\n```\n\n## 创建主题配置文件\n\n在博客根目录的 `_config.yml` 文件旁边新建一个文件： `_config.stellar.yml` ，在这个文件中的配置信息优先级高于主题文件夹中的配置文件。\n\n\n## 头部标签自定义\n\n### Open Graph\n\n默认生成 Open Graph 标签，如果您不希望生成它，可以在主题配置文件中关闭：\n\n```yaml blog/_config.stellar.yml\nopen_graph:\n  enable: true\n  twitter_id: # for open_graph meta\n```\n"},{"title":"自定义小组件的配置与使用","url":"/wiki/stellar/widgets/index.html","content":"\n侧边栏组件库在 `_data/widgets.yml` 文件中，配置和使用是两个部分，使用较为简单，即在需要的地方指定组件名：\n\n```yaml blog/source/_posts/xxx.md\n---\nsidebar: ['我的小组件1', '我的小组件2']\n---\n```\n\n也可以在配置文件中指定各个页面默认使用哪些组件：\n\n```yaml blog/_config.stellar.yml\nsidebar:\n  widgets:\n    index: [welcome, recent, timeline] # for home/wiki/categories/tags/archives/404 pages\n    page: [welcome, toc] # for pages using 'layout:page'\n    post: [toc, ghrepo, ghissues] # for pages using 'layout:post'\n    wiki: [toc, ghrepo, ghissues, related] # for pages using 'layout:wiki'\n```\n\n{% border Stellar 1.11.0 color:red %}\n侧边栏组件配置从` _config.yml` 中转移到数据文件 `_data/widgets.yml` 中，且仅支持在数据文件中配置。同时布局由 `sidebar.widgets_layout` 改名为 `sidebar.widgets`\n{% endborder %}\n\n各种组件配置方法如下：\n\n{% quot el:h2 toc %}\n\n这是文章/文档的目录树组件，显示文章和文档的目录结构：\n\n```yaml blog/source/_data/widgets.yml\ntoc:\n  layout: toc\n  list_number: false # 是否显示序号\n  min_depth: 2 # 建议不要低于 2 即从 H2 标签开始解析（H1标签用于文章大标题）\n  max_depth: 5 # 5 代表最多解析到 H5 标签\n  fallback: recent # Use a backup widget when toc does not exist.\n```\n\n`toc` 的 `fallback` 默认是 `recent`，即一篇文章没有 `TOC` 的时候会显示一个 `recent`\n\n{% quot el:h2 recent %}\n\n```yaml blog/source/_data/widgets.yml\nrecent:\n  layout: recent\n  rss: # /atom.xml # npm i hexo-generator-feed\n  limit: 5 # Count of posts\n```\n\n在 `wiki` 板块显示的是最近更新的 `wiki` 页面，其余地方显示最近更新的文章。\n\n`hexo` 的覆盖规则是合并而不是替换，所以若不想使用 `recent`，除了在 `_config.stellar.yml` 中删除 `recent` 你还需要将此处的 `recent` 置空，即\n\n```yaml blog/source/_data/widgets.yml\nrecent:\n#  layout: recent\n#  rss: # /atom.xml # npm i hexo-generator-feed\n#  limit: 5 # Count of posts\n```\n\n然后自己需要的地方用自己另建的一个 `my_recent` 组件\n\n```yaml blog/source/_data/widgets.yml\nmy_recent:\n  layout: recent\n  ...\n```\n\n{% quot el:h2 related %}\n\n相关文档组件，用于显示具有相同 `tags` 的其它项目列表，暂不支持自定义内容：\n\n{% border Stellar 1.12.0 color:red %}\n1.12.0 已将 `wiki_more`，更名为 `related`\n{% endborder %}\n\n```yaml blog/source/_data/widgets.yml\nrelated:\n  layout: related\n```\n\n{% quot el:h2 markdown %}\n\n这是一个自由度很高的标签，可以显示 [markdown](https://docs.github.com/cn/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) 文本内容：\n\n```yaml blog/source/_data/widgets.yml\nwelcome:\n  layout: markdown\n  title: 欢迎欢迎\n  content: |\n    欢迎使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 主题，下面是您的入门指南，祝您使用愉快！\n    <br>\n    **第一步**\n    创建 `blog/_config.stellar.yml` 文件，在此文件中填写需要自定义的主题配置。\n    <br>\n    **第二步**\n    创建 `blog/source/_data/widgets.yml` 文件，此文件中填写需要自定义的侧边栏组件，例如 `welcome` 组件。\n    <br>\n    如果有任何疑问，请先查阅 [文档](https://xaoxuu.com/wiki/stellar/)，如果文档中没有提供，请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues/) 向开发中询问。\n```\n\n{% quot el:h2 tagcloud %}\n\n标签云组件：\n\n```yaml blog/source/_data/widgets.yml\ntagcloud:\n  layout: tagcloud\n  title: 标签云\n  # 标签云配置\n  min_font: 12\n  max_font: 24\n  amount: 100\n  orderby: name\n  order: 1 # 1, sac 升序；-1, desc 降序\n  color: false # 使用颜色\n  start_color:  # 开始的颜色。您可使用十六进位值（'#b700ff'），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。\n  end_color:  # 结束的颜色。您可使用十六进位值（'#b700ff'），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。\n  show_count: false # 显示每个标签的文章总数\n```\n\n{% quot el:h2 ghuser %}\n\n显示 GitHub 用户基础信息：\n\n```yaml blog/source/_data/widgets.yml\nghuser:\n  layout: ghuser\n  api: https://api.github.com # 若有 api.github.com 镜像可填，否则保持默认\n  username: github # your github login username\n  avatar: true # show avatar or not\n  menu: true # show menu or not\n```\n\n{% quot el:h2 ghrepo %}\n\n显示 GitHub 仓库基础信息，需要搭配 `repo` 一起使用：\n\n```yaml blog/source/_data/widgets.yml\nghrepo:\n  layout: ghrepo\n```\n\n需要在需要显示的文章页面的 `front-matter` 中按照如下格式写上仓库持有者和仓库名：\n\n```yaml blog/source/_posts/xxx.md\n---\nrepo: xaoxuu/hexo-theme-stellar\n---\n```\n\n如果需要显示在 `wiki` 项目中，则在 `_data/projects.yml` 中填写到对应项目的信息中：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  title: Stellar\n  subtitle: '每个人的独立博客 | Designed by xaoxuu'\n  repo: xaoxuu/hexo-theme-stellar\n  ...\n```\n\n{% quot el:h2 timeline %}\n\n时间线组件，这个功能在 {% mark 1.12.0 color:dark %} 版本后开始支持：\n\n```yaml blog/source/_data/widgets.yml\ntimeline:\n  layout: timeline\n  title: 近期动态\n  api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues # 若你想限制数量，在api链接后面加上?per_page=1指限制为1条\n  user: # 是否过滤只显示某个人发布的内容，如果要筛选多人，用英文逗号隔开\n  hide: # title,footer # 隐藏标题或底部 # 此功能需要 Stellar v1.13.0\n```\n\n现在侧边栏不仅能放置近期动态，还可以放置朋友圈文章，这个功能在 {% mark 1.13.0 color:dark %} 版本后开始支持。\n\n```yaml blog/source/_data/widgets.yml\n# 愣着干啥，新建啊\n'朋友圈':\n  layout: timeline\n  title: 近期动态\n  api: https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator # 你的朋友圈数据文件地址\n  type: fcircle\n  limit: # 可通过这个限制最大数量\n```\n\n然后你可以在 `_config.stellar.yml` 中设置引用\n\n```yaml blog/_config.stellar.yml\nsidebar:\n  ...\n  widgets:\n    index: [welcome, 朋友圈]\n```\n\n或者在你需要显示的页面引入，页面内引入优先于配置文件引入：\n\n```yaml blog/source/_posts/xxx.md\n---\nsidebar: [ghuser, search, 朋友圈]\n---\n```\n\n## 专用组件\n\n需要在多个地方使用的组件配置在数据文件 `_data/widgets.yml` 中，只在某一篇文章中使用的组件可以配置在 `front-matter` 中，例如：\n\n```yaml blog/source/_posts/xxx.md\n---\ntitle: 某一篇文章\nsidebar:\n  - toc # 只写一个字符串代表引用对应的通用组件\n  - layout: markdown\n    title: '重要通知 [NOTE.2022-09]'\n    content: |\n      请不要原封不动的把本站内容复制到贵站中使用，这样一方面不尊重原作者，另一方面也会因为存在大量重复内容影响贵站收录甚至降权。\n\n      从2022年9月起本站已不再开源，已经持有源码副本或`fork`的朋友请及时删除以防止被他人恶意搬运的情况继续发生。\n      \n      [> 了解详情](https://github.com/xaoxuu/xaoxuu.github.io#readme)\n---\n```\n\n在 `front-matter` 中创建的专用组件应至少包含 `layout` 或者 `override` 属性，如果需要继承自某个通用组件，可以在 `override` 属性写上对应通用组件的名字（对应的通用组件必须要有 `layout` 属性）。\n\n```yaml blog/source/_posts/xxx.md\n---\ntitle: 某一篇文章\nsidebar:\n  - toc # 只写一个字符串代表引用对应的通用组件\n  - override: my_timeline_lite\n    api: https://xxx\n---\n```\n\n对应的通用组件是：\n\n```yaml blog/source/_data/widgets.yml\nmy_timeline_lite:\n  layout: timeline\n  title: 近期动态\n  user: xaoxuu\n  hide: title,footer\n```"},{"title":"如何使用文档系统","url":"/wiki/stellar/wiki-settings/index.html","content":"\nStellar 独创了其它 Hexo 主题所没有的 Wiki 系统，可以自动找到一个项目的所有文档分页，生成一个目录树，还可以手动指定顺序、标题、分组，而非依赖文件路径、文件名来排序和显示。\n\n## 创建一个项目\n\n在 `blog/source/` 文件夹中创建一个 `wiki` 文件夹，在其中放入各个项目的文档。以 Stellar 项目为例：\n\n```\nblog/source/wiki/stellar/index.md\n```\n\n设置布局模板和项目名称：\n\n```yaml blog/source/wiki/stellar/index.md\n---\nlayout: wiki  # 使用wiki布局模板\nwiki: Stellar # 这是项目名\ntitle: 这是分页标题\n---\n```\n\n建议用这个文件作为项目的主页，并在文件夹内创建其它分页。Stellar 会把同一个项目的所有分页中 `order` 最小的一页作为项目的主页（其默认值为0）。\n\n## 完善项目信息\n\n在数据文件中创建项目文件，以 Stellar 为例：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  name: Stellar\n  title: Stellar - 每个人的独立博客\n  subtitle: '每个人的独立博客 | Designed by xaoxuu'\n  tags: 博客主题\n  cover: true\n  logo:\n    src: /assets/wiki/stellar/icon.svg\n    small: 112px\n    large: 240px\n  description: Stellar 是一个内置 wiki 系统的 hexo 主题，适合综合型站点使用。同时也拥有简约而精美的视觉设计和丰富的标签插件，帮助您简单从容地应对各种场合。\n  repo: xaoxuu/hexo-theme-stellar\n  comment_title: '评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。'\n  beaudar:\n    repo: xaoxuu/hexo-theme-stellar\n    'issue-term': 'Q & A'\n```\n\n\n### 是否显示封面\n\n项目可以显示一个全屏封面，封面占据一个屏幕的高度，会居中依次显示项目的 logo、标题、描述。开启项目封面方法如下：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  cover: true\n  logo:\n    src: /assets/wiki/stellar/icon.svg\n    small: 120px\n    large: 240px\n```\n\n如果 logo 中已经包含了项目标题，可以这样设置不显示项目标题：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  cover: [logo, description]\n```\n\n### 项目文档标签\n\n如果您有很多项目，有些项目是有相关性的，可以相同的 `tags` 值：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  tags: 博客主题\n```\n\n也可以设置多个 `tags` 值：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  tags: [博客主题, 开源项目]\n```\n\n\n### 项目的 GitHub 仓库信息\n\n设置了 `repo` 值就会在侧边栏显示项目仓库的相关链接：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  repo: xaoxuu/hexo-theme-stellar\n```\n\n### 项目评论设置\n\n如果希望项目的所有分页使用相同的评论数据，可以在这里覆盖评论配置：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  comment_title: '评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。'\n  comments:\n    service: beaudar\n    beaudar:\n      repo: xaoxuu/hexo-theme-stellar\n      'issue-term': 'Q & A'\n```\n\n### 是否索引\n\n如果您有些项目希望在项目列表中隐藏，可以设置 `index` 值：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  index: false\n```\n\n## 文档排序\n\n一个项目文档的多个分页之间以 `order` 的值作为排序依据，数字越小越靠前，最小的是项目主页。\n\n## 侧边栏设置\n\n### 侧边栏组件\n\n如果您希望自定义某个项目的侧边栏组件，可以设置 `sidebar` 值：\n\n```yaml blog/source/_data/projects.yml\nNotes:\n  sidebar: [toc]\n```\n\n### 对目录树进行分组\n\n如果您的项目文档分页较多，可以对目录树进行分组：\n\n```yaml blog/source/_data/projects.yml\nStellar:\n  ...\n  sections:\n    '快速开始': [0, 99]\n    '基本使用': [100, 199]\n    '文档系统': [200, 299]\n    '进阶设定': [900, 999]\n```\n\n左边是显示的标题，右边是 `order` 的区间，例如某页文档的 `order` 是 `150`，那么这页文档将会显示在「日常问题解决方案」这个组中。\n\n\n\n## 修改 wiki 路径\n\n在根目录中添加 `wiki_dir` 指定 Wiki 主页的路径：\n\n```yaml blog/_config.yml\nwiki_dir: wiki\n```\n\n例如书籍类的“项目”可以改为：\n\n```yaml blog/_config.yml\nwiki_dir: books\n```\n\n例如商品/产品类的“项目”可以改为：\n\n```yaml blog/_config.yml\nwiki_dir: products\n```\n"}]
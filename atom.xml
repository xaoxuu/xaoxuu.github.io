<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XAOXUU</title>
  <icon>https://xaoxuu.com/assets/xaoxuu/avatar/rect-256@2x.png</icon>
  <subtitle>风暴前夕 | xaoxuu.com</subtitle>
  <link href="https://xaoxuu.com/atom.xml" rel="self"/>
  
  <link href="https://xaoxuu.com/"/>
  <updated>2022-11-21T00:00:00.000Z</updated>
  <id>https://xaoxuu.com/</id>
  
  <author>
    <name>xaoxuu</name>
    <email>me@xaoxuu.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅尝 GitHub Codespaces</title>
    <link href="https://xaoxuu.com/blog/20221121/"/>
    <id>https://xaoxuu.com/blog/20221121/</id>
    <published>2022-11-21T00:00:00.000Z</published>
    <updated>2022-11-21T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 最近上线了 <mark class="tag-plugin mark" color="dark">Codespaces</mark> 功能，页面入口如下：</p><div class="tag-plugin image"><div class="image-bg"><img src="https://bu.dusays.com/2022/11/21/637b8254e794a.png"/></div></div><p>免费账号可以使用 120 core-hours compute • 15GB storage 额度：</p><div class="tag-plugin image"><div class="image-bg"><img src="https://bu.dusays.com/2022/11/21/637b8f99caa22.png"/></div></div><p>感觉挺不错的，赶快来体验吧～</p><p class="tag-plugin quot" type="text">使用方法</p><p>现在，每个项目仓库 <mark class="tag-plugin mark" color="dark">Code</mark> 的下拉菜单中多了一个 <mark class="tag-plugin mark" color="dark">Codespaces</mark> 入口，点击就可以创建一个此项目仓库的 Codespaces 如图所示：</p><div class="tag-plugin image"><div class="image-bg"><img src="https://bu.dusays.com/2022/11/21/637b90778847c.png" style="width:400px;"/></div></div><p>由于我的博客源码是通过 submodule 方式引用主题的，而且还设置了 GitHub Actions 自动化部署，所以几分钟等待过后 Codespaces 就已经把博客全套环境创建完成了，在这整个过程中不需要自己进行任何配置：</p><div class="tag-plugin image"><div class="image-bg"><img src="https://bu.dusays.com/2022/11/21/637b91cfb2d7e.png"/></div></div><p>修改完代码直接提交到当前仓库，就和在本地提交 git 代码一样。</p><p class="tag-plugin quot" type="text">浅尝小结</p><p>初始化和博客环境搭建过程体验非常好，全程不需要操作。但是速度和本地相比是明显感觉到慢点的，由于自己写了一个 <mark class="tag-plugin mark" color="dark">macOS</mark> 平台的云脚本也可以在新装系统上一键完成全套流程，所以它可能不太适合我用来管理博客。</p><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://xaoxuu.com/wiki/cloud-shell/blog/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div><span class="cap link fs12">https://xaoxuu.com/wiki/cloud-shell/blog/</span></div><div class="bottom"><span class="title">https://xaoxuu.com/wiki/cloud-shell/blog/</span><span class="cap desc fs12"></span></div></a></div><p>不知道大家会用它来做什么呢？<span class="tag-plugin emoji"><img no-lazy="" class="inline" src="https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatthink.png"/></span></p>]]></content>
    
    
    <summary type="html">GitHub 最近上线了 Codespaces 功能，免费账号可以使用 120 core-hours compute • 15GB storage 额度，感觉挺不错的，赶快来体验吧～</summary>
    
    
    
    <category term="新闻稿" scheme="https://xaoxuu.com/blog/categories/%E6%96%B0%E9%97%BB%E7%A8%BF/"/>
    
    
    <category term="GitHub" scheme="https://xaoxuu.com/blog/tags/github/"/>
    
    <category term="Codespaces" scheme="https://xaoxuu.com/blog/tags/codespaces/"/>
    
  </entry>
  
  <entry>
    <title>探索 Stellar 时间线标签的 N 种用法</title>
    <link href="https://xaoxuu.com/blog/20221029/"/>
    <id>https://xaoxuu.com/blog/20221029/</id>
    <published>2022-10-29T00:00:00.000Z</published>
    <updated>2019-11-06T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间线标签是 Stellar 最强大的特性之一，它可以以侧边栏组件身份出现在左侧边栏，可以以标签插件形式出现在文章任意位置，以下是笔者能想到的几种常见用法。</p><span id="more"></span><h2 class="tag-plugin quot" type="icon" id="教程与步骤"><a href="#教程与步骤" class="headerlink" title="教程与步骤"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />教程与步骤</h2><div class="tag-plugin split" ><div class="cell" index="0"><p><strong>效果</strong></p><div class="tag-plugin timeline"><div class="timenode" index="0"><div class="header"><p>第一步：打开 GitHub</p></div><div class="body fs14"><p>打开 <a href="https://github.com/xaoxuu/hexo-theme-stellar/">Stellar</a> 的 GitHub 页面。</p></div></div><div class="timenode" index="1"><div class="header"><p>第二步：点击 Star</p></div><div class="body fs14"><p>如果发现右上角的 Star 还没点亮，就点亮它！</p></div></div></div></div><div class="cell" index="1"><p><strong>源码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline %&#125;</span><br><span class="line">&lt;!-- node 第一步：打开 GitHub --&gt;</span><br><span class="line">打开 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 的 GitHub 页面。</span><br><span class="line">&lt;!-- node 第二步：点击 Star --&gt;</span><br><span class="line">如果发现右上角的 Star 还没点亮，就点亮它！</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div></div><h2 class="tag-plugin quot" type="icon" id="近期动态（说说）"><a href="#近期动态（说说）" class="headerlink" title="近期动态（说说）"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />近期动态（说说）</h2><p>设置 <code>user:xxx</code> 则会只显示某人发的 <code>issue</code> 数据，可以用来展示个人动态。</p><div class="tag-plugin tabs"id="tab_1""><ul class="nav-tabs"><li class="tab active"><a href="#tab_1-1">效果</a></li><li class="tab"><a href="#tab_1-2">源码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><div class="tag-plugin timeline stellar-timeline-api" api="https://api.github.xaox.cc/repos/xaoxuu/blog-timeline/issues?per_page=2" user="xaoxuu"></div></div><div class="tab-pane" id="tab_1-2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline user:xaoxuu api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=2 %&#125;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div></div></div><h2 class="tag-plugin quot" type="icon" id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />话题讨论</h2><p>如果不限制 <code>user:xxx</code> 则会显示所有人发的 <code>issue</code> 数据，可通过 <code>labels</code> 筛选用于展示某一话题。</p><div class="tag-plugin tabs"id="tab_2""><ul class="nav-tabs"><li class="tab active"><a href="#tab_2-1">效果</a></li><li class="tab"><a href="#tab_2-2">源码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab_2-1"><div class="tag-plugin timeline stellar-timeline-api" api="https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/issues?labels=1.x+版本&per_page=3"></div></div><div class="tab-pane" id="tab_2-2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=1.x+版本&amp;per_page=3 %&#125;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div></div></div><h2 class="tag-plugin quot" type="icon" id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />扩展阅读</h2><p>可设置 <code>hide:title,footer</code> 隐藏标题和底部栏以进行紧凑型布局，例如 <a href="https://xaoxuu.com/wiki/stellar/articles/">#探索号</a> 系列文章：</p><div class="tag-plugin tabs"id="tab_3""><ul class="nav-tabs"><li class="tab active"><a href="#tab_3-1">效果</a></li><li class="tab"><a href="#tab_3-2">源码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab_3-1"><div class="tag-plugin timeline stellar-timeline-api" api="https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&labels=分享&per_page=3" hide="title,footer"></div></div><div class="tab-pane" id="tab_3-2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline hide:title,footer api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&amp;labels=分享&amp;per_page=3 %&#125;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div></div></div><h2 class="tag-plugin quot" type="icon" id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />更新日志</h2><p>不只是 <code>issues</code> 数据，时间线也兼容 <code>releases</code> 数据，可直接用于展示项目更新日志：</p><div class="tag-plugin tabs"id="tab_4""><ul class="nav-tabs"><li class="tab active"><a href="#tab_4-1">效果</a></li><li class="tab"><a href="#tab_4-2">源码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab_4-1"><div class="tag-plugin timeline stellar-timeline-api" api="https://api.github.com/repos/xaoxuu/hexo-theme-stellar/releases?per_page=3"></div></div><div class="tab-pane" id="tab_4-2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/releases?per_page=3 %&#125;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div></div></div><h2 class="tag-plugin quot" type="icon" id="友链文章订阅"><a href="#友链文章订阅" class="headerlink" title="友链文章订阅"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />友链文章订阅</h2><p>嗯，除了 <code>issues</code> 和 <code>releases</code> 数据，时间线还兼容「友链朋友圈」数据，可以展示小伙伴们最近发布的文章：</p><div class="tag-plugin split" ><div class="cell" index="0"><p><strong>效果</strong></p><div class="tag-plugin timeline stellar-fcircle-api" api="https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator" limit="3"></div></div><div class="cell" index="1"><p><strong>源码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline type:fcircle limit:3 api:https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator %&#125;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><p>因为篇幅有限，这里设置了最多只显示 3 条数据，实际可根据需要进行设置。</p></div></div><h2 class="tag-plugin quot" type="icon" id="热评文章"><a href="#热评文章" class="headerlink" title="热评文章"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />热评文章</h2><p>如果使用基于 issues 的评论系统，可以通过按评论数排序展示热评文章：</p><div class="tag-plugin tabs"id="tab_5""><ul class="nav-tabs"><li class="tab active"><a href="#tab_5-1">效果</a></li><li class="tab"><a href="#tab_5-2">源码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab_5-1"><div class="tag-plugin timeline stellar-timeline-api" api="https://api.github.com/repos/xaoxuu/blog-comments/issues?sort=comments&per_page=3" user="utterances-bot,beaudar-bot" hide="title,user"></div></div><div class="tab-pane" id="tab_5-2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline hide:title,user user:utterances-bot,beaudar-bot api:https://api.github.com/repos/xaoxuu/blog-comments/issues?sort=comments&amp;per_page=3 %&#125;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><p>因为篇幅有限，这里设置了最多只显示 3 条数据，实际可根据需要进行设置。</p></div></div></div><h2 class="tag-plugin quot" type="icon" id="侧边栏时间线"><a href="#侧边栏时间线" class="headerlink" title="侧边栏时间线"></a><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />侧边栏时间线</h2><p>在 <code>source/_data/widgets.yml</code> 文件中创建时间线组件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">timeline:</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">timeline</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">近期动态</span></span><br><span class="line">  <span class="attr">api:</span> <span class="string">https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=1</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">xaoxuu</span></span><br><span class="line"></span><br><span class="line"><span class="attr">timeline_stellar_more:</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">timeline</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Stellar</span> <span class="string">探索号</span></span><br><span class="line">  <span class="attr">api:</span> <span class="string">https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&amp;labels=分享&amp;per_page=5</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="string">title</span></span><br></pre></td></tr></table></figure><p>然后在需要显示的页面的 <code>front-matter</code> 中的 <code>sidebar</code> 部分写上它的名字，例如本文的配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span> [<span class="string">toc</span>, <span class="string">timeline_stellar_more</span>]</span><br></pre></td></tr></table></figure><p>大家有什么关于 Stellar 的文章想要分享吗？欢迎投稿，提完 <code>issue</code> 这里就可以看到了，不要乱投哦～</p><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://xaoxuu.com/wiki/stellar/articles/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div><span class="cap link fs12">https://xaoxuu.com/wiki/stellar/articles/</span></div><div class="bottom"><span class="title">https://xaoxuu.com/wiki/stellar/articles/</span><span class="cap desc fs12"></span></div></a></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;时间线标签是 Stellar 最强大的特性之一，它可以以侧边栏组件身份出现在左侧边栏，可以以标签插件形式出现在文章任意位置，以下是笔者能想到的几种常见用法。&lt;/p&gt;</summary>
    
    
    
    <category term="技术分享" scheme="https://xaoxuu.com/blog/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Stellar" scheme="https://xaoxuu.com/blog/tags/stellar/"/>
    
    <category term="Hexo" scheme="https://xaoxuu.com/blog/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>用 GitHub 搭建一个简单的脚本库</title>
    <link href="https://xaoxuu.com/blog/20210102/"/>
    <id>https://xaoxuu.com/blog/20210102/</id>
    <published>2021-01-02T00:00:00.000Z</published>
    <updated>2021-01-02T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin note" color="warning"><div class="title"><strong>接口变动</strong></div><div class="body"><p>近期已升级至 v3 版本，文章内容已更新。</p></div></div><p>细心的朋友可能会发现，我提供的一些脚本都可以在不依赖任何包管理工具的情况下通过一行命令安装，并且它们的安装命令极为相似：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -s https://sh.xaox.cc/install | bash -s hexo</span><br><span class="line">curl -s https://sh.xaox.cc/install | bash -s tag</span><br><span class="line">curl -s https://sh.xaox.cc/install | bash -s vimcn</span><br><span class="line">curl -s https://sh.xaox.cc/install | bash -s podspec</span><br></pre></td></tr></table></figure><p>虽然它们安装方式极为相似，但是安装逻辑却并非完全相同，例如前三者是安装到 <code>/usr/local/bin/</code> 目录下，在任意位置打开终端都可以使用，而  <code>podspec.sh</code> 则是下载到当前目录下。</p><p>如果打开 <code>https://sh.xaox.cc/install</code> 文件，你会发现它并没有做任何实质性的操作，只是负责任务派发，根据不同的参数把「安装」指令指派给不同的项目，不同的项目对「安装」的具体实现可以相同也可以不同。</p><p>对于相同的部分，以 <code>vimcn</code> 为例，它的 <code>index.sh</code> 实现如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这个脚本负责下载和安装的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># function lib</span></span><br><span class="line">lib=<span class="string">&#x27;https://sh.xaox.cc/lib/v3&#x27;</span></span><br><span class="line"><span class="comment"># repository name</span></span><br><span class="line">REPO=<span class="string">&#x27;vimcn&#x27;</span></span><br><span class="line"><span class="comment"># clint file name</span></span><br><span class="line">TARGET=<span class="string">&#x27;cli.sh&#x27;</span></span><br><span class="line"><span class="comment"># clint file name</span></span><br><span class="line">RENAME=<span class="string">&#x27;upload&#x27;</span></span><br><span class="line"><span class="comment"># download version</span></span><br><span class="line">VERSION=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$VERSION</span>&quot;</span> == <span class="string">&quot;&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    VERSION=<span class="string">&#x27;main&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">on_success</span></span>() &#123;</span><br><span class="line">    doc_url=xxx</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;\n&gt; \033[32m恭喜您，安装成功！\033[0m 请收藏这个页面，在您遇到问题的时候可以查看文档：\n<span class="variable">$&#123;doc_url&#125;</span>\n\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curl -s <span class="variable">$&#123;lib&#125;</span>/download.sh | sh -s <span class="variable">$&#123;REPO&#125;</span> <span class="variable">$&#123;VERSION&#125;</span> <span class="variable">$&#123;TARGET&#125;</span> &amp;&amp;</span><br><span class="line">curl -s <span class="variable">$&#123;lib&#125;</span>/install.sh | sh -s <span class="variable">$HOME</span>/Downloads/<span class="variable">$&#123;TARGET&#125;</span> <span class="variable">$&#123;RENAME&#125;</span> &amp;&amp; on_success</span><br></pre></td></tr></table></figure><p>从中可以看到它导入了一个「库」，确切的说是一个存放可复用代码的仓库地址，具体的「下载」与「安装」脚本像独立组件一样可供外部调用。与此例不同的 <code>podspec.sh</code> 脚本就只有下载操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="variable">$&#123;lib&#125;</span>/download.sh | sh -s <span class="variable">$&#123;REPO&#125;</span> <span class="variable">$&#123;VERSION&#125;</span> <span class="variable">$&#123;TARGET&#125;</span> ./ &amp;&amp;</span><br><span class="line"><span class="built_in">chmod</span> 777 <span class="variable">$&#123;TARGET&#125;</span> &amp;&amp; on_success</span><br></pre></td></tr></table></figure><h2 id="易于扩展"><a href="#易于扩展" class="headerlink" title="易于扩展"></a>易于扩展</h2><p>这么一套流程使得脚本安装变得非常有扩展性，如果需要发布一个新的脚本，只需要新建仓库，在其中写一个 <code>index.sh</code> 脚本，通过调用 <code>lib</code> 仓库里封装好的脚本，传入仓库名、版本、要下载的文件，就可以轻松实现下载安装流程。</p><h2 id="易于使用"><a href="#易于使用" class="headerlink" title="易于使用"></a>易于使用</h2><p>更重要的是，可以通过一行命令来安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -s https://sh.xaox.cc/install | sh -s 我的脚本</span><br></pre></td></tr></table></figure><p>这套体系类似于包管理工具一样，但目前只对创建在 <a href="https://github.com/cloud-shell-lib/">@cloud-shell-lib</a> 中的仓库有效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就是一个比包管理工具更轻量级更小的「个人脚本管理」体系，不需要本地依赖，适合经常换系统、换设备执行一些轻量级任务的场景。</p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a><del>Todo</del></h2><p>暂时没有 todo 了，不打算折腾了，感兴趣的朋友可以自己研究一下，不懂的话可以留言询问。搭建方法就是：</p><ol><li>fork <a href="https://github.com/cloud-shell-lib/lib">lib</a> 或者自己创建一个更好的公共库。</li><li>在网站某个路径下放一个 <a href="https://sh.xaox.cc/install">install</a> 文件，根据传入参数把指令转发给目标脚本仓库。</li><li>在目标脚本仓库中创建一个命名固定的脚本用于接收传入的指令，然后可以根据需要执行操作或者调用公共库的下载、安装等通用流程。</li></ol>]]></content>
    
    
    <summary type="html">细心的朋友可能会发现，我提供的一些脚本都可以在不需要任何包管理工具的情况下通过一行命令安装，本文讲述如何搭建一个轻量级的脚本库，方便随时执行自己存放于仓库的脚本。</summary>
    
    
    
    <category term="设计开发" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="shell" scheme="https://xaoxuu.com/blog/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>苹果设计开发加速器线上活动</title>
    <link href="https://xaoxuu.com/blog/20201119/"/>
    <id>https://xaoxuu.com/blog/20201119/</id>
    <published>2020-11-19T00:00:00.000Z</published>
    <updated>2020-11-19T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>受疫情影响，今年设计开发加速器活动改为线上形式，本次参与的活动课题是《为 iPhone 和 iPad 搭建灵活适配的用户界面》。<span id="more"></span>新出的几款 iPhone 和 iPad 设备尺寸和旧设备都不同，造成适配成本增加，本次活动目的是向开发者分享高效而灵活的适配方案。</p><h2 id="避免屏幕分辨率硬编码"><a href="#避免屏幕分辨率硬编码" class="headerlink" title="避免屏幕分辨率硬编码"></a>避免屏幕分辨率硬编码</h2><p>常见陷阱：对硬件设备型号做特殊判断</p><h2 id="适配方面"><a href="#适配方面" class="headerlink" title="适配方面"></a>适配方面</h2><ul><li>启动屏</li><li>安全区和布局边框</li><li>尺寸类</li><li>动态字体</li></ul><h3 id="启动屏"><a href="#启动屏" class="headerlink" title="启动屏"></a>启动屏</h3><p>用 Storyboard 启动屏，不建议用图片作为启动页，详见官方设计指南：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="Human Interface Guidelines" href="https://developer.apple.com/design/human-interface-guidelines/patterns/launching/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="icon"><div class="left"><span class="title">Human Interface Guidelines</span><span class="cap link fs12">https://developer.apple.com/design/human-interface-guidelines/patterns/launching/</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div><h3 id="安全区和布局边框"><a href="#安全区和布局边框" class="headerlink" title="安全区和布局边框"></a>安全区和布局边框</h3><p><strong>安全区</strong></p><p>UIScreen &amp; UIWindow 获得布局尺寸进行排版不适用于 iPhone X 以及以后机型</p><p>要使用安全区来进行布局（安全区是动态的，不同设备、横竖屏、子视图都不相同）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.safeAreaInsets</span><br><span class="line">.safeAreaLayoutGuide</span><br></pre></td></tr></table></figure><p>还可以根据需要定制安全区（例如定制工具栏）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.additionalSafeAreaInsets</span><br></pre></td></tr></table></figure><p>安全区发生变化时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.viewSafeAreaInsetsDidChange()</span><br></pre></td></tr></table></figure><p><strong>布局边框</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.layoutMargins</span><br><span class="line">.directionalLayoutMargins</span><br><span class="line">.layoutMarginsGuide</span><br><span class="line">.layoutMarginsDidChange()</span><br></pre></td></tr></table></figure><p>与安全区配合使用</p><p>子视图传递</p><p>布局边框会根据设备宽度、动态字体而自动调整，能够自动适配。</p><h3 id="尺寸类"><a href="#尺寸类" class="headerlink" title="尺寸类"></a>尺寸类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeClasses</span><br></pre></td></tr></table></figure><ul><li>C 紧凑型（iPhone竖屏，iPad分屏）</li><li>R 常规型（iPad竖屏，12.9‘iPad等宽分屏）</li></ul><h3 id="动态字体"><a href="#动态字体" class="headerlink" title="动态字体"></a>动态字体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.large</span><br><span class="line">.title1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">label.font = UIFont.preferred...</span><br></pre></td></tr></table></figure><p><strong>自定义字体</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metrics = UIFontMetrics(...)</span><br></pre></td></tr></table></figure><blockquote><p>more at WWDC2017</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><div class="tag-plugin timeline"><div class="timenode" index="0"><div class="header"><p>2021年1月4日</p></div><div class="body fs14"><p>今天收到 Apple 的邮件，设计开发加速器活动现在已经开放申请啦，感兴趣的朋友们可以去 <a href="https://developer.apple.com/cn/accelerator/">官网</a> 申请。</p></div></div><div class="timenode" index="1"><div class="header"><p>2021年2月1日</p></div><div class="body fs14"><p>今天无意中发现又关闭申请入口了。</p></div></div><div class="timenode" index="2"><div class="header"><p>2021年4月9日</p></div><div class="body fs14"><p>今天经同事提醒发现又开放申请了。</p></div></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;受疫情影响，今年设计开发加速器活动改为线上形式，本次参与的活动课题是《为 iPhone 和 iPad 搭建灵活适配的用户界面》。</summary>
    
    
    
    <category term="技术加油站" scheme="https://xaoxuu.com/blog/categories/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="设计开发加速器" scheme="https://xaoxuu.com/blog/tags/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>心率管家的设计与开发（下篇：信号处理）</title>
    <link href="https://xaoxuu.com/blog/20200927/"/>
    <id>https://xaoxuu.com/blog/20200927/</id>
    <published>2020-09-27T00:00:00.000Z</published>
    <updated>2020-09-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名开发者，如何使用手机摄像头测量心率呢？在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。</p><span id="more"></span><div class="tag-plugin video-wrap"><div class="frame-wrap" id="iphone11"focus="top"><video poster="/assets/wiki/heartmate/docs/usage01.jpg" playsinline="" muted="" loop="" autoplay="" preload="metadata"><source src="/assets/wiki/heartmate/docs/usage01.mp4" type="video/mp4"></video><div class="frame"></div></div></div><h2 id="光电容积脉搏波描记法"><a href="#光电容积脉搏波描记法" class="headerlink" title="光电容积脉搏波描记法"></a>光电容积脉搏波描记法</h2><p>目前市面上大部分便携心率检测设备都是基于光电容积脉搏波描记法来测量的。由于心跳引起动脉周期性变化，动脉内血液的容积发生周期性变化，因而对光线的吸收也会呈现同样的周期性变化，这个周期性变化的频率就是脉率，脉率大部分情况都和心率一致。</p><p>打开相机，把手指指尖覆盖在摄像头上，观察屏幕上的取景框，就可以发现每心跳一次，屏幕中的红色都会变暗一次。对每一帧画面提取 RGB 均值，并转换到 HSV 色彩空间，把色相 H 作为特征值，得到时域信号。</p><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>我使用简单的时域分析法计算脉率，关键点就是计算采样时间内的波峰个数。把色相信号绘制波形图如下：</p><div class="tag-plugin image"><div class="image-bg" style="background:#fff;padding:8px;"><img src="/assets/xaoxuu/blog/2020-0927b@2x.jpg" style="width:300px;"/></div></div><p>由于覆盖力度不稳定导致色相会整体偏移因而产生低频噪声，再加原本就存在的高频噪声影响，波形显得很杂乱无章，所以使用带通递归滤波器进行滤波：</p><div class="tag-plugin image"><div class="image-bg" style="background:#fff;padding:16px;"><img src="/assets/xaoxuu/blog/2020-0927c@1x.svg"/></div></div><p>公式展开为：</p><div class="tag-plugin image"><div class="image-bg" style="background:#fff;padding:16px;"><img src="/assets/xaoxuu/blog/2020-0927d@1x.svg"/></div></div><p>用 Swift 语言实现这个滤波器的算法（10阶）为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">BandpassFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> x <span class="operator">=</span> [<span class="type">CGFloat</span>].<span class="keyword">init</span>(repeating: <span class="number">0</span>, count: <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> y <span class="operator">=</span> [<span class="type">CGFloat</span>].<span class="keyword">init</span>(repeating: <span class="number">0</span>, count: <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">@discardableResult</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">filted</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> x.count <span class="operator">&gt;</span> <span class="number">10</span>, y.count <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">10</span> &#123;</span><br><span class="line">            x[i] <span class="operator">=</span> x[i<span class="operator">+</span><span class="number">1</span>]</span><br><span class="line">            y[i] <span class="operator">=</span> y[i<span class="operator">+</span><span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        x[<span class="number">10</span>] <span class="operator">=</span> value <span class="operator">/</span> <span class="number">1.894427025e+01</span></span><br><span class="line">        y[<span class="number">10</span>] <span class="operator">=</span> x[<span class="number">10</span>] <span class="operator">-</span> x[<span class="number">0</span>] <span class="operator">+</span> <span class="number">5</span> <span class="operator">*</span> (x[<span class="number">2</span>] <span class="operator">-</span> x[<span class="number">8</span>]) <span class="operator">+</span> <span class="number">10</span> <span class="operator">*</span> (x[<span class="number">6</span>] <span class="operator">-</span> x[<span class="number">4</span>])</span><br><span class="line">        y[<span class="number">10</span>] <span class="operator">+=</span> (<span class="operator">-</span><span class="number">0.0000000000</span> <span class="operator">*</span> y[<span class="number">0</span>]) <span class="operator">+</span> (<span class="number">0.0357796363</span> <span class="operator">*</span> y[<span class="number">1</span>])</span><br><span class="line">        y[<span class="number">10</span>] <span class="operator">+=</span> (<span class="operator">-</span><span class="number">0.1476158522</span> <span class="operator">*</span> y[<span class="number">2</span>]) <span class="operator">+</span> (<span class="number">0.3992561394</span> <span class="operator">*</span> y[<span class="number">3</span>])</span><br><span class="line">        y[<span class="number">10</span>] <span class="operator">+=</span> (<span class="operator">-</span><span class="number">1.1743136181</span> <span class="operator">*</span> y[<span class="number">4</span>]) <span class="operator">+</span> (<span class="number">2.4692165842</span> <span class="operator">*</span> y[<span class="number">5</span>])</span><br><span class="line">        y[<span class="number">10</span>] <span class="operator">+=</span> (<span class="operator">-</span><span class="number">3.3820859632</span> <span class="operator">*</span> y[<span class="number">6</span>]) <span class="operator">+</span> (<span class="number">3.9628972812</span> <span class="operator">*</span> y[<span class="number">7</span>])</span><br><span class="line">        y[<span class="number">10</span>] <span class="operator">+=</span> (<span class="operator">-</span><span class="number">4.3832594900</span> <span class="operator">*</span> y[<span class="number">8</span>]) <span class="operator">+</span> (<span class="number">3.2101976096</span> <span class="operator">*</span> y[<span class="number">9</span>])</span><br><span class="line">        <span class="keyword">return</span> y[<span class="number">10</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个算法是从 <a href="https://github.com/WuXiaoTu/HeartRate">WuXiaoTu&#x2F;HeartRate</a> 这个开源库中翻译来的。</p></blockquote><p>经过滤波之后就能看到波形图呈现锯齿状，由于这是由摄像头捕捉到的色相的波形图，所以看起来并不会像心电图那样：</p><div class="tag-plugin image"><div class="image-bg" style="background:#fff;padding:8px;"><img src="/assets/xaoxuu/blog/2020-0927e@2x.jpg" style="width:300px;"/></div></div><p>有了干净的波形图，就可以数出一段时间内的波峰个数，从而计算出频率。例如数5秒内有多少个波峰，然后乘以12就是每分钟脉搏跳动次数，也就是这5秒内的平均脉率。现在 GitHub 上的很多同类的开源项目也都是这种方案。由于连续测量的时间越长，发生中断的可能性就越大，测量成功率就越低，再考虑到心率本身就是变化的，时间跨度太长也会使得数据变得没有意义，测量时间太短又很容易被个别误差数据影响。</p><p>网络上现有方案都是先确定测量时长，时间结束后计算结果：</p><ul><li>如果测量时间短：成功率高，准确性低。</li><li>如果测量时间中等：成功率低，准确性高。</li><li>如果测量时间长：成功率很低，准确性很高，但是数据意义不大。</li></ul><p>我想出了一种新的方案，就是每探测到一个有效脉冲，就记录下这个脉冲与上一个有效脉冲之间的间隔，两个连续的有效脉冲计算出来的频率就是100%正确的瞬时脉率。所以改进后的方案是：开始测量后，始终记录脉冲，随时可以计算瞬时脉率、最后若干秒的平均脉率。</p><ul><li>成功率：100%（不存在测量中断而失败的情况）</li><li>准确性的情况如下：<ul><li>如果脉冲计数都是由脉搏跳动引起的，测量结果就是完全准确的</li><li>如果脉搏跳动了而脉冲计数没有增加，不会影响结果，因为计算时只会把有效脉冲的周期进行累加</li><li>如果在脉搏跳动间隙额外增加了脉冲计数，那么数据就会失真</li></ul></li></ul><p>如果不故意快速抖动手指，数据失真的情况就不会发生，因为手指不离开摄像头并在两次脉搏跳动中间产生一次色相饱和度明度都以假乱真的脉冲信号是很难的。</p><h3 id="脉冲探测器"><a href="#脉冲探测器" class="headerlink" title="脉冲探测器"></a>脉冲探测器</h3><p>经过滤波后的数值是围绕0上下波动的，分别记录大于0的值和小于0的值，各自保存到数组中，然后求出它们的平均值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> filted <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    upVals.append(filted)</span><br><span class="line">    <span class="keyword">if</span> upVals.count <span class="operator">&gt;</span> <span class="number">20</span> &#123;</span><br><span class="line">        upVals.removeFirst(upVals.count <span class="operator">-</span> <span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> filted <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    downVals.append(filted)</span><br><span class="line">    <span class="keyword">if</span> downVals.count <span class="operator">&gt;</span> <span class="number">20</span> &#123;</span><br><span class="line">        downVals.removeFirst(downVals.count <span class="operator">-</span> <span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> avgUp <span class="operator">=</span> upVals.reduce(<span class="number">0</span>, <span class="operator">+</span>) <span class="operator">/</span> <span class="type">CGFloat</span>(upVals.count)</span><br><span class="line"><span class="keyword">let</span> avgDown <span class="operator">=</span> downVals.reduce(<span class="number">0</span>, <span class="operator">+</span>) <span class="operator">/</span> <span class="type">CGFloat</span>(downVals.count)</span><br></pre></td></tr></table></figure><p>如果新的值高于 <code>avgUp</code> 的一半，就标记 <code>flag = true</code> ，低于 <code>avgDown</code> 的一半且 <code>flag = true</code> 就标记 <code>flag = true</code>，触发一次脉冲，记录下这个脉冲的时间戳。如果两个脉冲之间的时间间隔符合正常心率的范围，就认为是有效脉冲。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> filted <span class="operator">&gt;</span> <span class="number">0.5</span> <span class="operator">*</span> avgUp  &#123;</span><br><span class="line">    flag <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> filted <span class="operator">&lt;</span> <span class="number">0.5</span> <span class="operator">*</span> avgDown <span class="operator">&amp;&amp;</span> flag <span class="operator">==</span> <span class="literal">true</span> &#123;</span><br><span class="line">    flag <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> time <span class="operator">=</span> <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">    <span class="keyword">let</span> period <span class="operator">=</span> time <span class="operator">-</span> periodStart</span><br><span class="line">    <span class="comment">// 与上一个周期间隔时间满足正常周期范围</span></span><br><span class="line">    <span class="keyword">if</span> period <span class="operator">&lt;</span> <span class="type">MAX_PERIOD</span> <span class="operator">&amp;&amp;</span> period <span class="operator">&gt;</span> <span class="type">MIN_PERIOD</span> &#123;</span><br><span class="line">        <span class="comment">// 记录这次脉冲与上次脉冲的时间间隔</span></span><br><span class="line">        periods.append(period)</span><br><span class="line">        <span class="comment">// 捕获到脉冲</span></span><br><span class="line">        delegate<span class="operator">?</span>.pulseDetector(detector: <span class="keyword">self</span>, capture: periods)</span><br><span class="line">    &#125;</span><br><span class="line">    periodStart <span class="operator">=</span> time</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> filted</span><br></pre></td></tr></table></figure><p>上文「正常心率的范围」如何界定？心率如果低到 40bpm 此时周期达到最大值，如果心率高达 255bpm 则周期达到最小值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">MAX_PERIOD</span> <span class="operator">=</span> <span class="type">CFTimeInterval</span>(<span class="number">60.0</span> <span class="operator">/</span> <span class="number">40</span>)</span><br><span class="line"><span class="type">MIN_PERIOD</span> <span class="operator">=</span> <span class="type">CFTimeInterval</span>(<span class="number">60.0</span> <span class="operator">/</span> <span class="number">255</span>)</span><br></pre></td></tr></table></figure><h3 id="计算脉率"><a href="#计算脉率" class="headerlink" title="计算脉率"></a>计算脉率</h3><p>上一步记录下了每个脉冲的周期，取出最后 N 个要计算的脉冲，把它们的周期相加就是总时长，用 <code>个数 / 时长</code> 计算的值就是频率，频率乘以 <code>60</code> 就是每分钟的脉冲数，也就是脉率。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">calcFrequency</span>(<span class="params">count</span>: <span class="type">Int</span>) -&gt; <span class="type">CGFloat</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> (<span class="number">0</span> <span class="operator">...</span> periods.count).contains(count) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> duration <span class="operator">=</span> periods.dropFirst(periods.count <span class="operator">-</span> count).reduce(<span class="number">0</span>, <span class="operator">+</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGFloat</span>(count) <span class="operator">/</span> <span class="type">CGFloat</span>(duration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag-plugin img-wrap"><div class="frame-wrap" id="iphone11"><img class="img" src="/assets/xaoxuu/blog/2020-0927f@2x.jpg"/><div class="frame"></div></div></div><h2 id="准确性与参考价值"><a href="#准确性与参考价值" class="headerlink" title="准确性与参考价值"></a>准确性与参考价值</h2><p>由于心率是动态变化的，即使测量的脉搏跳动都是准确的，也就是说测量阶段实现了零误差，但是计算方式不一样也会产生不同的结果。因此直接拿结果去和小米手环或者 Apple Watch 上显示的数值去进行对比是不严谨的。正确地方法是在一个时间段内用多种方式测量的同时亲自用手测量脉搏跳动次数，可以借助本文的 demo 计算瞬时或者平均脉率，如果一段时间的脉冲计数完全正确，那么 demo 计算的结果就是完全准确的，瞬时脉率、最后 N 秒的平均脉率一般都不会相同。因此即使戴在一只手上同一时间进行测量，不同产品显示的心率不同也并不能说明它们谁更准，只能说谁的结果更具有参考价值。</p><p>对此，我优化后的心率管家测量方案可以选择测量时长，也可以随时结束测量，运动后心率变化快的时候适合取短时间内例如5s平均脉率，心平气和的时候可以取适当长一点的例如10s或者20s的平均脉率。</p><h2 id="脉率和心率"><a href="#脉率和心率" class="headerlink" title="脉率和心率"></a>脉率和心率</h2><p>脉率是每分钟脉搏的次数，心率是每分钟心跳次数，健康情况下脉率与心率一致，但是如果出现心律失常，心脏有一些跳动不能有效将血液泵至全身，因此会出现脉搏缺失，导致脉率显著低于心率。如果用来判断心脏功能状态，误差很大。对于心动过速、低血压症和休克病人，即使是心率规则，由于脉压差很小，脉搏也会很弱，此时往往不能够准确测量脉率。</p><p>另外，脉搏随肢体移动会形成伪迹波动，也会影响脉率的测量。而心率不受心律失常、心动过速、休克、肢体活动的影响，所以在临床上，医生判断心跳活动不是看脉率，而是看心率，摸脉搏只是一个辅助操作。</p><p>因此，通过手环、手表、app 测量的“心率”并不是一个完全可靠的数据。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>非常感谢 <a href="https://lifestyle1.cn/">@JustinYang</a> 大佬在滤波算法方面给予的援助。也十分感谢 <a href="https://punmy.cn/">@Punmy</a>、<a href="https://github.com/WuXiaoTu">@WuXiaoTu</a> 等作者的文章，使得后人能够少走很多弯路。</p><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://xaoxuu.com/blog/20190723/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div><span class="cap link fs12">https://xaoxuu.com/blog/20190723/</span></div><div class="bottom"><span class="title">https://xaoxuu.com/blog/20190723/</span><span class="cap desc fs12"></span></div></a></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一名开发者，如何使用手机摄像头测量心率呢？在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。&lt;/p&gt;</summary>
    
    
    
    <category term="设计开发" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
    <category term="心率" scheme="https://xaoxuu.com/blog/tags/%E5%BF%83%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>静态博客使用 Issues API 来实现动态发布友链、书签</title>
    <link href="https://xaoxuu.com/blog/20200823/"/>
    <id>https://xaoxuu.com/blog/20200823/</id>
    <published>2020-08-23T00:00:00.000Z</published>
    <updated>2020-08-23T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于发布 issue 的成本远远低于发布一次博客更新（即便是使用了持续集成），可以用 issue 来简化每个独立博客都必备的友链系统，也可以通过 issue 来快速发布动态资讯，弥补静态博客必须更新静态文件才能更新内容的缺点。此功能已经集成到了主题中，使用非常方便。</p><span id="more"></span><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>如标题所说，例如 Issues API 来实现，把请求到的结果进行解析，然后生成 HTML 标签，添加到页面中。为了获取到需要的信息，创建 Issue 需要遵循一定的格式，例如「网站卡片」就需要截图、网站标题、网站链接、网站描述、头像。可以设置 <a href="https://github.com/volantis-x/examples/issues/new/choose">Issues 模版</a> 来简化步骤。</p><p>通过 issue 方式发布内容可以支持 <code>script</code> 脚本，为了安全起见，最好设置一个限制，例如用标签来激活 <code>labels=active</code> 或者只对自己发布的有效，可以在解析数据的时候过滤掉 <code>script</code> 标签。</p><h2 id="如何在主题中使用？"><a href="#如何在主题中使用？" class="headerlink" title="如何在主题中使用？"></a>如何在主题中使用？</h2><p>在 GitHub 或者 Gitee 创建仓库，仿照下面的示例，把 api 中的用户名和仓库名改成自己的。Issue 内容中需要有一段满足 JSON 格式的代码块：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;screenshot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;版本：^4.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>仓库链接：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/xaoxuu/friends/issues" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://github.com/xaoxuu/friends/issues</span><span class="cap link fs12">https://github.com/xaoxuu/friends/issues</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="在线演示效果"><a href="#在线演示效果" class="headerlink" title="在线演示效果"></a>在线演示效果</h2><p>见本站友链</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://xaoxuu.com/friends/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://xaoxuu.com/friends/</span><span class="cap link fs12">https://xaoxuu.com/friends/</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于发布 issue 的成本远远低于发布一次博客更新（即便是使用了持续集成），可以用 issue 来简化每个独立博客都必备的友链系统，也可以通过 issue 来快速发布动态资讯，弥补静态博客必须更新静态文件才能更新内容的缺点。此功能已经集成到了主题中，使用非常方便。&lt;/p&gt;</summary>
    
    
    
    <category term="设计开发" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="博客" scheme="https://xaoxuu.com/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="GitHub" scheme="https://xaoxuu.com/blog/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>个人电脑作为办公设备时，我们如何保护隐私？</title>
    <link href="https://xaoxuu.com/blog/20200627/"/>
    <id>https://xaoxuu.com/blog/20200627/</id>
    <published>2020-06-27T00:00:00.000Z</published>
    <updated>2020-06-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区加密。</p><span id="more"></span><h2 id="分区加密"><a href="#分区加密" class="headerlink" title="分区加密"></a>分区加密</h2><p>对 Mac 电脑进行磁盘分区和安装多系统非常简单，打开「磁盘工具」点击标题栏的「分区」按钮进行分区即可，分区的格式一定要选择加密的，这里推荐「APFS（加密）」格式。密码要记下来防止遗忘。这里选择加密分区主要可以防止意外挂载：在启动了工作区的系统之后，由于需要密码才能挂载生活区的数据宗卷，可以有效避免不小心点了挂载或者设置了自动挂载，导致拥有完整的磁盘访问权限的安防软件自动扫描了生活区的文件资料。同样的道理，工作分区加密也可以防止生活区的某些软件扫描到了工作资料导致数据泄露。</p><div class="tag-plugin image"><div class="image-bg"><img src="/assets/xaoxuu/blog/2020-0627d@2x.png"/></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/assets/xaoxuu/blog/2020-0627c@2x.png"/></div></div><p>分区完成之后，安装系统，目标宗卷选择刚刚新建的工作分区，剩下的系统安装步骤不需要赘述了。</p><h2 id="工作专用账号"><a href="#工作专用账号" class="headerlink" title="工作专用账号"></a>工作专用账号</h2><p>系统安装完成之后，最好登录工作专用的账号，不要使用同一个 AppleID 进行登录，否则仍然存在数据泄露的风险。同样的，浏览器账号也需要使用工作专用。AppleID 和浏览器账号基本上可以满足大部分需要记住账号密码的需求。</p><p>而对于工作日志，我推荐给程序员的做法是创建本地 git 仓库，用 <a href="https://typora.io/">Typora</a> 编辑器 markdown 格式书写。它的缺点十分有限，就是新增文件稍微麻烦一点，要在左侧目录树上点击右键，然后选择「新建文件」，然后输入文件名，除此之外几乎没有缺点。对于支持 md 的其它笔记软件来说，它对于 md 的支持比较完整，方便更换和修改主题，导出格式丰富并且样式也比较完整。</p><div class="tag-plugin image"><div class="image-bg"><img src="/assets/xaoxuu/blog/2020-0627e@2x.png" alt="Typora 操作界面"/></div><div class="image-meta"><span class="image-caption center">Typora 操作界面</span></div></div><h2 id="用户目录权限"><a href="#用户目录权限" class="headerlink" title="用户目录权限"></a>用户目录权限</h2><p>Mac 自带的一些用户文件目录例如「文稿」「桌面」等默认权限是 700 也就是仅当前用户可以读写和执行，但是自己新建的文件夹默认权限是 755 即全局用户都可以读取和执行。所以如果自己在原生的文件目录之外新建了文件夹，记得更改文件夹的权限：</p><div class="tag-plugin image"><div class="image-bg" style="background:#ECECEC;"><img src="/assets/xaoxuu/blog/2020-0627b@2x.jpg" alt="把权限由 755 修改为 700" style="width:500px;"/></div><div class="image-meta"><span class="image-caption center">把权限由 755 修改为 700</span></div></div><p>我切换了另一个用户进入这个用户目录时就提示无权限访问了，理论上这个用户上的应用程序也没有权限访问吧。（不太肯定）</p><div class="tag-plugin note" color="white"><div class="title"><strong>一个小坑</strong></div><div class="body"><p>经测试发现，在两个独立的宗卷中如果存在用户名和密码相同的两个用户，那么即使设置了 700 权限，但实际上在另一个宗卷中登录同名同密码的用户，对这个用户的文件夹一样拥有权限，不知道这是苹果有意为之还是设计漏洞。</p></div></div><h2 id="一个不便之处"><a href="#一个不便之处" class="headerlink" title="一个不便之处"></a>一个不便之处</h2><p>流程是进入系统后自动请求挂载另一个宗卷，由于开启了文件保险箱，所以弹出了密码输入框，不输入密码点击取消，则没有权限访问另一卷的磁盘内容。但是每次开机都会有这个弹窗，挺烦人的。</p><div class="tag-plugin image"><div class="image-bg"><img src="/assets/xaoxuu/blog/2020-0627f@2x.png" style="width:400px;"/></div></div><p>网上搜索了设置开机不自动挂载的方法，都是修改 <code>fstab</code> 文件的方法：</p><figure class="highlight md"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line">UUID=427478BB-E267-4455-869A-4AAB54F792A1 none auto noauto 0 0</span><br></pre></td></tr></table></figure><p>实测无效，每次登录用户还是会自动尝试挂载，可能这种方式在 APFS 分区中不再支持了。不知道在 2020 年，如何让 APFS 加密分区不自动挂载？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区加密。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://xaoxuu.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Mac" scheme="https://xaoxuu.com/blog/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>苹果设计开发加速器《创建卓越的 Apple Watch 体验》活动现场体验</title>
    <link href="https://xaoxuu.com/blog/20191006/"/>
    <id>https://xaoxuu.com/blog/20191006/</id>
    <published>2019-10-06T00:00:00.000Z</published>
    <updated>2019-10-06T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>9月26号收到了苹果的一活动邀请邮件《创建卓越的 Apple Watch 体验》，活动地点是：Design and Development Accelerator，这是苹果今年7月份在上海设立的设计开发加速器，为开发者提供有关应用设计与开发的专业培训和资源。</p><span id="more"></span><details class="tag-plugin folding" ><summary><span>什么是「设计开发加速器」？</span></summary><div class="body"><ul><li>苹果官网：<a href="https://developer.apple.com/cn/accelerator/">设计开发加速器</a></li><li>视频体验：<a href="https://www.bilibili.com/video/av58500736/?spm_id_from=333.788.videocard.7">搞机零距离：中国开发者的大好事？苹果工程师一对一授课，让人开了又开？</a></li><li>媒体资讯：<a href="https://sspai.com/post/55613">苹果设计开发加速器正式启动，每年计划为 5000 名国内开发者提供支持</a></li></ul><iframe src="//player.bilibili.com/player.html?aid=58500736&bvid=BV1Cx411Z71y&cid=102025595&page=1" allowfullscreen="allowfullscreen" width="100%" height="400" scrolling="no" frameborder="0" style="border-radius:8px"></iframe></div></details><h2 id="watchOS-6"><a href="#watchOS-6" class="headerlink" title="watchOS 6"></a>watchOS 6</h2><p>构建面向 watchOS 的 app，让用户随时随地及时掌握信息并轻松完成快速操作。开放了更多种全新的 API，可以构建完全独立的 watchOS app，甚至是不带有 iOS 版的 watchOS app。现在，用户可以直接在 Apple Watch 上的 App Store 中查找并安装 app。</p><h2 id="独立的-App"><a href="#独立的-App" class="headerlink" title="独立的 App"></a>独立的 App</h2><p>在 watchOS 6 中，可以构建完全独立的 Watch App。“Sign in with Apple” 让用户远离手机时也能在 Apple Watch 上登录 app。</p><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:16px;"><img src="/assets/xaoxuu/mirror/apple/documentation/watchkit/af79db6d-02b1-4df0-9f46-6c3c9db12d76.png" alt="选择应用模板" style="width:500px;"/></div><div class="image-meta"><span class="image-caption center">选择应用模板</span></div></div><ul><li><p><strong>Watch-only app</strong><br>创建只有 Apple Watch 且没有相关 iOS 应用程序。</p></li><li><p><strong>watchOS app with an iOS app</strong><br>当您拥有 iOS 应用并想要提供可提供相似或相关体验的 watchOS 应用。</p></li></ul><p>在创建 watchOS Target 时，指定要构建的 watchOS 项目的类型。此外，如果将 watchOS 应用程序与 iOS 应用程序捆绑在一起，则必须指定 watchOS 应用程序如何与其配套的 iOS 应用互动。</p><ul><li><strong>Independent Apps</strong> （独立应用）不需要 iOS 配套应用即可正常运行。用户可以选择安装 iOS 应用、watchOS 应用或同时安装两者。</li><li><strong>Dependent Apps</strong> （从属应用）依靠 iOS 配套应用才能正常运行；仅在 watchOS 应用需要与 iOS 应用互动时才创建从属应用。用户必须使用其 iOS 应用购买并安装从属的 watchOS 应用。</li></ul><blockquote><p>在 watchOS 5 和更低版本中，所有 watchOS 应用程序都是从属应用。</p></blockquote><h2 id="Apple-Watch-上的-App-Store"><a href="#Apple-Watch-上的-App-Store" class="headerlink" title="Apple Watch 上的 App Store"></a>Apple Watch 上的 App Store</h2><p>watchOS 6 上提供适用于 Apple Watch 的 App Store，让用户可以直接在 Apple Watch 上轻松探索、浏览、搜索和安装 watchOS app。使用 Siri、听写或涂写进行搜索，或者通过轻点产品页面链接，直接进入产品页面。</p><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:16px;"><img src="/assets/xaoxuu/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png" style="width:180px;"/></div></div><p>系统会为独立和从属应用直接将 watchOS 应用程序下载并安装到 Apple Watch。</p><h2 id="Apple-Watch-人机界面指南"><a href="#Apple-Watch-人机界面指南" class="headerlink" title="Apple Watch 人机界面指南"></a>Apple Watch 人机界面指南</h2><p>Apple Watch 设计为可穿戴，因此用户界面适合穿戴者使用，并为他们带来轻巧，反应灵敏且高度个性化的体验。人们经常使用 watchOS 应用程序的相关体验（例如复杂功能、通知和 Siri 交互），而不是使用应用程序本身。创造出色的 watchOS 体验意味着既要设计应用程序，又要设计快速，信息丰富的元素，使人们能够以适合自己的方式访问您的内容。最有用的应用通常：</p><ul><li>使用复杂功能可以在表盘上提供少量可能动态的信息，使人们可以一目了然地查看信息</li><li>使用通知传递及时的高价值信息并采取重要行动</li><li>帮助人们使用 Siri 获取信息并执行任务</li><li>如有必要，请在应用程序体验中提供更多详细信息和功能</li></ul><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:16px;"><img src="/assets/xaoxuu/mirror/apple/design/human-interface-guidelines/watchos/watchOS-hero.svg" style="width:320px;"/></div></div><br><div class="tag-plugin note" color="blue"><div class="title"><strong>图片来源声明</strong></div><div class="body"><p>本文挖了坑但是许久没有填上，直到 watchOS 7 都要发布了，最后决定放弃填坑，文章封面和文中的部分插图来源于苹果官方文档。</p></div></div><details class="tag-plugin folding" ><summary><span>附：议程安排</span></summary><div class="body"><div class="tag-plugin image"><div class="image-bg" style="background:#F3F2F7;padding:16px;"><img src="/assets/xaoxuu/blog/2019-1006fb@2x.jpg" style="width:400px;"/></div></div><p>苹果上海设计开发加速器地点在源深体育中心地铁站4出口处，三座非常低调没有任何招牌的建筑，绕着走了一圈才找到A座二楼入口的门。内部环境如媒体图片一样，室内禁止私自拍照，只有这张门票留作纪念喽。</p><div class="tag-plugin image"><div class="image-bg" style="background:#857E74;padding:16px;"><img src="/assets/xaoxuu/blog/2019-1006fc@2x.jpg" style="width:400px;"/></div></div></div></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;9月26号收到了苹果的一活动邀请邮件《创建卓越的 Apple Watch 体验》，活动地点是：Design and Development Accelerator，这是苹果今年7月份在上海设立的设计开发加速器，为开发者提供有关应用设计与开发的专业培训和资源。&lt;/p&gt;</summary>
    
    
    
    <category term="技术加油站" scheme="https://xaoxuu.com/blog/categories/%E6%8A%80%E6%9C%AF%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="设计开发加速器" scheme="https://xaoxuu.com/blog/tags/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用链式语法打造一个 ObjC 安全的对象类型转换库</title>
    <link href="https://xaoxuu.com/blog/20190829/"/>
    <id>https://xaoxuu.com/blog/20190829/</id>
    <published>2019-08-29T00:00:00.000Z</published>
    <updated>2019-08-29T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我就职过的公司，都出现过不止一次因为后台实际数据类型和文档不一致导致的程序线上崩溃问题。原则上即使服务器离线了，app 都不应该直接闪退，所以 app 应当具有对服务器异常情况进行处理的能力。使用 ValueX 可以有效避免后台返回数据类型异常导致的程序崩溃。</p><span id="more"></span><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/xaoxuu/ValueX/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://github.com/xaoxuu/ValueX/</span><span class="cap link fs12">https://github.com/xaoxuu/ValueX/</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h2><ul><li>场景1： NSString 类型变成 NSNull</li><li>场景2： nil 变成 <code>@&quot;&lt;null&gt;&quot;</code> 值</li><li>场景3： userId 不确定是 NSString 还是 NSNumber</li><li>场景4： NSDictionary 中嵌套的容器变成了 Json 字符串格式</li></ul><h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><ul><li>实际类型与定义类型不符</li><li>实际类型与期望类型不一致</li></ul><h2 id="设计接口"><a href="#设计接口" class="headerlink" title="设计接口"></a>设计接口</h2><p>假如我得到一个值 <code>NSString *obj</code>，实际上可能是 NSNull ，可能是 NSNumber ，可能是空数据的 <code>@&quot;&lt;null&gt;&quot;</code> 或者 <code>@&quot;(null)&quot;</code> 等各种表述。那么我需要确保 <code>NSSafeString(obj)</code> 的结果一定是 NSString 类型的值，如果是空数据，就应该是 nil。如果是 <code>@123</code> 这样的数字，那么应该得到 <code>@&quot;123&quot;</code> 这样的字符串。</p><p>如果是 json 数据，它可能以 NSData 类型存在，可能以 Json 字符串 NSString 类型存在，可能以 NSArray 或者 NSDictionary 对象形式存在。我需要的是我要什么类型就能直接获取。例如 <code>ValueX(obj).stringValue</code> 就得到这个数据的 Json 字符串，<code>ValueX(obj).dictionaryValue</code> 就得到这个数据的字典对象。</p><p>所以这个库就分为两部份工作，一部分是将实际类型与定义类型一致化；第二部分是将已知类型转换成它能够转换的其他类型。</p><h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><p>针对 ObjC 中常用的 6 种数据类型 NSString、NSNumber、NSData、NSArray、NSSet、NSDictionary 一一进行判断，写出6个函数：</p><figure class="highlight objc"><figcaption><span>得到安全类型：</span></figcaption><table><tr><td class="code"><pre><span class="line">FOUNDATION_EXTERN <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeString</span>(<span class="type">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSNumber</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeNumber</span>(<span class="type">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSData</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeData</span>(<span class="type">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSArray</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeArray</span>(<span class="type">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSSet</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeSet</span>(<span class="type">id</span> obj);</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSDictionary</span> * __<span class="keyword">nullable</span> <span class="built_in">NSSafeDictionary</span>(<span class="type">id</span> obj);</span><br></pre></td></tr></table></figure><p>确保从这些函数出来的值是与定义类型一致的值。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>即使拿到的值与定义类型一致，有时候我们要用的可能又是其他类型。</p><figure class="highlight objc"><figcaption><span>数据类型转换函数：</span></figcaption><table><tr><td class="code"><pre><span class="line">FOUNDATION_EXTERN VXObject *ValueX(<span class="type">id</span> &lt;VXConvertable&gt;obj);</span><br></pre></td></tr></table></figure><p>确保 VXObject 类型可以通过点语法直接得到原数据所能够转换的其他类型。VXObject 是一种中间类型，针对上述 6 种数据类型，每一种可以转换成其他哪些类型进行一一判断。</p><p>其中，NSNumber 只可以转换为 NSString、NSData，遵循 VXConvertable 协议。表示数字的 NSString，可以转换成 NSNumber，表示 Json 的字符串可以转换成对应的 NSArray 或者 NSDictionary，遵守 VXConvertableData 协议。反过来 NSArray、NSSet 或者 NSDictionary 则遵守 VXConvertableObject 协议。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableData</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNumber</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertable</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSData</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableData</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSSet</span> (<span class="title">VCObject</span>) &lt;<span class="title">VXConvertableObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span> (<span class="title">VXObject</span>) &lt;<span class="title">VXConvertableObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它们的协议内容是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">VXConvertable</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (VXObject *)vx;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">VXConvertableObject</span> &lt;<span class="title">VXConvertable</span>&gt;</span></span><br><span class="line">- (VXObject *)vxWithOptions:(<span class="built_in">NSJSONWritingOptions</span>)opt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">VXConvertableData</span> &lt;<span class="title">VXConvertable</span>&gt;</span></span><br><span class="line">- (VXObject *)vxWithOptions:(<span class="built_in">NSJSONReadingOptions</span>)opt;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>就按照这个思路进行开发，实现的代码就不再赘述了。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://xaoxuu.com/wiki/valuex/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://xaoxuu.com/wiki/valuex/</span><span class="cap link fs12">https://xaoxuu.com/wiki/valuex/</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;我就职过的公司，都出现过不止一次因为后台实际数据类型和文档不一致导致的程序线上崩溃问题。原则上即使服务器离线了，app 都不应该直接闪退，所以 app 应当具有对服务器异常情况进行处理的能力。使用 ValueX 可以有效避免后台返回数据类型异常导致的程序崩溃。&lt;/p&gt;</summary>
    
    
    
    <category term="设计开发" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="链式语法" scheme="https://xaoxuu.com/blog/tags/%E9%93%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/"/>
    
    <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    <category term="ObjC" scheme="https://xaoxuu.com/blog/tags/objc/"/>
    
    <category term="ValueX" scheme="https://xaoxuu.com/blog/tags/valuex/"/>
    
  </entry>
  
  <entry>
    <title>设计一个样式和逻辑分离的 HUD 库</title>
    <link href="https://xaoxuu.com/blog/20190827/"/>
    <id>https://xaoxuu.com/blog/20190827/</id>
    <published>2019-08-27T00:00:00.000Z</published>
    <updated>2019-08-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写「ProHUD」之前我已经在「AXKit」中实现了原生控件快速构造方法、为公司写了 ObjC 版的可定制化 HUD、Swift 版的开源的 NoticeBoard（通知横幅）。ProHUD 诞生的意义就在于取代这些不那么完善的 HUD。</p><span id="more"></span><p><strong>这是一个简单易用且完全可定制化的 HUD</strong></p><p>ProHUD &#x3D; Toast（通知横幅） + Alert（ProgressHUD、弹窗） + ActionSheet（操作表）</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>用相似的接口调用 <strong>Toast</strong>、<strong>Alert</strong>、<strong>Guard</strong> 组件。</li><li>程序初始化时配置自定义 UI 样式，快速调用。</li><li>用简便的方法拿到已发布的实例，避免重复发布实例。</li><li>可对已发布的实例进行数据更新。</li><li>横竖屏和 iPad 布局优化。</li><li>易于扩展，可以很方便的添加任意控件，并处理好布局。</li><li>可对所有实例监听消失事件。</li></ol><h3 id="Toast-顶部浮动通知条"><a href="#Toast-顶部浮动通知条" class="headerlink" title="Toast - 顶部浮动通知条"></a>Toast - 顶部浮动通知条</h3><ol><li>多个 Toast 并存策略（平铺）。</li><li>只接收一个点击事件。</li><li>可以预先对不同的场景配置不同的默认值（图标、持续时间）。</li></ol><h3 id="Alert-页面中心弹窗"><a href="#Alert-页面中心弹窗" class="headerlink" title="Alert - 页面中心弹窗"></a>Alert - 页面中心弹窗</h3><ol><li>多个 Alert 并存策略（具有景深效果的堆叠）。</li><li>可以预先对不同的场景配置不同的默认值（图标、持续时间）。</li><li>可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。</li><li>对已发布的实例进行文本和按钮的更新，包括新增、修改、删除文本和按钮。</li><li>强制退出按钮（防止超时导致页面卡死）。</li></ol><h3 id="Guard-页面底部操作表"><a href="#Guard-页面底部操作表" class="headerlink" title="Guard - 页面底部操作表"></a>Guard - 页面底部操作表</h3><ol><li>快速创建具有预先配置的默认样式的文本元素（标题、副标题、正文）。</li><li>可快速创建具有预先配置的默认样式（Default、Destructive、Cancel）的按钮。</li></ol><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="UI与逻辑分离"><a href="#UI与逻辑分离" class="headerlink" title="UI与逻辑分离"></a>UI与逻辑分离</h3><p>这个库采用配置 UI 和调用接口分离的设计，这种思路借鉴了和而泰公共库，我认为这是一种调用比传统 UI 库方便的同时可定制化能力也比传统 UI 库强大的设计思路。</p><p>简单来说，就是你在 AppDelegate 中告诉 ProHUD，你要的横幅、弹窗、操作表分别是什么样的，如果参数是什么什么，就怎么展示 UI。然后调用的地方就不需要设置 UI 了，只需要专注于数据。</p><figure class="highlight swift"><figcaption><span>例如弹出一个正在加载的提示框：</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">Alert</span>.push(scene: .loading, title: <span class="string">&quot;正在加载&quot;</span>, message: <span class="string">&quot;请稍等片刻&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样就发出了一个弹窗，而弹窗的样式，则在 AppDelegate 中以及预先配置好了。我使用了 <code>scene</code> 这个灵活的参数，你可以自己扩展场景。</p><figure class="highlight swift"><figcaption><span>为程序的弹窗场景设置模板，实现快速调用：</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ProHUD</span>.<span class="title class_">Scene</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> confirm: <span class="type">ProHUD</span>.<span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> scene <span class="operator">=</span> <span class="type">ProHUD</span>.<span class="type">Scene</span>(identifier: <span class="string">&quot;confirm&quot;</span>)</span><br><span class="line">        scene.image <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="string">&quot;ProHUDMessage&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> scene</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> delete: <span class="type">ProHUD</span>.<span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> scene <span class="operator">=</span> <span class="type">ProHUD</span>.<span class="type">Scene</span>(identifier: <span class="string">&quot;delete&quot;</span>)</span><br><span class="line">        scene.image <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="string">&quot;ProHUDTrash&quot;</span>)</span><br><span class="line">        scene.title <span class="operator">=</span> <span class="string">&quot;确认删除&quot;</span></span><br><span class="line">        scene.message <span class="operator">=</span> <span class="string">&quot;此操作不可撤销&quot;</span></span><br><span class="line">        <span class="keyword">return</span> scene</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> buy: <span class="type">ProHUD</span>.<span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> scene <span class="operator">=</span> <span class="type">ProHUD</span>.<span class="type">Scene</span>(identifier: <span class="string">&quot;buy&quot;</span>)</span><br><span class="line">        scene.image <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="string">&quot;ProHUDBuy&quot;</span>)</span><br><span class="line">        scene.title <span class="operator">=</span> <span class="string">&quot;确认付款&quot;</span></span><br><span class="line">        scene.message <span class="operator">=</span> <span class="string">&quot;一旦购买拒不退款&quot;</span></span><br><span class="line">        <span class="keyword">return</span> scene</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 scene 就可以理解成一套模板。</p><h3 id="动态更新"><a href="#动态更新" class="headerlink" title="动态更新"></a>动态更新</h3><p>ProHUD 另一个优势就是动态更新，对于已经发布的实例，你可以方便的去更新内容。</p><figure class="highlight swift"><figcaption><span>示例1：获取刚才弹出的Loading，把它更新为加载成功。</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">Alert</span>.find(<span class="string">&quot;loading&quot;</span>, last: &#123; (a) <span class="keyword">in</span></span><br><span class="line">    a.update &#123; (vm) <span class="keyword">in</span></span><br><span class="line">        vm.scene <span class="operator">=</span> .success</span><br><span class="line">        vm.title <span class="operator">=</span> <span class="string">&quot;同步成功&quot;</span></span><br><span class="line">        vm.message <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>示例2：获取刚才弹出的Loading，把它更新为加载失败，并增加重试按钮。</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">Alert</span>.find(<span class="string">&quot;loading&quot;</span>, last: &#123; (a) <span class="keyword">in</span></span><br><span class="line">    a.update &#123; (vm) <span class="keyword">in</span></span><br><span class="line">        vm.scene <span class="operator">=</span> .error</span><br><span class="line">        vm.title <span class="operator">=</span> <span class="string">&quot;同步失败&quot;</span></span><br><span class="line">        vm.message <span class="operator">=</span> <span class="string">&quot;请检查网络是否连接&quot;</span></span><br><span class="line">        vm.add(action: .default, title: <span class="string">&quot;重试&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        vm.add(action: .cancel, title: <span class="string">&quot;取消&quot;</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="极端场景"><a href="#极端场景" class="headerlink" title="极端场景"></a>极端场景</h3><p>很多库没有多实例管理，很容易出现简单粗暴的视图重叠现象，ProHUD 针对不同场景做了不同的优化，对于横幅来说，可以平铺显示，像系统的通知中心一样，你可以拖拽向上移除。对于弹窗来说，我给底层的弹窗做了景深效果处理，使得看起来不像是 BUG。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://xaoxuu.com/wiki/prohud/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://xaoxuu.com/wiki/prohud/</span><span class="cap link fs12">https://xaoxuu.com/wiki/prohud/</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在写「ProHUD」之前我已经在「AXKit」中实现了原生控件快速构造方法、为公司写了 ObjC 版的可定制化 HUD、Swift 版的开源的 NoticeBoard（通知横幅）。ProHUD 诞生的意义就在于取代这些不那么完善的 HUD。&lt;/p&gt;</summary>
    
    
    
    <category term="设计开发" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
    <category term="ProHUD" scheme="https://xaoxuu.com/blog/tags/prohud/"/>
    
  </entry>
  
  <entry>
    <title>心率管家的设计与开发（上篇：整体流程）</title>
    <link href="https://xaoxuu.com/blog/20190723/"/>
    <id>https://xaoxuu.com/blog/20190723/</id>
    <published>2019-07-23T00:00:00.000Z</published>
    <updated>2019-07-23T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期开发并上架了新版心率管家 App（仅 iOS 端），专业版不定期限免，欢迎下载体验。本文将从设计、开发、上架等每个步骤和细节进行分享，也包含部分模块源码。</p><span id="more"></span><div class="tag-plugin link dis-select"><a class="link-card plain" title="心率管家" href="https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="icon"><div class="left"><span class="title">心率管家</span><span class="cap link fs12">https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="立项"><a href="#立项" class="headerlink" title="立项"></a>立项</h2><h3 id="确定需求"><a href="#确定需求" class="headerlink" title="确定需求"></a>确定需求</h3><p>立项的初衷是满足随时测心率的需求（没有智能手环手表的人群），App 核心功能就是测量心率，围绕这个功能展开的是测量时更多细节的记录、对已有数据的筛选。再往深度挖掘的是数据分析、健康预测。</p><h3 id="市场考察"><a href="#市场考察" class="headerlink" title="市场考察"></a>市场考察</h3><p>虽然 AppStore 已有，但是无一例外都特别丑，要么收费要么有广告，所以不如自己做一个。</p><h3 id="测量原理"><a href="#测量原理" class="headerlink" title="测量原理"></a>测量原理</h3><p><strong>光电容积脉搏波描记法（PPG）</strong></p><p>是追踪可见光（通常为绿光）在人体组织中的反射。它具备一个可见光光源来照射皮肤，再使用光电传感器采集被皮肤反射回来的光线。PPG 有两种模式，透射式和反射式，像一般的手环手表这样，光源和传感器在同一侧的，就是反射式；而医院中常见的夹在指尖上的通常是透射式的，即光源和传感器在不同侧。 皮肤本身对光线的反射能力是相对稳定的，但是心脏泵血使得血管容积周期性地变化，导致反射光也呈现出周期性的波动值，特别是在指尖这种毛细血管非常丰富的部位，这种周期性的波动很容易被观察到。</p><p>Wikipedia: <a href="https://en.wikipedia.org/wiki/Photoplethysmogram">#Photoplethysmogram</a></p><p>对应到 App 上就是通过分析摄像头每一帧画面的色值，计算出颜色波动的频率，即为近似心率。</p><h3 id="定价策略"><a href="#定价策略" class="headerlink" title="定价策略"></a>定价策略</h3><ul><li>付费版：价格波动，通过降价和限免吸引爬虫收录。</li><li>免费版：限制了部分个性化功能，核心功能不受影响，没有任何广告。</li></ul><h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><p>语言：Swift5<br>设计模式：MVC<br>路由方案：JLRoutes<br>主题和UI管理：Inspire<br>缓存方案：SQLite<br>数据同步方案：暂定AppleHealth</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>初期使用 Sketch 制作效果图，在后期直接在项目中进行调整，没有再更新到 Sketch 中。下面这是最终发布到 AppStore 的应用截图：</p><div class="tag-plugin swiper-container" id="swiper-api" width="min"><div class="swiper-wrapper"><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot01.jpg"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot02.jpg"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot03.jpg"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot04.jpg"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot05.jpg"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot06.jpg"></div></div><div class="swiper-pagination"></div><div class="swiper-button-prev blur"></div><div class="swiper-button-next blur"></div></div><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="心率测量组件"><a href="#心率测量组件" class="headerlink" title="心率测量组件"></a>心率测量组件</h3><p>心率测量功能开发为一个私有库，具体实现稍后补充。。。</p><h3 id="可定制UI"><a href="#可定制UI" class="headerlink" title="可定制UI"></a>可定制UI</h3><p>使用 <a href="https://xaoxuu.com/wiki/inspire/">Inspire</a> 作为主题管理器，目前暂未支持主题切换，后续更新会加入。</p><h3 id="快捷指令"><a href="#快捷指令" class="headerlink" title="快捷指令"></a>快捷指令</h3><p>使用 JLRoutes 路由方案，目前支持 URLSchemes 启动并开始测量，可接受两个参数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接启动</span></span><br><span class="line">heartmatepro:<span class="comment">//record</span></span><br><span class="line"><span class="comment">// 自定义补光灯亮度（亮度值 l 为浮点数，取值范围是0~1）</span></span><br><span class="line">heartmatepro:<span class="comment">//record?l=0.3</span></span><br><span class="line"><span class="comment">// 自定义补光灯亮度和测量样本容器大小（样本容器大小 c 为正整数，取值范围是1~20）</span></span><br><span class="line">heartmatepro:<span class="comment">//record?l=0.1&amp;c=10</span></span><br></pre></td></tr></table></figure><p>免费版限制了自定义亮度，但是你依然可以通过这种方式来自定义。</p><h3 id="ProHUD"><a href="#ProHUD" class="headerlink" title="ProHUD"></a>ProHUD</h3><p>使用 <a href="https://xaoxuu.com/wiki/prohud/">ProHUD</a> 来负责弹窗和操作表，包括隐私政策页面。</p><div class="tag-plugin swiper-container" id="swiper-api" width="min"><div class="swiper-wrapper"><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot21.png"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot22.png"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot23.png"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot24.png"></div><div class="swiper-slide"><img no-lazy src="/assets/wiki/heartmate/screenshot25.png"></div></div><div class="swiper-pagination"></div><div class="swiper-button-prev blur"></div><div class="swiper-button-next blur"></div></div><h2 id="上架"><a href="#上架" class="headerlink" title="上架"></a>上架</h2><p>新建应用，填写名称、BundleId 等资料，然后在 App 页面填写描述、网址、隐私政策链接、上传截图、确定分级……</p><p>待应用通过 testflight 测试无误后，打包上传。然后过几分钟 appstoreconnect 页面就可以选中刚才上传的包了，然后提交审核，第二天就审核通过。（现在 AppStore 新应用审核也太快了）</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://appstoreconnect.apple.com" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://appstoreconnect.apple.com</span><span class="cap link fs12">https://appstoreconnect.apple.com</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="数据价值"><a href="#数据价值" class="headerlink" title="数据价值"></a>数据价值</h3><p>后续迭代中会在测量详情页面下方的留白处加上【标签】、【备注】、【数据分析】模块，前两者利于检索数据，数据分析目前没有能力独自完成，计划使用第三方服务。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p><strong>图标</strong><br>这是一次彻底重做，所以也可以算是初版。很多细节还比较粗糙，例如图标没有经过打磨，设置列表连图标都没有。</p><p><strong>占位图</strong><br>很多页面在没有数据的时候也没有占位的图片，这个也会慢慢完善。</p><p><strong>心率区间</strong><br>心率卡片的颜色、心率卡片右上角以及归档页面心率的底部的彩色长条代表的是当前所处的心率区间，App 中并没有说明，后续迭代中也会完善这里。并且心率区间的划分需要年龄和性别，这个也会在后期进行完善。</p><h2 id="下篇：信号处理"><a href="#下篇：信号处理" class="headerlink" title="下篇：信号处理"></a>下篇：信号处理</h2><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://xaoxuu.com/blog/20200927/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://xaoxuu.com/blog/20200927/</span><span class="cap link fs12">https://xaoxuu.com/blog/20200927/</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期开发并上架了新版心率管家 App（仅 iOS 端），专业版不定期限免，欢迎下载体验。本文将从设计、开发、上架等每个步骤和细节进行分享，也包含部分模块源码。&lt;/p&gt;</summary>
    
    
    
    <category term="设计开发" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
    <category term="心率" scheme="https://xaoxuu.com/blog/tags/%E5%BF%83%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>整理 iOS 老项目中混乱不堪的多语言翻译</title>
    <link href="https://xaoxuu.com/blog/20171225/"/>
    <id>https://xaoxuu.com/blog/20171225/</id>
    <published>2017-12-25T00:00:00.000Z</published>
    <updated>2017-12-25T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>linksmart 项目截止目前已经支持了 17 个国家的语言，从诞生到现在也已经经历了很多程序员的修改和维护，代码已经变得十分混乱。因为公司一直在接新的定制项目，所以也没有时间进行一次彻底的重构，只能在维护某方面的 BUG 的时候，对相关代码进行局部重构。</p><span id="more"></span><p>现在的情况是：</p><ul><li>同一个文本有些语言有翻译，有些语言没有翻译。</li><li>有些需要使用缩进的地方，由于某种原因，并没有使用 <code>UIEdgeInsets</code> 进行缩进，而是在文本前后加空格。(⊙﹏⊙)b</li></ul><h2 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h2><p>首先必须得找出一种合适的方法维护这些 Localizable.strings，在 Excel 里做一个总表，增加语言的时候，可以直接把英文的一列发给客户进行翻译。最大的优势是：随时可以用脚本把 Excel 里的所有语言导出成项目支持的 Localizable.strings 文件，极大提高效率。</p><h2 id="1-补全"><a href="#1-补全" class="headerlink" title="1. 补全"></a>1. 补全</h2><p>使用 <code>genstrings</code> 命令将所有 <code>.m</code> 文件中的 LocalizedString 文本生成 Localizable.strings。<br>打开终端，进入需要检测的文件夹，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.m&quot; -print0 | xargs -0 genstrings -o ./</span><br></pre></td></tr></table></figure><p>生成的这一份文件只包含所有 <code>.m</code> 文件中的国际化字符串，并不包含 plist 和 xib 中的字符串。接下来只要把这一份和原来的所有翻译合并起来去重，就得到一份最全的 key。</p><p>如果也需要检测 xib、.h 文件，则执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;*.xib&#x27; -o -name &#x27;*.[mh]&#x27; -print0 | xargs -0 genstrings -o ./</span><br></pre></td></tr></table></figure><p>生成的文件会存在当前目录。</p><h2 id="2-合并去重"><a href="#2-合并去重" class="headerlink" title="2. 合并去重"></a>2. 合并去重</h2><p>我尝试过直接读取 Localizable.strings 文件，但提示编码错误，就暂时 copy 到 txt 文件中进行处理。</p><blockquote><p>合并的Demo：<a href="https://github.com/xaoxuu/LocalizedTool-iOS">https://github.com/xaoxuu/LocalizedTool-iOS</a></p></blockquote><h2 id="3-导入Excel"><a href="#3-导入Excel" class="headerlink" title="3. 导入Excel"></a>3. 导入Excel</h2><p>接下来的步骤工作量有点大，就是重新把那些翻译导入 Excel 中，补全缺少的那些翻译。</p><h3 id="1-下载，解压"><a href="#1-下载，解压" class="headerlink" title="1. 下载，解压"></a>1. 下载，解压</h3><p>下载工具：<a href="https://github.com/CatchZeng/Localizable.strings2Excel">https://github.com/CatchZeng/Localizable.strings2Excel</a> 。</p><p>解压开之后把里面的两个zip也解压开</p><h3 id="2-安装工具"><a href="#2-安装工具" class="headerlink" title="2. 安装工具"></a>2. 安装工具</h3><h4 id="pyexcelerator"><a href="#pyexcelerator" class="headerlink" title="pyexcelerator"></a>pyexcelerator</h4><p>打开命令行工具，cd到 <code>.../Localizable.strings2Excel-master/pyexcelerator-0.6.4.1</code> 文件夹，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h4 id="xld"><a href="#xld" class="headerlink" title="xld"></a>xld</h4><p>cd到 <code>.../Localizable.strings2Excel-master/xlrd-1.0.0</code> 文件夹，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h3 id="3-使用脚本"><a href="#3-使用脚本" class="headerlink" title="3. 使用脚本"></a>3. 使用脚本</h3><p>cd到 <code>.../Localizable.strings2Excel-master/python</code> 文件夹</p><p>如需将Excel表格转换成Localizable.strings或者strings.xml文件，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python LocalizableBack.py -f xxx/xxx.xls -t xxx/xxx</span><br></pre></td></tr></table></figure><p>如需将Localizable.strings或者strings.xml文件转换成Excel表格，执行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python Localizable.py -f xxx/ -t xxx/</span><br></pre></td></tr></table></figure><blockquote><p>工具的链接在：<a href="https://github.com/CatchZeng/Localizable.strings2Excel">GitHub&#x2F;CatchZeng</a> 感谢作者编写了如此方便的工具！<br>更多详细使用脚本请阅读 <a href="https://github.com/CatchZeng/Localizable.strings2Excel">官方README文件</a> 。</p></blockquote><h2 id="附：检测中文字符串"><a href="#附：检测中文字符串" class="headerlink" title="附：检测中文字符串"></a>附：检测中文字符串</h2><p>如果项目的默认语言是中文，而且前期没有用多语言写法，可以使用 Xcode 的替换功能，将中文字符串替换成多语言的写法：</p><p>搜索：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(@&quot;[^&quot;]*[\u4E00-\u9FA5]+[^&quot;\n]*?&quot;)</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLocalizedStringFromTable($0, @&quot;Localizable&quot;, nil)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;linksmart 项目截止目前已经支持了 17 个国家的语言，从诞生到现在也已经经历了很多程序员的修改和维护，代码已经变得十分混乱。因为公司一直在接新的定制项目，所以也没有时间进行一次彻底的重构，只能在维护某方面的 BUG 的时候，对相关代码进行局部重构。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://xaoxuu.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="Code" scheme="https://xaoxuu.com/blog/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 开发中，如何实现只推迟而不会重复执行的函数</title>
    <link href="https://xaoxuu.com/blog/20171109/"/>
    <id>https://xaoxuu.com/blog/20171109/</id>
    <published>2017-11-09T00:00:00.000Z</published>
    <updated>2017-11-10T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 iOS 开发中，如果想推迟执行一段代码，使用 <code>dispatch_after</code> 函数可以轻易实现，但有时候我们想在它推迟的期间再次推迟，直到最终不再推迟的时候，才真正的被调用一次。这就需要每次先将旧的事件取消，然后重新设置。</p><span id="more"></span><p><strong>自动消失的视图</strong></p><p>例如当用户的某种操作点击一下屏幕就发出一条状态栏消息，消息在2秒后消失，在消失前如果用户又触发了这个条件，理应是在这次触发的2秒后消失，如果简单的使用 <code>dispatch_after</code> 函数进行延迟，结果会是在第一次点击的2秒后消失，可能你在1.5秒的时候又点击了一下，但是只过了0.5秒就消失了。</p><p><strong>降低服务器访问次数</strong></p><p>例如：用户修改了信息的30秒后上传至服务器。那么如果用户修改了姓名，然后30秒内又修改了头像，在修改了头像后的30秒内又修改了性别等等。我们希望的并不是每次修改就上传一次，而是在用户最后修改完所有信息之后，看起来似乎不准备继续修改了的时候，再上传至服务器。使用推迟而不重复执行的方法可以在避免多次访问服务器的同时及时地上传用户修改后的信息。</p><h2 id="便捷的方案：GCD"><a href="#便捷的方案：GCD" class="headerlink" title="便捷的方案：GCD"></a>便捷的方案：GCD</h2><p>实现的方法很简单，步骤如下：</p><ol><li>获取到函数</li><li>取消函数</li><li>重新赋值或启动</li></ol><h3 id="使用-Objective-C"><a href="#使用-Objective-C" class="headerlink" title="使用 Objective-C"></a>使用 Objective-C</h3><p>在 Objective-C 中，将要执行的代码保存成 <code>dispatch_block_t</code> 的静态类型变量，取出这个静态变量，然后使用 <code>dispatch_block_cancel()</code> 取消，然后重新设置它的值，然后调用 <code>dispatch_after</code>。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)delayTest&#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_block_t task;</span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">        dispatch_block_cancel(task);</span><br><span class="line">    &#125;</span><br><span class="line">    task = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line">        <span class="comment">// 被推迟执行的代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="tag-plugin note" ><div class="title"><strong>也可以使用 AXKit 实现</strong></div><div class="body"><p>也可以使用 <a href="https://github.com/xaoxuu/AXKit/">AXKit</a> 封装好的方法，将要执行的代码保存成 <code>ax_dispatch_operation_t</code> 的静态类型变量，使用 <code>ax_dispatch_cancel_operation()</code> 取消之前的任务，然后使用 <code>ax_dispatch_cancellable()</code> 再次赋值。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)delayTest2&#123;</span><br><span class="line">    <span class="keyword">static</span> ax_dispatch_operation_t animationToken;</span><br><span class="line">    ax_dispatch_cancel_operation(animationToken);</span><br><span class="line">    animationToken = ax_dispatch_cancellable(duration, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 被推迟执行的代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="使用-Swift"><a href="#使用-Swift" class="headerlink" title="使用 Swift"></a>使用 Swift</h3><p>创建静态变量 <code>static var task = DispatchWorkItem.init&#123;&#125;</code>，先取消 <code>task.cancel()</code>，再赋值 <code>DispatchWorkItem</code>，然后使用 <code>DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task)</code> 延迟调用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> task <span class="operator">=</span> <span class="type">DispatchWorkItem</span>.<span class="keyword">init</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">hide</span>(<span class="params">duration</span>: <span class="type">TimeInterval</span>) &#123;</span><br><span class="line">    task.cancel()</span><br><span class="line">    task <span class="operator">=</span> <span class="type">DispatchWorkItem</span>.<span class="keyword">init</span>(block: &#123;</span><br><span class="line">        <span class="comment">// 被推迟执行的代码</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> duration, execute: task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更高效的方案：定时器"><a href="#更高效的方案：定时器" class="headerlink" title="更高效的方案：定时器"></a>更高效的方案：定时器</h2><p>上述方案存在一定的性能问题，在低频触发时没有问题，但是在每一秒都要触发一次或多次的时候，显然不合适。这时候可以设置一个定时器，通过定时器延迟调用，每次触发的时候只是修改定时器的 fireDate 属性，实现步骤不再赘述。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 iOS 开发中，如果想推迟执行一段代码，使用 &lt;code&gt;dispatch_after&lt;/code&gt; 函数可以轻易实现，但有时候我们想在它推迟的期间再次推迟，直到最终不再推迟的时候，才真正的被调用一次。这就需要每次先将旧的事件取消，然后重新设置。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://xaoxuu.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="GCD" scheme="https://xaoxuu.com/blog/tags/gcd/"/>
    
    <category term="ObjC" scheme="https://xaoxuu.com/blog/tags/objc/"/>
    
    <category term="Swift" scheme="https://xaoxuu.com/blog/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 接入 Strava 分享模块（下篇：StravaSDK）</title>
    <link href="https://xaoxuu.com/blog/20170628/"/>
    <id>https://xaoxuu.com/blog/20170628/</id>
    <published>2017-06-28T00:00:00.000Z</published>
    <updated>2017-06-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/StravaKit/StravaKit">StravaKit</a> 是一个比较新而且代码比较规范的第三方SDK，但是目前还没有上传功能（详见 <a href="https://github.com/StravaKit/StravaKit/blob/master/TODO.md">todo</a>）。所以我不得已对 <code>StravaKit 0.9.5</code> 增加上传功能，并进行一些简单封装和改编，使之能够植入到公司项目中。由于时间有限，我只增加了上传fit文件的功能，并且使用了第三方框架 <code>Alamofire</code>，所以需要在项目中导入 <code>Alamofire</code>。</p><span id="more"></span><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>StravaSDK 下载：<a href="https://github.com/xaoxuu/StravaSDK">StravaSDK.zip</a></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>需要三个参数：<code>ClientId</code>、<code>ClientSecret</code> 和app的 <code>URLSchemes</code>。其中前两个是在 <a href="https://labs.strava.com/developers/">Strava平台</a> 注册一个app的时候会给出。<br>示例代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.config(clientId: <span class="string">&quot;18583&quot;</span>, clientSecret: <span class="string">&quot;a05fde98a830effde2e0f84cc39d76b040d4d67e&quot;</span>, appSchemes: <span class="string">&quot;hitfit&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>获取授权</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.authorize()</span><br></pre></td></tr></table></figure><p>取消授权</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.deauthorize()</span><br></pre></td></tr></table></figure><p>查询是否已授权</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.isAuthorized</span><br></pre></td></tr></table></figure><h2 id="上传活动数据（-fit）"><a href="#上传活动数据（-fit）" class="headerlink" title="上传活动数据（.fit）"></a>上传活动数据（.fit）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">StravaSDK</span>.uploadActivity(path: <span class="string">&quot;.../test.fit&quot;</span>, type: <span class="string">&quot;run&quot;</span>, name: <span class="string">&quot;Afternoon Run&quot;</span>) &#123; (response, error) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/StravaKit/StravaKit&quot;&gt;StravaKit&lt;/a&gt; 是一个比较新而且代码比较规范的第三方SDK，但是目前还没有上传功能（详见 &lt;a href=&quot;https://github.com/StravaKit/StravaKit/blob/master/TODO.md&quot;&gt;todo&lt;/a&gt;）。所以我不得已对 &lt;code&gt;StravaKit 0.9.5&lt;/code&gt; 增加上传功能，并进行一些简单封装和改编，使之能够植入到公司项目中。由于时间有限，我只增加了上传fit文件的功能，并且使用了第三方框架 &lt;code&gt;Alamofire&lt;/code&gt;，所以需要在项目中导入 &lt;code&gt;Alamofire&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://xaoxuu.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="StravaSDK" scheme="https://xaoxuu.com/blog/tags/stravasdk/"/>
    
  </entry>
  
  <entry>
    <title>iOS 接入 Strava 分享模块（上篇：FitSDK）</title>
    <link href="https://xaoxuu.com/blog/20170622/"/>
    <id>https://xaoxuu.com/blog/20170622/</id>
    <published>2017-06-22T00:00:00.000Z</published>
    <updated>2017-06-22T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.garmin.com/fit/?resources/fit/">fit</a> 是一种文件协议，体积小巧，多用于可穿戴设备记录、传输运动与健康数据。官方提供了 C、C++、Java 语言的 SDK 和非常详细的使用文档。因此在 iOS 端接入 fit 就需要在 C 或 C++ 的 SDK 基础上进行一点面向对象的封装。</p><span id="more"></span><h2 id="认识-Fit"><a href="#认识-Fit" class="headerlink" title="认识 Fit"></a>认识 Fit</h2><p>我使用的 C 语言的 SDK，官方有示例 demo，在 <code>fit_mgr</code> 文件中提供了一些示例，这些代码未必全部都要用到。创建一个最简单的 <code>.fit</code> 文件的流程是：</p><h3 id="写-fileid"><a href="#写-fileid" class="headerlink" title="写 fileid"></a>写 fileid</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fit_transaction_file</span><span class="params">(FIT_FILE type, FIT_MANUFACTURER manufacturer, FIT_UINT16 product, FIT_UINT32Z serial_number)</span>&#123;</span><br><span class="line">    <span class="comment">// Write file id message.</span></span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">0</span>;</span><br><span class="line">    FIT_FILE_ID_MESG file_id;</span><br><span class="line">    Fit_InitMesg(fit_mesg_defs[FIT_MESG_FILE_ID], &amp;file_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @xaoxuu: type FIT_FILE_ACTIVITY = 4 活动数据</span></span><br><span class="line">    file_id.type = type;</span><br><span class="line">    <span class="comment">// @xaoxuu: 厂商</span></span><br><span class="line">    file_id.manufacturer = manufacturer;</span><br><span class="line">    <span class="comment">// @xaoxuu: 产品</span></span><br><span class="line">    <span class="comment">//        file_id.product_name</span></span><br><span class="line">    file_id.product = product;</span><br><span class="line">    <span class="comment">// @xaoxuu: 序列号</span></span><br><span class="line">    file_id.serial_number = serial_number;</span><br><span class="line">    <span class="comment">// @xaoxuu: 生产日期</span></span><br><span class="line">    <span class="comment">//        time_t now;</span></span><br><span class="line">    <span class="comment">//        time(&amp;now);</span></span><br><span class="line">    <span class="comment">//        file_id.time_created = now;</span></span><br><span class="line"></span><br><span class="line">    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FILE_ID], FIT_FILE_ID_MESG_DEF_SIZE, static_fp);</span><br><span class="line">    WriteMessage(local_mesg_number, &amp;file_id, FIT_FILE_ID_MESG_SIZE, static_fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fit_transaction_field_desc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Write a Field Description</span></span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">1</span>;</span><br><span class="line">    FIT_FIELD_DESCRIPTION_MESG field_description_mesg;</span><br><span class="line"></span><br><span class="line">    Fit_InitMesg(fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], &amp;field_description_mesg);</span><br><span class="line">    field_description_mesg.developer_data_index = <span class="number">0</span>;</span><br><span class="line">    field_description_mesg.field_definition_number = <span class="number">0</span>;</span><br><span class="line">    field_description_mesg.fit_base_type_id = FIT_BASE_TYPE_UINT16;</span><br><span class="line">    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], FIT_FIELD_DESCRIPTION_MESG_DEF_SIZE, static_fp);</span><br><span class="line">    WriteMessage(local_mesg_number, &amp;field_description_mesg, FIT_FIELD_DESCRIPTION_MESG_SIZE, static_fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写-record"><a href="#写-record" class="headerlink" title="写 record"></a>写 record</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入Record Defenition</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fit_transaction_record_def</span><span class="params">()</span>&#123;</span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">2</span>;</span><br><span class="line">    WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_RECORD], FIT_RECORD_MESG_DEF_SIZE, static_fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环写入record数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fit_transaction_record_msg</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> timestamp, <span class="type">int</span> position_lat, <span class="type">int</span> position_long, <span class="type">unsigned</span> <span class="type">int</span> distance, <span class="type">unsigned</span> <span class="type">short</span> altitude, <span class="type">unsigned</span> <span class="type">short</span> speed, <span class="type">unsigned</span> <span class="type">char</span> heart_rate)</span>&#123;</span><br><span class="line">    <span class="comment">//Record message</span></span><br><span class="line">    FIT_UINT8 local_mesg_number = <span class="number">2</span>;</span><br><span class="line">    FIT_RECORD_MESG record;</span><br><span class="line"></span><br><span class="line">    Fit_InitMesg(fit_mesg_defs[FIT_MESG_RECORD], &amp;record);</span><br><span class="line">    record.timestamp = timestamp;</span><br><span class="line">    record.position_lat = position_lat;</span><br><span class="line">    record.position_long = position_long;</span><br><span class="line">    record.distance = distance;</span><br><span class="line">    record.altitude = altitude;</span><br><span class="line">    record.speed = speed;</span><br><span class="line">    record.heart_rate = heart_rate;</span><br><span class="line">    WriteMessage(local_mesg_number,&amp;record,FIT_RECORD_MESG_SIZE,static_fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始封装"><a href="#开始封装" class="headerlink" title="开始封装"></a>开始封装</h2><h3 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h3><p>FitActivity.h</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitAcitvity.h</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">FitActivityRecord</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, FitActivityType) &#123;</span><br><span class="line">    FitActivityTypeWalk = <span class="number">11</span>, <span class="comment">// 枚举值等于FIT_SPORT值</span></span><br><span class="line">    FitActivityTypeRun = <span class="number">1</span>,</span><br><span class="line">    FitActivityTypeRide = <span class="number">2</span>,</span><br><span class="line">    FitActivityTypeSwim = <span class="number">5</span>,</span><br><span class="line">    FitActivityTypeHike = <span class="number">17</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FitActivity</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: fit 文件路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: 活动名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: 活动类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) FitActivityType type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: 活动类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *typeString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: records</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>&lt;FitActivityRecord *&gt; *records;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一条record</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param record record</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)addRecord:(<span class="type">void</span> (^)(FitActivityRecord *aRecord))record;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FitActivityRecord</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: position_lat</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">int</span> position_lat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: position_long</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">int</span> position_long;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: distance</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> distance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: altitude</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">short</span> altitude;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: speed</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">short</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @xaoxuu: heart_rate</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">char</span> heart_rate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>FitActivity.m</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitAcitvity.m</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;FitAcitvity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FitActivity</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _records = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">self</span>.type = FitActivityTypeWalk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setType:(FitActivityType)type&#123;</span><br><span class="line">    _type = type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeWalk:</span><br><span class="line">            _typeString = <span class="string">@&quot;walk&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeRun:</span><br><span class="line">            _typeString = <span class="string">@&quot;run&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeRide:</span><br><span class="line">            _typeString = <span class="string">@&quot;ride&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeSwim:</span><br><span class="line">            _typeString = <span class="string">@&quot;swim&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FitActivityTypeHike:</span><br><span class="line">            _typeString = <span class="string">@&quot;hike&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">    _path = [<span class="keyword">self</span> pathWithName:name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addRecord:(<span class="type">void</span> (^)(FitActivityRecord *aRecord))record&#123;</span><br><span class="line">    <span class="keyword">if</span> (record) &#123;</span><br><span class="line">        FitActivityRecord *rec = [FitActivityRecord new];</span><br><span class="line">        record(rec);</span><br><span class="line">        [<span class="keyword">self</span>.records addObject:rec];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)pathWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [[<span class="built_in">NSTemporaryDirectory</span>() stringByAppendingPathComponent:<span class="string">@&quot;com.xaoxuu.fitsdk&quot;</span>] stringByAppendingPathComponent:name];</span><br><span class="line">    path = [path stringByAppendingPathExtension:<span class="string">@&quot;fit&quot;</span>];</span><br><span class="line">    <span class="comment">// create dir if not exist</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *dir = path.stringByDeletingLastPathComponent;</span><br><span class="line">    <span class="type">BOOL</span> result = [fm createDirectoryAtPath:dir withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;can not create the directory at path %@&quot;</span>,dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FitActivityRecord</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _timestamp = <span class="number">702940946</span>;</span><br><span class="line">        _position_lat = <span class="number">0</span>;</span><br><span class="line">        _position_long = <span class="number">0</span>;</span><br><span class="line">        _distance = <span class="number">0</span>;</span><br><span class="line">        _altitude = <span class="number">0</span>;</span><br><span class="line">        _speed = <span class="number">0</span>;</span><br><span class="line">        _heart_rate = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="封装接口"><a href="#封装接口" class="headerlink" title="封装接口"></a>封装接口</h3><p>FitSDK.h</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitSDK.h</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;FitAcitvity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FitSDK</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 创建一个活动数据fit文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param activity 活动数据</span></span><br><span class="line"><span class="comment"> @return 活动数据模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (FitActivity *)createActivity:(<span class="type">void</span> (^)(FitActivity *activity))activity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>FitSDK.m</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  FitSDK.m</span></span><br><span class="line"><span class="comment">//  FitSDK</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xaoxuu on 04/07/2017.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 xaoxuu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;FitSDK.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;fit_mgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FitSDK</span></span></span><br><span class="line"></span><br><span class="line">+ (FitActivity *)createActivity:(<span class="type">void</span> (^)(FitActivity *activity))activity&#123;</span><br><span class="line">    FitActivity *act = [FitActivity new];</span><br><span class="line">    <span class="keyword">if</span> (activity) &#123;</span><br><span class="line">        activity(act);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> createActivityWithModel:act];</span><br><span class="line">    <span class="keyword">return</span> act;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)createActivityWithModel:(FitActivity *)activity&#123;</span><br><span class="line">    <span class="comment">// @xaoxuu: fit file</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *fp = [activity.path cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    fit_transaction(fp, activity.type, ^&#123;</span><br><span class="line">        [activity.records enumerateObjectsUsingBlock:^(FitActivityRecord * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            fit_transaction_record_msg(obj.timestamp, obj.position_lat, obj.position_long, obj.distance, obj.altitude, obj.speed, obj.heart_rate);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">FitActivity *activity = [FitSDK createActivity:^(FitActivity *activity) &#123;</span><br><span class="line">    activity.name = <span class="string">@&quot;test&quot;</span>;</span><br><span class="line">    activity.type = FitActivityTypeRun;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        [activity addRecord:^(FitActivityRecord *aRecord) &#123;</span><br><span class="line">            aRecord.timestamp = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - <span class="number">631065600</span>;</span><br><span class="line">            aRecord.position_lat = <span class="number">495280430</span>+i*<span class="number">1000</span>;</span><br><span class="line">            aRecord.position_long = <span class="number">-872696681</span>-i*<span class="number">1500</span>;</span><br><span class="line">            aRecord.distance = <span class="number">2</span>+i/<span class="number">100</span>;</span><br><span class="line">            aRecord.altitude = <span class="number">287.2</span>+i;</span><br><span class="line">            aRecord.speed = <span class="number">0.29</span>+i/<span class="number">50</span>;</span><br><span class="line">            aRecord.heart_rate = <span class="number">68</span>+i/<span class="number">4</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// activity.path就是生成的fit文件路径</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, activity.path);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.garmin.com/fit/?resources/fit/&quot;&gt;fit&lt;/a&gt; 是一种文件协议，体积小巧，多用于可穿戴设备记录、传输运动与健康数据。官方提供了 C、C++、Java 语言的 SDK 和非常详细的使用文档。因此在 iOS 端接入 fit 就需要在 C 或 C++ 的 SDK 基础上进行一点面向对象的封装。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://xaoxuu.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="FitSDK" scheme="https://xaoxuu.com/blog/tags/fitsdk/"/>
    
  </entry>
  
  <entry>
    <title>如何封装自己的 iOS Framework 静态库</title>
    <link href="https://xaoxuu.com/blog/20161106/"/>
    <id>https://xaoxuu.com/blog/20161106/</id>
    <published>2016-11-06T00:00:00.000Z</published>
    <updated>2016-11-06T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>像工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库。</p><span id="more"></span><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>创建工程，最好是起名为 <code>xxxDemo</code> 例如 <code>AXKitDemo</code>，然后新建一个 target 名为 <code>AXKit</code>，并把原来的工程改名为 <code>AXKit</code>。（为了方便在 demo 中调试静态库）</li><li>新建一个 target ，选择类型为 <code>framework</code>。</li><li>在 <code>framework</code> 中创建需要封装的类，写好代码。</li><li>在 <code>Build Setting</code> 里更改参数，<code>Math-O Type</code> 为 <code>Static Library</code>。</li><li>在 <code>Build Phases -&gt; Headers</code> 里将需要暴露出来的头文件从 <code>Project</code> 移动到 <code>Public</code>。</li><li>添加一个 <code>Aggregate</code> 的 target，并添加运行脚本。目的是把编译出来的真机版和模拟器版的 <code>framework</code> 合并。</li><li>模拟器编译一下，真机编译一下，然后 <code>Aggregate</code> 编译一下，然后在项目的 <code>Products</code> 文件夹里就有了最终生成的静态库。</li></ol><h2 id="自动合成脚本"><a href="#自动合成脚本" class="headerlink" title="自动合成脚本"></a>自动合成脚本</h2><p><code>Aggregate</code> 的 Run Script 脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ &quot;$&#123;ACTION&#125;&quot; = &quot;build&quot; ]</span><br><span class="line">then</span><br><span class="line">INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line">DEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line">SIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line"></span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</span><br><span class="line">#ditto &quot;$&#123;DEVICE_DIR&#125;/Headers&quot; &quot;$&#123;INSTALL_DIR&#125;/Headers&quot;</span><br><span class="line"></span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line">#open &quot;$&#123;DEVICE_DIR&#125;&quot;</span><br><span class="line">#open &quot;$&#123;SRCROOT&#125;/Products&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;像工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://xaoxuu.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="Framework" scheme="https://xaoxuu.com/blog/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>如何从 UIImageView 指定的坐标点取色？</title>
    <link href="https://xaoxuu.com/blog/20160914/"/>
    <id>https://xaoxuu.com/blog/20160914/</id>
    <published>2016-09-14T00:00:00.000Z</published>
    <updated>2016-10-20T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发中有时候会遇到这样的需求，要给用户一个取色板，让用户从中自由地选取颜色，用来改变主题或者控制灯具的颜色等。这时候我们就需要获取一个视图的指定坐标的颜色值。</p><span id="more"></span><p>有时候我们可能会需要一个取色器，例如我的蓝牙灯项目，让用户从一个取色器中随意取色：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;CoreGraphics/CoreGraphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;UIImage+ColorAtPixel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">ColorAtPixel</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIColor</span> *)colorAtPixel:(<span class="built_in">CGPoint</span>)point &#123;</span><br><span class="line">    <span class="comment">// Cancel if point is outside image coordinates</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGRectContainsPoint</span>(<span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height), point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a 1x1 pixel byte array and bitmap context to draw the pixel into.</span></span><br><span class="line">    <span class="comment">// Reference: http://stackoverflow.com/questions/1042830/retrieving-a-pixel-alpha-value-for-a-uiimage</span></span><br><span class="line">    <span class="built_in">NSInteger</span> pointX = trunc(point.x);</span><br><span class="line">    <span class="built_in">NSInteger</span> pointY = trunc(point.y);</span><br><span class="line">    <span class="built_in">CGImageRef</span> cgImage = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(cgImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(cgImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="type">int</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> bytesPerRow = bytesPerPixel * <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pixelData[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(pixelData,</span><br><span class="line">                                                 <span class="number">1</span>,</span><br><span class="line">                                                 <span class="number">1</span>,</span><br><span class="line">                                                 bitsPerComponent,</span><br><span class="line">                                                 bytesPerRow,</span><br><span class="line">                                                 colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextSetBlendMode</span>(context, kCGBlendModeCopy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw the pixel we are interested in onto the bitmap context</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, -pointX, -pointY);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, (<span class="built_in">CGFloat</span>)width, (<span class="built_in">CGFloat</span>)height), cgImage);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert color values [0..255] to floats [0.0..1.0]</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red   = (<span class="built_in">CGFloat</span>)pixelData[<span class="number">0</span>] / <span class="number">255.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = (<span class="built_in">CGFloat</span>)pixelData[<span class="number">1</span>] / <span class="number">255.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue  = (<span class="built_in">CGFloat</span>)pixelData[<span class="number">2</span>] / <span class="number">255.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> alpha = (<span class="built_in">CGFloat</span>)pixelData[<span class="number">3</span>] / <span class="number">255.0</span>f;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:alpha];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="开始优化"><a href="#开始优化" class="headerlink" title="开始优化"></a>开始优化</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 从圆形范围内的指定点获取UIColor对象，并在block中执行操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param point      指定坐标点</span></span><br><span class="line"><span class="comment"> @param completion 取色完成后执行的block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)ax_getColorFromCircleWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="type">void</span> (^)(<span class="built_in">UIColor</span> *color))completion;</span><br></pre></td></tr></table></figure><p>调用起来应该是这样的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getColorFromCircleWithPoint:point completion:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用color</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>因为取色板一般是圆形的，如果坐标点超出了圆形但依然在imageView的frame内，可能会返回一些用户不期望的结果，用block巧妙地解决了这一问题，超出范围就不再有回调。如果你认为我的封装使用起来更加方便，可以继续阅读下面详细内容。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>推荐CocoaPods方式，在podfile中添加一行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AXKit&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在终端中执行 <code>pod install</code> 即可完成安装。</p><p>AXKit的全局头文件是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过CocoaPods或静态库方式安装</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;AXKit/AXKit.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通过手动方式</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AXKit.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h2><h3 id="从指定点获取RGBA值"><a href="#从指定点获取RGBA值" class="headerlink" title="从指定点获取RGBA值"></a>从指定点获取RGBA值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)ax_getRed:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)red green:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)green blue:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)blue alpha:(<span class="keyword">nullable</span> <span class="built_in">CGFloat</span> *)alpha withPoint:(<span class="built_in">CGPoint</span>)point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line"><span class="built_in">CGFloat</span> r,g,b,a;</span><br><span class="line">[imageView ax_getRed:&amp;r green:&amp;g blue:&amp;b alpha:&amp;a withPoint:point];</span><br><span class="line"><span class="comment">// 然后r/g/b/a就有了值</span></span><br></pre></td></tr></table></figure><p>需要自己创建变量，然后把地址传进去，然后才能用，不推荐直接使用。</p><h3 id="从指定点获取RGBA值，并在block中执行操作"><a href="#从指定点获取RGBA值，并在block中执行操作" class="headerlink" title="从指定点获取RGBA值，并在block中执行操作"></a>从指定点获取RGBA值，并在block中执行操作</h3><p>加了一个block，调用起来就方便许多：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)ax_getRGBAWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="type">void</span>(^)(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getRGBAWithPoint:point completion:^(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用red/green/blue/alpha</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>优点是不需要自己创建变量，直接调用方法，在block回调里直接获得red&#x2F;green&#x2F;blue&#x2F;alpha值。</p><blockquote><p>但是，很多时候，我们用的取色器是圆形的，就需要再进行一点封装。</p></blockquote><h3 id="从圆形范围内的指定点获取RGBA值，并在block中执行操作"><a href="#从圆形范围内的指定点获取RGBA值，并在block中执行操作" class="headerlink" title="从圆形范围内的指定点获取RGBA值，并在block中执行操作"></a>从圆形范围内的指定点获取RGBA值，并在block中执行操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)ax_getRGBAFromCircleWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="type">void</span> (^)(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getRGBAFromCircleWithPoint:point completion:^(<span class="built_in">CGFloat</span> red,<span class="built_in">CGFloat</span> green,<span class="built_in">CGFloat</span> blue,<span class="built_in">CGFloat</span> alpha)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用red/green/blue/alpha</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>跟第2种调用方法一模一样，但是区别是超出圆形范围之后就不再执行block回调了，这是一种<strong>安全</strong>的做法。如果不用block方式，那么即使超出了圆形范围，也一定会返回对应的rgba值，会造成不想要的后果。</p><blockquote><p>block的回调机制巧妙地解决了这个问题。</p></blockquote><p>如果我想直接获得一个UIColor对象呢，跟获取RGBA一样有三种方法。</p><h3 id="从指定点获取UIColor对象"><a href="#从指定点获取UIColor对象" class="headerlink" title="从指定点获取UIColor对象"></a>从指定点获取UIColor对象</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)ax_getColorWithPoint:(<span class="built_in">CGPoint</span>)point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line"><span class="built_in">UIColor</span> *color = [imageView ax_getColorWithPoint:point];</span><br><span class="line"><span class="comment">// 获得UIColor对象</span></span><br></pre></td></tr></table></figure><p>由声明可以看出来，返回的值是一个可空类型，因此这跟第一种方法一样是<strong>不安全</strong>的。</p><h3 id="从指定点获取UIColor对象，并在block中执行操作"><a href="#从指定点获取UIColor对象，并在block中执行操作" class="headerlink" title="从指定点获取UIColor对象，并在block中执行操作"></a>从指定点获取UIColor对象，并在block中执行操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)ax_getColorWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="type">void</span>(^)(<span class="built_in">UIColor</span> *color))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getColorWithPoint:point completion:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用color</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种方法比第4种要方便一些，如果超出UIImageView的时候就不执行block里的代码。</p><h3 id="从圆形范围内的指定点获取UIColor对象，并在block中执行操作"><a href="#从圆形范围内的指定点获取UIColor对象，并在block中执行操作" class="headerlink" title="从圆形范围内的指定点获取UIColor对象，并在block中执行操作"></a>从圆形范围内的指定点获取UIColor对象，并在block中执行操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)ax_getColorFromCircleWithPoint:(<span class="built_in">CGPoint</span>)point completion:(<span class="type">void</span> (^)(<span class="built_in">UIColor</span> *color))completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来是这样的：</span></span><br><span class="line"><span class="comment">// 已知imageView、point</span></span><br><span class="line">[imageView ax_getColorFromCircleWithPoint:point completion:^(<span class="built_in">UIColor</span> *color)&#123;</span><br><span class="line">  <span class="comment">// 在这里直接用color</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>引言中的Demo用的就是这一种方法，在圆形取色器中取色，既方便又安全。</p><h2 id="附：Gist"><a href="#附：Gist" class="headerlink" title="附：Gist"></a>附：Gist</h2><script src="https://gist.github.xaox.cc/xaoxuu/27de7d2fe02530faab0147d8001a2921.js"></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发中有时候会遇到这样的需求，要给用户一个取色板，让用户从中自由地选取颜色，用来改变主题或者控制灯具的颜色等。这时候我们就需要获取一个视图的指定坐标的颜色值。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://xaoxuu.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="开源库" scheme="https://xaoxuu.com/blog/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ObjC 使用链式语法更优雅地管理沙盒文件</title>
    <link href="https://xaoxuu.com/blog/20160912/"/>
    <id>https://xaoxuu.com/blog/20160912/</id>
    <published>2016-09-12T00:00:00.000Z</published>
    <updated>2016-10-20T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>假如你需要把一个字典或者别的什么东西保存到沙盒里，你准备怎么做？也许你已经条件反射的想到了操作步骤……其实，你可以不必每次都那么老老实实的把每一步写出来，一行代码就可以了：【路径+保存文件】两个关键点，组成一条链式语法。</p><span id="more"></span><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="string">@&quot;文件名&quot;</span>.cachePath.save(要保存的内容);</span><br></pre></td></tr></table></figure><h2 id="接入AXKit"><a href="#接入AXKit" class="headerlink" title="接入AXKit"></a>接入AXKit</h2><p>如果你的项目里还没有AXKit，可以在pod文件里添加一条 <code>pod &#39;AXKit&#39;</code> 进行接入，也可移步至<a href="https://xaoxuu.com/wiki/axkit">AXKit在线文档</a>查看详细的安装和使用方法。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>我封装了几个常用的沙盒路径，如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)mainBundlePath; <span class="comment">// mainBundlePath就是主工程项目里的文件路径</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)docPath; <span class="comment">// 文档，iTunes会备份，适合保存重要的数据</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cachePath; <span class="comment">// 缓存，iTunes不会备份，适合保存不太重要的较大的数据</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)tempPath; <span class="comment">// 临时文件，iTunes不会备份，系统空闲时会自动删除，设备重启时也会删除</span></span><br></pre></td></tr></table></figure><p>除此之外，还提供了所有的路径，通过枚举的方式获取：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *(^)(<span class="built_in">NSSearchPathDirectory</span>))path; <span class="comment">// 传入NSSearchPathDirectory枚举就可得到路径</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在沙盒的文档路径里有个叫 <code>abc.plist</code> 的文件，它的描述就是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="string">@&quot;abc.plist&quot;</span>.docPath;</span><br></pre></td></tr></table></figure><h3 id="路径的拼接"><a href="#路径的拼接" class="headerlink" title="路径的拼接"></a>路径的拼接</h3><p>任何一个字符串都可以使用 <code>.append()</code> 进行拼接。</p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>保存的方法目前提供有四个：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>(^)(<span class="type">id</span>))savePlist;</span><br><span class="line">- (<span class="type">BOOL</span>(^)(<span class="built_in">NSObject</span>&lt;<span class="built_in">NSCoding</span>&gt; *))saveArchivedPlist;</span><br><span class="line">- (<span class="type">BOOL</span>(^)(<span class="built_in">NSObject</span>&lt;<span class="built_in">NSCoding</span>&gt; *))saveArchivedObject;</span><br><span class="line">- (<span class="type">BOOL</span>(^)(<span class="type">id</span> &lt;<span class="built_in">NSCoding</span>&gt;))save;</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><ol><li>在doc路径下保存一个名为”arr.plist”的文件：</li></ol>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> array];</span><br><span class="line"><span class="type">BOOL</span> result = <span class="string">@&quot;arr&quot;</span>.docPath.savePlist(arr);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在cache路径下归档一个名为”myfile.plist”的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyProfiles *myfile = [[MyProfiles alloc] init];</span><br><span class="line"><span class="comment">// MyProfiles类需实现NSCoding协议</span></span><br><span class="line"><span class="type">BOOL</span> result = <span class="string">@&quot;myfile&quot;</span>.cachePath.saveArchivedPlist(myfile);</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>读取的方法目前提供了七个：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">NSArray</span> *)readArray;</span><br><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">NSDictionary</span> *)readDictionary;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)readArchivedPlist;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)readJson;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)readTxt;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)readArchivedFile;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)readArchivedObject;</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol><li><p>在doc路径下读取一个名为”arr.plist”的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = <span class="string">@&quot;arr&quot;</span>.docPath.readArray;</span><br></pre></td></tr></table></figure></li><li><p>在cache路径下解档一个名为”myfile.plist”的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyProfiles *myfile = <span class="string">@&quot;myfile&quot;</span>.cachePath.readArchivedPlist;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>遍历路径下所有文件</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取doc/myDir 路径下所有的扩展名为&quot;plist&quot;文件路径</span></span><br><span class="line"><span class="built_in">NSArray</span> *paths = <span class="string">@&quot;myDir&quot;</span>.docPath.subpaths(<span class="string">@&quot;plist&quot;</span>);</span><br><span class="line"><span class="comment">// 如果传入值为空，则不区分扩展名获取所有文件路径</span></span><br><span class="line"><span class="built_in">NSArray</span> *paths2 = <span class="string">@&quot;myDir&quot;</span>.docPath.subpaths(<span class="string">@&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// paths里面装的是doc/myDir路径下的所有文件完整路径</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>结构：【路径+删除】</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)removePlist;</span><br><span class="line">- (<span class="type">BOOL</span>)removeJson;</span><br><span class="line">- (<span class="type">BOOL</span>)removeTxt;</span><br><span class="line">- (<span class="type">BOOL</span>)remove;</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><ol><li><p>在doc路径下删除一个名为”arr.plist”的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">BOOL</span> result = <span class="string">@&quot;arr.plist&quot;</span>.docPath.remove;</span><br></pre></td></tr></table></figure></li><li><p>在cache路径下删除一个名为”myfile.plist”的文件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyProfiles *myfile = <span class="string">@&quot;myfile.plist&quot;</span>.cachePath.remove;</span><br></pre></td></tr></table></figure></li></ol><h2 id="详细文档"><a href="#详细文档" class="headerlink" title="详细文档"></a>详细文档</h2><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://xaoxuu.com/wiki/axkit/" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://xaoxuu.com/wiki/axkit/</span><span class="cap link fs12">https://xaoxuu.com/wiki/axkit/</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;假如你需要把一个字典或者别的什么东西保存到沙盒里，你准备怎么做？也许你已经条件反射的想到了操作步骤……其实，你可以不必每次都那么老老实实的把每一步写出来，一行代码就可以了：【路径+保存文件】两个关键点，组成一条链式语法。&lt;/p&gt;</summary>
    
    
    
    <category term="设计开发" scheme="https://xaoxuu.com/blog/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://xaoxuu.com/blog/tags/ios/"/>
    
    <category term="链式语法" scheme="https://xaoxuu.com/blog/tags/%E9%93%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/"/>
    
    <category term="沙盒" scheme="https://xaoxuu.com/blog/tags/%E6%B2%99%E7%9B%92/"/>
    
    <category term="缓存" scheme="https://xaoxuu.com/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>十万蝼蚁不如一个巨人</title>
    <link href="https://xaoxuu.com/blog/20160522/"/>
    <id>https://xaoxuu.com/blog/20160522/</id>
    <published>2016-05-22T00:00:00.000Z</published>
    <updated>2016-05-22T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin poetry"><div class="title">Game&nbsp;of&nbsp;Thrones</div><div class="body"><p>混乱不是深渊。<br>混乱是阶梯。<br>很多人想往上爬 却失败了<br>且永无机会再试。<br>他们坠落而亡。<br>有人本有机会攀爬，<br>但他们拒绝了。<br>他们守着王国不放<br>守着诸神<br>守着爱情<br>尽皆幻想。<br>唯有阶梯是真实存在。<br>攀爬才是生活的全部。</p></div><div class="footer">台词节选</div></div><span id="more"></span><h2 id="物竞天择"><a href="#物竞天择" class="headerlink" title="物竞天择"></a>物竞天择</h2><p>世界是残酷的，强者以弱者为食。</p><h2 id="个体意识"><a href="#个体意识" class="headerlink" title="个体意识"></a>个体意识</h2><p>每个人都是一个独立的个体，群众的力量再强大，他们也不属于你，只是在某些时刻能够帮到你。与其成为一个强大群体中微不足道的一员，不如成为一个强大的个体。</p><h2 id="群体意识"><a href="#群体意识" class="headerlink" title="群体意识"></a>群体意识</h2><p>社会不需要太多巨人，需要团结在一起才能发挥威力的蚂蚁。像牧羊一样，管好头羊，其他都会乖乖跟着头羊，即使有不听话的，也不会威胁到牧羊人。但如果羊羔中有几个或更多比牧羊人掌管的头羊更加强壮的个体，牧羊人就会地位不保。这些羊羔如果足够聪明的话，是不应该过早展露实力的，冲动的结局则是变成一桌美食。</p><h2 id="珍惜当下"><a href="#珍惜当下" class="headerlink" title="珍惜当下"></a>珍惜当下</h2><p>活着本来就是如临深渊，如履薄冰，永远不能保证下一刻不会遭遇意外。每天早上睁开眼能够看到熟悉的世界，能够记得自己走过的人生，都值得庆幸。不做别人的棋子，更不教育自己的后代如何做好这一颗棋子，生活是你自己的。</p><h2 id="时间、效率、实力"><a href="#时间、效率、实力" class="headerlink" title="时间、效率、实力"></a>时间、效率、实力</h2><p>我一直把时间作为衡量价值的标准，因为只有时间是有限的、平等的。效率则是将时间转化成实力的最关键一步，是靠自己的努力获得的，谁也赠予不了，谁也偷不了。实力则是我的人生观中的价值所在，也是唯一的追求。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>你可以选择随遇而安，只需要一双发现美的眼睛和积极乐观的心态。</p><p>也可以攀爬，你会发现到处都是陷阱，一步跌落，就是万丈深渊。哪怕你认为现在的处境已经跌落人生谷底，但是事实是前方依然会有更深的陷阱在等着你。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tag-plugin poetry&quot;&gt;&lt;div class=&quot;title&quot;&gt;Game&amp;nbsp;of&amp;nbsp;Thrones&lt;/div&gt;&lt;div class=&quot;body&quot;&gt;&lt;p&gt;混乱不是深渊。&lt;br&gt;混乱是阶梯。&lt;br&gt;很多人想往上爬 却失败了&lt;br&gt;且永无机会再试。&lt;br&gt;他们坠落而亡。&lt;br&gt;有人本有机会攀爬，&lt;br&gt;但他们拒绝了。&lt;br&gt;他们守着王国不放&lt;br&gt;守着诸神&lt;br&gt;守着爱情&lt;br&gt;尽皆幻想。&lt;br&gt;唯有阶梯是真实存在。&lt;br&gt;攀爬才是生活的全部。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;台词节选&lt;/div&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="胡思乱想" scheme="https://xaoxuu.com/blog/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>我关于未来的智能生活的畅想</title>
    <link href="https://xaoxuu.com/blog/20160211/"/>
    <id>https://xaoxuu.com/blog/20160211/</id>
    <published>2016-02-11T00:00:00.000Z</published>
    <updated>2016-09-20T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我从小就对「活着」的机械十分着迷，就是我们现在所说的人工智能，当我初次了解到这个概念的时候，<del>就确定了我将奉献一生的事业</del>。</p><p>然而梦想很遥远，遥远到我这辈子无法见证<a href="https://baike.baidu.com/item/%E6%88%91%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA/1189079">《I, Robot》</a>那样的时代。</p><span id="more"></span><h2 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h2><p>我相信，不久的未来会有越来越多的东西要接入互联网，接入互联网就可以用手机控制。<br>网络就像神经，门窗联了网，门窗就活了，扫把联了网，扫把就活了。等所有的家具家电都联网的时候，就需要一个平台来管理这些智能硬件了。</p><p>所有接入互联网的传感器都成为了这个智能系统的感官，神经将这些信息传递到可以分析、处理数据的终端，经过计算后作出应答，并由这些神经传递指令到相应的智能设备上。</p><p>人与人、人与物之间的联系就更加紧密了，随时的远程互动，远程协助都更加方便了。<br>当然，这中间涉及到的隐私和网络安全问题也十分重要，但问题总要解决，不能因噎废食。</p><p>传统硬件，将一步一步被替换为智能硬件，至少是能用手机 app 控制，用手机 app 来控制，就是一种雏形了。毕竟目前没有足够多的智能硬件，没有到需要开发一个系统的程度。</p><h2 id="平台化"><a href="#平台化" class="headerlink" title="平台化"></a>平台化</h2><p>现在智能硬件也越来越多了，网络也十分发达了，但是它们的「语言」不同，各厂商的产品都用自己的标准，不同厂商之间的硬件是无法协同工作的。它们需要一个协议、或者一个平台，来实现合作。平台，也许就是智能家居时代来临的一个必要条件吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我从小就对「活着」的机械十分着迷，就是我们现在所说的人工智能，当我初次了解到这个概念的时候，&lt;del&gt;就确定了我将奉献一生的事业&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;然而梦想很遥远，遥远到我这辈子无法见证&lt;a href=&quot;https://baike.baidu.com/item/%E6%88%91%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA/1189079&quot;&gt;《I, Robot》&lt;/a&gt;那样的时代。&lt;/p&gt;</summary>
    
    
    
    <category term="闲聊时间" scheme="https://xaoxuu.com/blog/categories/%E9%97%B2%E8%81%8A%E6%97%B6%E9%97%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>如何进行有效的团队合作</title>
    <link href="https://xaoxuu.com/blog/20130206/"/>
    <id>https://xaoxuu.com/blog/20130206/</id>
    <published>2013-02-06T00:00:00.000Z</published>
    <updated>2015-03-11T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文只是我在大学时期关于小组决策效率与分工方面的思考，可能不适用于其它场景。</p><p>在任何一个团队中，我始终都是先做一个观察者，因为在掌握足够的信息之前，我的看法可能是片面的，由此产生的观点及推论发表出来可能会误导人。</p><span id="more"></span><h2 id="偏执"><a href="#偏执" class="headerlink" title="偏执"></a>偏执</h2><p>我印象非常深刻的一次经历：初二的时候，物理老师提问一个思考问题，我的答案和班上其它同学的都不一样，我有点犹豫了，老师说了一句话：<span class="tag-plugin quot" type="text">有时候，真理往往掌握在少数人手中</span>，而正是那一次的正确的坚持，让我受益匪浅。这件事在我的成长过程中起到了非常重要的作用，所以现在我是一个对认定事情非常偏执的人。</p><p>要相信自己有理有据的判断，在追求真理的路上敢于以一敌众，后来的某些经历也表明，即使所有人都反对你，你也未必要因此放弃，因为真相总有浮出水面的时候。</p><h2 id="交流意见"><a href="#交流意见" class="headerlink" title="交流意见"></a>交流意见</h2><p>然而我却又是一个不爱争论的人，往往我发表完我的意见，也理解了对方的意见之后，就不会再继续谈论了。</p><p>为什么不说服别人呢？我会尝试去说服别人，但是当说服的难度远远大于它所带来的意义的时候，我就放弃了。我没有当过领导者，所以说服别人对我来说也不是个必选项，尤其是考虑到这个过程所花费的时间成本跟成果的价值孰轻孰重，我会越来越谨慎行事。</p><h2 id="独立决策与民主决策"><a href="#独立决策与民主决策" class="headerlink" title="独立决策与民主决策"></a>独立决策与民主决策</h2><p>两者并非不可兼得。为什么要兼得？为了效率。</p><p>我的眼中只有效率，不在乎形式，假如一个问题有两种既定方案，如果三十个人讨论半天各执己见，有些人选择A方案，有些人选择B方案，选择A方案的人试图说服选择B方案的人，选择B方案的人也试图说服选择A方案的人，最终的结果可能是选A也可能是选B，也可能出来一种新的C方案。</p><p><strong>不是所有人都能看见真相</strong>，经过讨论可能会让更多人走向正确的道路，也有可能会让少部分持有最佳方案却意志不够坚定的人被说服放弃，历史上这样的例子并不少见，每时每刻，都有数不清的人会在讨论中与<strong>成为历史</strong>或<strong>被历史遗忘</strong>擦肩而过。</p><p>我们更需要的是：交流意见 –&gt; 独立思考 –&gt; 独立决策。</p><h2 id="合力不等于力量的叠加"><a href="#合力不等于力量的叠加" class="headerlink" title="合力不等于力量的叠加"></a>合力不等于力量的叠加</h2><p>力量都是有方向的，方向相同则相加。很多时候一次糟糕的合作导致若干力量相抵消，最终还不如一个人的效率高，一个聪明的团队应该在力量和方向上都作出最优选择。</p><p>我自认为是一个没有大家所谓的“团队精神”的人，因为我认为即使我们做不到最好，也不要硬撑着搞形式，作出最糟糕的选择，效率才是最终目的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文只是我在大学时期关于小组决策效率与分工方面的思考，可能不适用于其它场景。&lt;/p&gt;
&lt;p&gt;在任何一个团队中，我始终都是先做一个观察者，因为在掌握足够的信息之前，我的看法可能是片面的，由此产生的观点及推论发表出来可能会误导人。&lt;/p&gt;</summary>
    
    
    
    <category term="胡思乱想" scheme="https://xaoxuu.com/blog/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
    
  </entry>
  
</feed>
